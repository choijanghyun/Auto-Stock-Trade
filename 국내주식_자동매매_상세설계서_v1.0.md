# ğŸ“Š êµ­ë‚´ ì£¼ì‹ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ìƒì„¸ì„¤ê³„ì„œ (Detailed Design Document)

**í”„ë¡œì íŠ¸ëª…:** KIS Auto Trading System (KATS)
**ë²„ì „:** v1.0
**ì‘ì„±ì¼:** 2026-02-13
**ê¸°ìˆ  ìŠ¤íƒ:** Python 3.11+ / KIS Developers REST API & WebSocket / SQLite & PostgreSQL
**ì„¤ê³„ ê¸°ë°˜:** ì„¸ê³„ ë² ìŠ¤íŠ¸ì…€ëŸ¬ TOP 20 íŠ¸ë ˆì´ë”© ë„ì„œ ë¶„ì„ ê¸°ë°˜ ì „ëµ ì—”ì§„

---

## ëª©ì°¨

1. [ì‹œìŠ¤í…œ ê°œìš”](#1-ì‹œìŠ¤í…œ-ê°œìš”)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#2-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ](#3-ë°ì´í„°ë² ì´ìŠ¤-ìŠ¤í‚¤ë§ˆ)
4. [í•µì‹¬ ëª¨ë“ˆ ë° í´ë˜ìŠ¤ êµ¬ì¡°](#4-í•µì‹¬-ëª¨ë“ˆ-ë°-í´ë˜ìŠ¤-êµ¬ì¡°)
5. [KIS API íŠ¹í™” ì„¤ê³„](#5-kis-api-íŠ¹í™”-ì„¤ê³„)
6. [ì „ëµ ì—”ì§„ ìƒì„¸ ì„¤ê³„](#6-ì „ëµ-ì—”ì§„-ìƒì„¸-ì„¤ê³„)
7. [ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—”ì§„](#7-ë¦¬ìŠ¤í¬-ê´€ë¦¬-ì—”ì§„)
8. [ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ](#8-ëª¨ë‹ˆí„°ë§-ë°-ì•Œë¦¼-ì‹œìŠ¤í…œ)
9. [AI ìì—°ì–´ ì²˜ë¦¬ (MCP í†µí•©)](#9-ai-ìì—°ì–´-ì²˜ë¦¬-mcp-í†µí•©)
10. [ì˜ˆì™¸ ì²˜ë¦¬ ë° ì¥ì•  ëŒ€ì‘](#10-ì˜ˆì™¸-ì²˜ë¦¬-ë°-ì¥ì• -ëŒ€ì‘)
11. [ë°°í¬ ë° ìš´ì˜](#11-ë°°í¬-ë°-ìš´ì˜)

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 

í•œêµ­íˆ¬ìì¦ê¶Œ(KIS Developers) REST API ë° WebSocketì„ í™œìš©í•˜ì—¬, ì„¸ê³„ ë² ìŠ¤íŠ¸ì…€ëŸ¬ TOP 20 íŠ¸ë ˆì´ë”© ë„ì„œì—ì„œ ê²€ì¦ëœ ì „ëµ ì•Œê³ ë¦¬ì¦˜ì„ ìë™ ì‹¤í–‰í•˜ëŠ” êµ­ë‚´ ì£¼ì‹ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì„ ì„¤ê³„í•œë‹¤. ë³¸ ì‹œìŠ¤í…œì€ ë³€ë™ì„± ëŒíŒŒ ì „ëµ, ê·¸ë¦¬ë“œ ë§¤ë§¤, ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ë“± í•µì‹¬ ì „ëµ ì™¸ì—ë„ SEPA ëª¨ë©˜í…€ ëŒíŒŒ, CAN SLIM, Triple Screen, VWAP ë°”ìš´ìŠ¤ ë“± ê³ ê¸‰ ì „ëµì„ í¬í•¨í•˜ë©°, ì •êµí•œ ë¦¬ìŠ¤í¬ ê´€ë¦¬ì™€ ë§¤ë§¤ ë³µê¸° ì‹œìŠ¤í…œì„ í†µí•© ì œê³µí•œë‹¤.

### 1.2 í•µì‹¬ ì„¤ê³„ ì›ì¹™

| ì›ì¹™ | ì„¤ëª… | ê·¼ê±° |
|------|------|------|
| **ì¢…ëª© ì„ ì • ìš°ì„ ** | ì‹œê°€ì´ì•¡, ê±°ë˜ëŒ€ê¸ˆ, ê¸°ìˆ ì Â·ê¸°ë³¸ì  ì¡°ê±´ì„ ëª¨ë‘ ì¶©ì¡±í•˜ëŠ” ì¢…ëª©ë§Œ ë§¤ë§¤ | Minervini, O'Neil: "ì¢…ëª© ì„ ì •ì´ ìˆ˜ìµì˜ 80%ë¥¼ ê²°ì •" |
| **í¬ì§€ì…˜ ì‚¬ì´ì§• ì¤‘ì‹¬** | Rë°°ìˆ˜ ê¸°ë°˜ ë¦¬ìŠ¤í¬ í†µì œ, SQNìœ¼ë¡œ ì‹œìŠ¤í…œ í’ˆì§ˆ ì¸¡ì • | Van Tharp: "í¬ì§€ì…˜ ì‚¬ì´ì§•ì´ ì„±ê³¼ ë³€ë™ì„±ì˜ 91%ë¥¼ ê²°ì •" |
| **ê¸°ê³„ì  ì†ì ˆ** | ì§„ì… ì „ ì†ì ˆê°€ ê²°ì •, ì˜ˆì™¸ ì—†ëŠ” ìë™ ì‹¤í–‰ | Douglas, Minervini: "-1R ì´ˆê³¼ ì†ì‹¤ì€ ê·œì¹™ ìœ„ë°˜ ì‹ í˜¸" |
| **í˜„ê¸ˆì´ ìµœê³ ì˜ í¬ì§€ì…˜** | ìƒìŠ¹ì¥ 30%+, í•˜ë½ì¥ 70%+ í˜„ê¸ˆ ìœ ì§€ | Elder, Livermore |
| **ì¸¡ì •ê³¼ ê°œì„ ** | ë§¤ë§¤ ì¼ì§€ ìë™ ê¸°ë¡, ì£¼ê°„/ì›”ê°„ ì„±ê³¼ ë¦¬ë·° ìë™ ìƒì„± | Steenbarger: "ì¸¡ì •í•˜ì§€ ì•Šìœ¼ë©´ ê°œì„ í•  ìˆ˜ ì—†ë‹¤" |

### 1.3 ë§¤ë§¤ ëª¨ë“œ

| ëª¨ë“œ | ì„¤ëª… | API í˜¸ì¶œ |
|------|------|---------|
| **ì‹¤ì „ ë§¤ë§¤ (Live)** | ì‹¤ì œ ì£¼ë¬¸ ì²´ê²°, ì‹¤ê³„ì¢Œ ìì‚° ë³€ë™ | KIS REST API ì‹¤ì „ ë„ë©”ì¸ |
| **ê°€ìƒ ë§¤ë§¤ (Paper)** | ì‹¤ì‹œê°„ í˜¸ê°€ ê¸°ë°˜ ê°€ìƒ ì²´ê²°, DB ê°€ìƒ ê³„ì¢Œ ì—…ë°ì´íŠ¸ | ì‹œì„¸ APIë§Œ í˜¸ì¶œ, ì£¼ë¬¸ API ë¯¸í˜¸ì¶œ |

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ ì•„í‚¤í…ì²˜ ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        KATS (KIS Auto Trading System)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Auth    â”‚  Market  â”‚ Strategy â”‚  Risk    â”‚  Order   â”‚  AI/NLP      â”‚
â”‚  Manager â”‚  Data    â”‚  Engine  â”‚  Manager â”‚  Manager â”‚  (MCP)       â”‚
â”‚          â”‚  Hub     â”‚          â”‚          â”‚          â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Core Infrastructure Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ KIS REST â”‚ â”‚ KIS WS   â”‚ â”‚ Database â”‚ â”‚ Logger   â”‚ â”‚ Notifier â”‚ â”‚
â”‚  â”‚ Client   â”‚ â”‚ Client   â”‚ â”‚ (SQLite/ â”‚ â”‚ (Trade   â”‚ â”‚ (Slack/  â”‚ â”‚
â”‚  â”‚          â”‚ â”‚          â”‚ â”‚ PgSQL)   â”‚ â”‚  Journal)â”‚ â”‚  Kakao)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ë°ì´í„° íë¦„ë„

```
[KIS REST API] â”€â”€ì‹œì„¸/ì”ê³ ì¡°íšŒâ”€â”€â–¶ [Market Data Hub] â”€â”€ê°€ê²©/ì§€í‘œâ”€â”€â–¶ [Strategy Engine]
                                        â”‚                              â”‚
[KIS WebSocket] â”€â”€ì‹¤ì‹œê°„ì²´ê²°/í˜¸ê°€â”€â”€â–¶     â”‚                     ì „ëµ ì‹ í˜¸ â”‚
                                        â”‚                              â–¼
                                        â”‚                     [Risk Manager]
                                        â”‚                       â”‚  ê²€ì¦ í†µê³¼
                                        â”‚                       â–¼
                                        â”‚              [Order Manager] â”€â”€ì£¼ë¬¸â”€â”€â–¶ [KIS REST API]
                                        â”‚                       â”‚
                                        â”‚                       â–¼
                                        â”‚              [Trade Journal DB]
                                        â”‚                       â”‚
                                        â–¼                       â–¼
                                  [Monitoring &          [Notification
                                   Statistics]            Service]
```

### 2.3 ëª¨ë“ˆ ê³„ì¸µ êµ¬ì¡°

```
kats/
â”œâ”€â”€ main.py                         # ì—”íŠ¸ë¦¬í¬ì¸íŠ¸, ìŠ¤ì¼€ì¤„ëŸ¬
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.py                 # í™˜ê²½ ì„¤ì • (API í‚¤, DB ê²½ë¡œ, ì „ëµ íŒŒë¼ë¯¸í„°)
â”‚   â””â”€â”€ constants.py                # ìƒìˆ˜ ì •ì˜ (ë“±ê¸‰ ê¸°ì¤€, ì‹œê°„ëŒ€, ì´ë²¤íŠ¸ ìº˜ë¦°ë”)
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ token_manager.py            # í† í° ìë™ ë°œê¸‰/ê°±ì‹ /ìºì‹±
â”‚   â””â”€â”€ hashkey_manager.py          # í•´ì‹œí‚¤ ìƒì„± ë° ë³´ì•ˆ ì²˜ë¦¬
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ kis_rest_client.py          # REST API ë˜í¼ (Throttling í¬í•¨)
â”‚   â”œâ”€â”€ kis_websocket_client.py     # WebSocket í´ë¼ì´ì–¸íŠ¸ (ì¬ì—°ê²° ì „ëµ)
â”‚   â””â”€â”€ rate_limiter.py             # API í˜¸ì¶œ ì œí•œ ê´€ë¦¬
â”œâ”€â”€ market/
â”‚   â”œâ”€â”€ data_hub.py                 # ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘/ìºì‹± í—ˆë¸Œ
â”‚   â”œâ”€â”€ stock_screener.py           # ì¢…ëª© ìŠ¤ìºë‹ (Minervini Trend Template)
â”‚   â”œâ”€â”€ indicator_calculator.py     # ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° (MA, RSI, VWAP, BB ë“±)
â”‚   â””â”€â”€ sector_analyzer.py          # ì„¹í„° ê°•ì•½ ë¶„ì„
â”œâ”€â”€ strategy/
â”‚   â”œâ”€â”€ base_strategy.py            # ì „ëµ ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ volatility_breakout.py      # ë³€ë™ì„± ëŒíŒŒ ì „ëµ (ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤)
â”‚   â”œâ”€â”€ grid_trading.py             # ê·¸ë¦¬ë“œ ë§¤ë§¤ ì „ëµ
â”‚   â”œâ”€â”€ dividend_switching.py       # ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ì „ëµ
â”‚   â”œâ”€â”€ sepa_momentum.py            # SEPA ëª¨ë©˜í…€ ëŒíŒŒ (Minervini)
â”‚   â”œâ”€â”€ gap_and_go.py               # Gap & Go ëˆŒë¦¼ëª© ë§¤ìˆ˜ (Cameron/Aziz)
â”‚   â”œâ”€â”€ canslim_breakout.py         # CAN SLIM ëŒíŒŒ ë§¤ë§¤ (O'Neil)
â”‚   â”œâ”€â”€ triple_screen.py            # Triple Screen ì¶”ì„¸ ì¶”ì¢… (Elder)
â”‚   â”œâ”€â”€ vwap_bounce.py              # VWAP ë°”ìš´ìŠ¤ (Carter/Aziz)
â”‚   â”œâ”€â”€ dead_cat_bounce.py          # ë°ë“œìº£ ë°”ìš´ìŠ¤ - í•˜ë½ì¥ (Staley/Turner)
â”‚   â”œâ”€â”€ inverse_etf.py              # ì¸ë²„ìŠ¤ ETF ë§¤ë§¤ - í•˜ë½ì¥ (Staley/Pring)
â”‚   â”œâ”€â”€ range_trading.py            # ë°•ìŠ¤ê¶Œ ë ˆì¸ì§€ ë§¤ë§¤ - í•˜ë½ì¥ (Nison/Murphy)
â”‚   â”œâ”€â”€ oversold_reversal.py        # ê³¼ë§¤ë„ ì—­ë°œìƒ - í•˜ë½ì¥ (Steenbarger)
â”‚   â””â”€â”€ strategy_selector.py        # ì¥ì„¸ë³„ ì „ëµ ìë™ ì„ íƒê¸°
â”œâ”€â”€ risk/
â”‚   â”œâ”€â”€ risk_manager.py             # í†µí•© ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—”ì§„
â”‚   â”œâ”€â”€ position_sizer.py           # Van Tharp Rë°°ìˆ˜ ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•
â”‚   â”œâ”€â”€ trailing_stop.py            # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ (ê³ ì •%/MA/ATR/ìº”ë“¤)
â”‚   â”œâ”€â”€ daily_kill_switch.py        # ì¼ì¼ ì†ì‹¤ ì°¨ë‹¨ (Kill-Switch)
â”‚   â”œâ”€â”€ drawdown_protocol.py        # ë“œë¡œìš°ë‹¤ìš´ ë‹¨ê³„ë³„ ëŒ€ì‘ í”„ë¡œí† ì½œ
â”‚   â””â”€â”€ grade_allocator.py          # ì¢…ëª© ë“±ê¸‰ë³„ ë¹„ì¤‘ ë°°ë¶„ (A/B/C)
â”œâ”€â”€ order/
â”‚   â”œâ”€â”€ order_manager.py            # ì£¼ë¬¸ ìƒì„±/ì‹¤í–‰/ì·¨ì†Œ ê´€ë¦¬
â”‚   â”œâ”€â”€ paper_trading.py            # ê°€ìƒ ë§¤ë§¤ ì—”ì§„
â”‚   â””â”€â”€ pyramid_manager.py          # í”¼ë¼ë¯¸ë”©(ë¶„í•  ì§„ì…) ê´€ë¦¬
â”œâ”€â”€ journal/
â”‚   â”œâ”€â”€ trade_journal.py            # ë§¤ë§¤ ì¼ì§€ ìë™ ê¸°ë¡
â”‚   â”œâ”€â”€ performance_analyzer.py     # Rë°°ìˆ˜, SQN, ìŠ¹ë¥  ë“± ì„±ê³¼ ë¶„ì„
â”‚   â””â”€â”€ review_generator.py         # ì¼ê°„/ì£¼ê°„/ì›”ê°„ ë¦¬ë·° ìë™ ìƒì„±
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ mcp_handler.py              # MCP ìì—°ì–´ ëª…ë ¹ ì²˜ë¦¬
â”‚   â””â”€â”€ nlp_parser.py               # ìì—°ì–´ â†’ ë§¤ë§¤ ëª…ë ¹ ë³€í™˜
â”œâ”€â”€ notification/
â”‚   â”œâ”€â”€ notifier.py                 # ì•Œë¦¼ í†µí•© ì¸í„°í˜ì´ìŠ¤
â”‚   â””â”€â”€ channels/                   # Slack, Kakao, Telegram ë“±
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ models.py                   # ORM ëª¨ë¸ ì •ì˜
â”‚   â”œâ”€â”€ repository.py               # ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´
â”‚   â””â”€â”€ migrations/                 # DB ë§ˆì´ê·¸ë ˆì´ì…˜
â””â”€â”€ utils/
    â”œâ”€â”€ event_calendar.py           # íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ìº˜ë¦°ë” (FOMC, ë§Œê¸°ì¼ ë“±)
    â”œâ”€â”€ market_regime.py            # ì¥ì„¸ íŒë‹¨ (ìƒìŠ¹/í•˜ë½/ë³´í•©)
    â””â”€â”€ logger.py                   # êµ¬ì¡°í™” ë¡œê¹…
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### 3.1 ERD ê°œìš”

```
[stocks] 1â”€â”€N [trades]
[stocks] 1â”€â”€N [watchlist]
[trades] 1â”€â”€1 [trade_journal]
[trades] Nâ”€â”€1 [strategies]
[daily_stats] â”€â”€â”€â”€ ì¼ë³„ ì§‘ê³„
[monthly_stats] â”€â”€ ì›”ë³„ ì§‘ê³„
[system_config] â”€â”€ ì„¤ì • ì •ë³´
[drawdown_log] â”€â”€ ë“œë¡œìš°ë‹¤ìš´ ì´ë ¥
[event_calendar] â”€ íŠ¹ìˆ˜ ì´ë²¤íŠ¸
```

### 3.2 í…Œì´ë¸” ì •ì˜

#### 3.2.1 stocks (ì¢…ëª© ë§ˆìŠ¤í„°)

```sql
CREATE TABLE stocks (
    stock_code      VARCHAR(10) PRIMARY KEY,          -- ì¢…ëª©ì½”ë“œ (ì˜ˆ: 005930)
    stock_name      VARCHAR(100) NOT NULL,             -- ì¢…ëª©ëª…
    market          VARCHAR(10) NOT NULL,              -- KOSPI / KOSDAQ
    sector          VARCHAR(50),                       -- ì—…ì¢…
    market_cap      BIGINT,                            -- ì‹œê°€ì´ì•¡ (ì›)
    grade           CHAR(1) CHECK (grade IN ('A','B','C','D')),  -- ë“±ê¸‰
    -- Minervini Trend Template ì§€í‘œ
    ma_50           DECIMAL(12,2),                     -- 50ì¼ ì´ë™í‰ê· 
    ma_150          DECIMAL(12,2),                     -- 150ì¼ ì´ë™í‰ê· 
    ma_200          DECIMAL(12,2),                     -- 200ì¼ ì´ë™í‰ê· 
    week52_high     DECIMAL(12,2),                     -- 52ì£¼ ìµœê³ ê°€
    week52_low      DECIMAL(12,2),                     -- 52ì£¼ ìµœì €ê°€
    rs_rank         DECIMAL(5,2),                      -- ìƒëŒ€ê°•ë„ (ì½”ìŠ¤í”¼ ëŒ€ë¹„, ë°±ë¶„ìœ„)
    avg_volume_20d  BIGINT,                            -- 20ì¼ í‰ê·  ê±°ë˜ëŸ‰
    avg_turnover_20d BIGINT,                           -- 20ì¼ í‰ê·  ê±°ë˜ëŒ€ê¸ˆ
    -- CAN SLIM ê¸°ë³¸ì  ì§€í‘œ
    eps_growth_qoq  DECIMAL(8,2),                      -- EPS ì„±ì¥ë¥  (ì „ë…„ ë™ê¸° ëŒ€ë¹„)
    revenue_growth  DECIMAL(8,2),                      -- ë§¤ì¶œ ì„±ì¥ë¥ 
    op_margin_trend VARCHAR(10),                       -- ì˜ì—…ì´ìµë¥  ì¶”ì„¸ (UP/DOWN/FLAT)
    inst_foreign_flow VARCHAR(10),                     -- ê¸°ê´€/ì™¸êµ­ì¸ ìˆ˜ê¸‰ (BUY/SELL/NEUTRAL)
    -- ë©”íƒ€
    trend_template_score INT DEFAULT 0,                -- Trend Template ì¶©ì¡± í•­ëª© ìˆ˜ (0~8)
    canslim_score   INT DEFAULT 0,                     -- CAN SLIM ì¶©ì¡± í•­ëª© ìˆ˜ (0~7)
    confidence_star INT DEFAULT 0 CHECK (confidence_star BETWEEN 0 AND 5), -- í™•ì‹ ë„ (ë³„ì )
    is_active       BOOLEAN DEFAULT TRUE,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.2 trades (ë§¤ë§¤ ë‚´ì—­)

```sql
CREATE TABLE trades (
    trade_id        SERIAL PRIMARY KEY,
    stock_code      VARCHAR(10) REFERENCES stocks(stock_code),
    trade_mode      VARCHAR(10) NOT NULL CHECK (trade_mode IN ('LIVE','PAPER')),
    -- ì£¼ë¬¸ ì •ë³´
    order_type      VARCHAR(10) NOT NULL,              -- BUY / SELL
    strategy_id     INT REFERENCES strategies(strategy_id),
    entry_price     DECIMAL(12,2),                     -- ì§„ì…ê°€
    exit_price      DECIMAL(12,2),                     -- ì²­ì‚°ê°€
    quantity        INT NOT NULL,                      -- ìˆ˜ëŸ‰
    amount          DECIMAL(15,2),                     -- íˆ¬ì… ê¸ˆì•¡
    -- ì†ìµ ì •ë³´
    pnl_amount      DECIMAL(15,2),                     -- ì†ìµ ê¸ˆì•¡
    pnl_percent     DECIMAL(8,4),                      -- ì†ìµë¥  (%)
    r_multiple      DECIMAL(8,4),                      -- Rë°°ìˆ˜ (Van Tharp)
    -- ë¦¬ìŠ¤í¬ ì •ë³´
    stop_loss_price DECIMAL(12,2),                     -- ì†ì ˆê°€
    risk_amount     DECIMAL(15,2),                     -- 1R ë¦¬ìŠ¤í¬ ê¸ˆì•¡
    position_pct    DECIMAL(5,2),                      -- ì´ ìë³¸ ëŒ€ë¹„ í¬ì§€ì…˜ ë¹„ì¤‘ (%)
    -- í”¼ë¼ë¯¸ë”© ì •ë³´
    pyramid_stage   INT DEFAULT 1,                     -- í”¼ë¼ë¯¸ë”© ë‹¨ê³„ (1ì°¨/2ì°¨/3ì°¨)
    parent_trade_id INT REFERENCES trades(trade_id),   -- ì› í¬ì§€ì…˜ trade_id
    -- ì‹¤í–‰ í’ˆì§ˆ
    slippage        DECIMAL(8,4),                      -- ìŠ¬ë¦¬í”¼ì§€ (%)
    fill_time_ms    INT,                               -- ì²´ê²° ì†Œìš” ì‹œê°„ (ms)
    -- ì‹œì¥ ì§€í‘œ ìŠ¤ëƒ…ìƒ· (ë§¤ë§¤ ë³µê¸°ìš©)
    snapshot_json   JSONB,                             -- ì§„ì… ì‹œì  ì°¨íŠ¸ ì§€í‘œ ìŠ¤ëƒ…ìƒ·
    -- íƒ€ì„ìŠ¤íƒ¬í”„
    entry_time      TIMESTAMP,
    exit_time       TIMESTAMP,
    holding_period  INTERVAL,                          -- ë³´ìœ  ê¸°ê°„
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.3 trade_journal (ë§¤ë§¤ ì¼ì§€ â€” Steenbarger ì…€í”„ ì½”ì¹­)

```sql
CREATE TABLE trade_journal (
    journal_id      SERIAL PRIMARY KEY,
    trade_id        INT UNIQUE REFERENCES trades(trade_id),
    -- ê±°ë˜ ê¸°ë¡
    stock_grade     CHAR(1),                           -- ì¢…ëª© ë“±ê¸‰ (A/B/C)
    entry_strategy  VARCHAR(50),                       -- ì§„ì… ì „ëµëª…
    checklist_score VARCHAR(20),                       -- ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶©ì¡±ë„ (ì˜ˆ: "12/13")
    -- ì‹¬ë¦¬ ê¸°ë¡ (Steenbarger)
    emotion_entry   VARCHAR(20),                       -- ì§„ì… ì‹œ ê°ì • (ì°¨ë¶„/ë¶ˆì•ˆ/í¥ë¶„/ë³µìˆ˜ì‹¬)
    emotion_during  TEXT,                              -- ë§¤ë§¤ ì¤‘ ê°ì • ë³€í™” ê¸°ë¡
    rule_compliance BOOLEAN DEFAULT TRUE,              -- ê·œì¹™ ì¤€ìˆ˜ ì—¬ë¶€
    rule_violation  TEXT,                              -- ìœ„ë°˜ ë‚´ìš© (ìˆì„ ê²½ìš°)
    lesson_learned  TEXT,                              -- ë°°ìš´ ì  (ê°•ì  ê°•í™”)
    improvement     TEXT,                              -- ê°œì„ í•  ì  (ì•½ì  ìˆ˜ì •)
    -- ìë™ ìƒì„± í•„ë“œ
    market_regime   VARCHAR(20),                       -- ë§¤ë§¤ ì‹œì  ì¥ì„¸ (ìƒìŠ¹/í•˜ë½/ë³´í•©)
    sector_flow     VARCHAR(20),                       -- ì„¹í„° ìˆ˜ê¸‰ ë°©í–¥
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.4 strategies (ì „ëµ ë§ˆìŠ¤í„°)

```sql
CREATE TABLE strategies (
    strategy_id     SERIAL PRIMARY KEY,
    strategy_code   VARCHAR(10) NOT NULL UNIQUE,       -- S1~S5, B1~B4, VB, GR, DS
    strategy_name   VARCHAR(100) NOT NULL,             -- ì „ëµëª…
    category        VARCHAR(20) NOT NULL,              -- BULL / BEAR / NEUTRAL
    description     TEXT,
    -- ì „ëµ íŒŒë¼ë¯¸í„° (JSON)
    default_params  JSONB,                             -- ê¸°ë³¸ ë§¤ê°œë³€ìˆ˜
    -- ì„±ê³¼ í†µê³„ (ìë™ ëˆ„ì )
    total_trades    INT DEFAULT 0,
    win_count       INT DEFAULT 0,
    loss_count      INT DEFAULT 0,
    avg_r_multiple  DECIMAL(8,4) DEFAULT 0,
    sqn_score       DECIMAL(8,4) DEFAULT 0,            -- System Quality Number
    is_active       BOOLEAN DEFAULT TRUE,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.5 daily_stats (ì¼ë³„ í†µê³„)

```sql
CREATE TABLE daily_stats (
    stat_date       DATE PRIMARY KEY,
    -- ë§¤ë§¤ í†µê³„
    total_trades    INT DEFAULT 0,                     -- ë‹¹ì¼ ë§¤ë§¤ íšŸìˆ˜
    buy_count       INT DEFAULT 0,
    sell_count      INT DEFAULT 0,
    win_count       INT DEFAULT 0,
    loss_count      INT DEFAULT 0,
    -- ê¸ˆì•¡ í†µê³„
    total_buy_amount  DECIMAL(15,2) DEFAULT 0,         -- ë§¤ìˆ˜ ì´ì•¡
    total_sell_amount DECIMAL(15,2) DEFAULT 0,         -- ë§¤ë„ ì´ì•¡
    daily_pnl       DECIMAL(15,2) DEFAULT 0,           -- ë‹¹ì¼ ì†ìµ
    daily_pnl_pct   DECIMAL(8,4) DEFAULT 0,            -- ë‹¹ì¼ ìˆ˜ìµë¥  (%)
    -- ëˆ„ì  í†µê³„
    cumulative_pnl  DECIMAL(15,2) DEFAULT 0,           -- ëˆ„ì  ì†ìµ
    total_capital   DECIMAL(15,2),                     -- ì´ ìë³¸
    cash_balance    DECIMAL(15,2),                     -- í˜„ê¸ˆ ì”ê³ 
    cash_ratio      DECIMAL(5,2),                      -- í˜„ê¸ˆ ë¹„ì¤‘ (%)
    -- Rë°°ìˆ˜ í†µê³„
    avg_r_multiple  DECIMAL(8,4),                      -- ë‹¹ì¼ í‰ê·  Rë°°ìˆ˜
    max_r_multiple  DECIMAL(8,4),                      -- ìµœëŒ€ Rë°°ìˆ˜
    min_r_multiple  DECIMAL(8,4),                      -- ìµœì†Œ Rë°°ìˆ˜
    -- ë¦¬ìŠ¤í¬ ì§€í‘œ
    drawdown_pct    DECIMAL(8,4),                      -- ë‹¹ì¼ ë“œë¡œìš°ë‹¤ìš´ (%)
    max_drawdown    DECIMAL(8,4),                      -- ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´ (%)
    -- ì¥ì„¸ ì •ë³´
    market_regime   VARCHAR(20),                       -- ì¥ì„¸ íŒë‹¨
    kospi_close     DECIMAL(10,2),                     -- ì½”ìŠ¤í”¼ ì¢…ê°€
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.6 monthly_stats (ì›”ë³„ í†µê³„)

```sql
CREATE TABLE monthly_stats (
    stat_month      VARCHAR(7) PRIMARY KEY,            -- YYYY-MM
    total_trades    INT DEFAULT 0,
    win_rate        DECIMAL(5,2),                      -- ìŠ¹ë¥  (%)
    monthly_pnl     DECIMAL(15,2),                     -- ì›”ê°„ ì†ìµ
    monthly_pnl_pct DECIMAL(8,4),                      -- ì›”ê°„ ìˆ˜ìµë¥  (%)
    avg_r_multiple  DECIMAL(8,4),
    sqn_score       DECIMAL(8,4),                      -- SQN ì ìˆ˜
    max_drawdown    DECIMAL(8,4),                      -- ì›”ê°„ ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´
    rule_compliance_rate DECIMAL(5,2),                 -- ê·œì¹™ ì¤€ìˆ˜ìœ¨ (%)
    -- ì „ëµë³„ ìˆ˜ìµ ê¸°ì—¬ë„
    strategy_pnl_json JSONB,                           -- {ì „ëµì½”ë“œ: ìˆ˜ìµê¸ˆ}
    -- ë“±ê¸‰ë³„ ìˆ˜ìµ ê¸°ì—¬ë„
    grade_pnl_json  JSONB,                             -- {A: ê¸ˆì•¡, B: ê¸ˆì•¡, C: ê¸ˆì•¡}
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.7 drawdown_log (ë“œë¡œìš°ë‹¤ìš´ ì´ë ¥)

```sql
CREATE TABLE drawdown_log (
    log_id          SERIAL PRIMARY KEY,
    level           VARCHAR(10) NOT NULL,              -- GREEN / YELLOW / ORANGE / RED / BLACK
    drawdown_pct    DECIMAL(8,4) NOT NULL,             -- ë“œë¡œìš°ë‹¤ìš´ ë¹„ìœ¨
    action_taken    TEXT,                               -- ì·¨í•œ ì¡°ì¹˜
    resumed_at      TIMESTAMP,                         -- ë§¤ë§¤ ì¬ê°œ ì‹œì 
    recovery_trades INT,                               -- ë³µê·€ê¹Œì§€ ë§¤ë§¤ íšŸìˆ˜
    triggered_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.8 system_config (ì‹œìŠ¤í…œ ì„¤ì •)

```sql
CREATE TABLE system_config (
    config_key      VARCHAR(100) PRIMARY KEY,
    config_value    TEXT NOT NULL,
    config_type     VARCHAR(20) DEFAULT 'STRING',      -- STRING / INT / FLOAT / JSON / BOOL
    description     TEXT,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì´ˆê¸° ì„¤ì •ê°’
INSERT INTO system_config VALUES
('trade_mode', 'PAPER', 'STRING', 'ë§¤ë§¤ ëª¨ë“œ: LIVE / PAPER'),
('total_capital', '100000000', 'INT', 'ì´ ìë³¸ê¸ˆ (ì›)'),
('risk_per_trade_pct', '2.0', 'FLOAT', 'ê±°ë˜ë‹¹ ë¦¬ìŠ¤í¬ ë¹„ìœ¨ (Elder 2% Rule)'),
('monthly_loss_limit_pct', '6.0', 'FLOAT', 'ì›”ê°„ ìµœëŒ€ ì†ì‹¤ í•œë„ (Elder 6% Rule)'),
('daily_loss_limit_pct', '3.0', 'FLOAT', 'ì¼ì¼ ìµœëŒ€ ì†ì‹¤ í•œë„ (Cameron)'),
('max_positions', '5', 'INT', 'ìµœëŒ€ ë™ì‹œ ë³´ìœ  ì¢…ëª© ìˆ˜'),
('grade_a_max_pct', '30', 'FLOAT', 'Aë“±ê¸‰ ë‹¨ì¼ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘'),
('grade_b_max_pct', '20', 'FLOAT', 'Bë“±ê¸‰ ë‹¨ì¼ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘'),
('grade_c_max_pct', '10', 'FLOAT', 'Cë“±ê¸‰ ë‹¨ì¼ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘'),
('sector_max_pct', '40', 'FLOAT', 'ë™ì¼ ì„¹í„° ìµœëŒ€ ë¹„ì¤‘'),
('trailing_stop_default_pct', '5.0', 'FLOAT', 'ê¸°ë³¸ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë¹„ìœ¨');
```

#### 3.2.9 event_calendar (íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ìº˜ë¦°ë”)

```sql
CREATE TABLE event_calendar (
    event_id        SERIAL PRIMARY KEY,
    event_date      DATE NOT NULL,
    event_type      VARCHAR(30) NOT NULL,              -- OPTION_EXPIRY / FOMC / EARNINGS / BOK / MSCI / SHORT_SELL
    event_name      VARCHAR(200),
    market_impact   TEXT,                               -- ì‹œì¥ ì˜í–¥ ì„¤ëª…
    trading_action  TEXT,                               -- ë‹¨íƒ€ ëŒ€ì‘ ì „ëµ
    cash_adjust_pct DECIMAL(5,2) DEFAULT 0,            -- í˜„ê¸ˆ ë¹„ì¤‘ ì¶”ê°€ í™•ë³´ (%)
    is_active       BOOLEAN DEFAULT TRUE
);
```

#### 3.2.10 paper_account (ê°€ìƒ ë§¤ë§¤ ê³„ì¢Œ)

```sql
CREATE TABLE paper_account (
    account_id      SERIAL PRIMARY KEY,
    stock_code      VARCHAR(10),
    quantity        INT DEFAULT 0,
    avg_price       DECIMAL(12,2),
    current_price   DECIMAL(12,2),
    unrealized_pnl  DECIMAL(15,2),
    total_cash      DECIMAL(15,2),
    total_equity    DECIMAL(15,2),
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 4. í•µì‹¬ ëª¨ë“ˆ ë° í´ë˜ìŠ¤ êµ¬ì¡°

### 4.1 ì¸ì¦ ê´€ë¦¬ (Auth Manager)

#### TokenManager í´ë˜ìŠ¤

```python
class TokenManager:
    """
    KIS API ì ‘ê·¼ í† í° ìë™ ë°œê¸‰/ê°±ì‹  ê´€ë¦¬
    - í† í° ìœ íš¨ê¸°ê°„: 24ì‹œê°„
    - ë§Œë£Œ 1ì‹œê°„ ì „ ìë™ ê°±ì‹ 
    - í† í° íŒŒì¼ ìºì‹±ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ì¬ë°œê¸‰ ë°©ì§€
    """
    
    def __init__(self, app_key: str, app_secret: str, base_url: str):
        self.app_key = app_key
        self.app_secret = app_secret
        self.base_url = base_url
        self.token: Optional[str] = None
        self.token_expired_at: Optional[datetime] = None
        self.token_file = "token_cache.json"
    
    async def get_token(self) -> str:
        """ìœ íš¨í•œ í† í° ë°˜í™˜. ë§Œë£Œ ì‹œ ìë™ ê°±ì‹ ."""
        if self._is_token_valid():
            return self.token
        
        # ìºì‹œ íŒŒì¼ì—ì„œ í† í° ë¡œë“œ ì‹œë„
        cached = self._load_cached_token()
        if cached and self._is_token_valid():
            return self.token
        
        # ì‹ ê·œ ë°œê¸‰
        return await self._issue_new_token()
    
    async def _issue_new_token(self) -> str:
        """POST /oauth2/tokenP â€” ì ‘ê·¼ í† í° ë°œê¸‰"""
        payload = {
            "grant_type": "client_credentials",
            "appkey": self.app_key,
            "appsecret": self.app_secret
        }
        response = await self._post("/oauth2/tokenP", payload)
        self.token = response["access_token"]
        self.token_expired_at = datetime.fromisoformat(
            response["access_token_token_expired"]
        )
        self._save_token_cache()
        logger.info(f"í† í° ë°œê¸‰ ì™„ë£Œ. ë§Œë£Œ: {self.token_expired_at}")
        return self.token
    
    def _is_token_valid(self) -> bool:
        """ë§Œë£Œ 1ì‹œê°„ ì „ê¹Œì§€ ìœ íš¨ë¡œ íŒë‹¨"""
        if not self.token or not self.token_expired_at:
            return False
        return datetime.now() < (self.token_expired_at - timedelta(hours=1))
    
    def schedule_refresh(self):
        """ë§Œë£Œ 1ì‹œê°„ ì „ ìë™ ê°±ì‹  ìŠ¤ì¼€ì¤„ë§"""
        if self.token_expired_at:
            refresh_time = self.token_expired_at - timedelta(hours=1)
            scheduler.add_job(self._issue_new_token, 'date', run_date=refresh_time)
```

#### HashkeyManager í´ë˜ìŠ¤

```python
class HashkeyManager:
    """
    ìš”ì²­ ë°ì´í„° ìœ„ë³€ì¡° ë°©ì§€ë¥¼ ìœ„í•œ í•´ì‹œí‚¤ ìƒì„±
    - POST ìš”ì²­ì˜ bodyë¥¼ í•´ì‹±í•˜ì—¬ tr_idë³„ í•´ì‹œí‚¤ ë°œê¸‰
    """
    
    async def get_hashkey(self, body: dict) -> str:
        """POST /uapi/hashkey â€” í•´ì‹œí‚¤ ë°œê¸‰"""
        response = await self.rest_client.post(
            "/uapi/hashkey",
            json=body,
            headers={"appkey": self.app_key, "appsecret": self.app_secret}
        )
        return response["HASH"]
```

### 4.2 API í†µì‹ ë¶€

#### KISRestClient í´ë˜ìŠ¤

```python
class KISRestClient:
    """
    KIS REST API í†µì‹  ë˜í¼
    - Throttling ë°©ì§€: ì´ˆë‹¹ ìµœëŒ€ 20íšŒ í˜¸ì¶œ ì œí•œ
    - ìë™ ì¬ì‹œë„: ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ Exponential Backoff
    - í•´ì‹œí‚¤ ìë™ ì ìš©
    """
    
    BASE_URL_LIVE = "https://openapi.koreainvestment.com:9443"
    BASE_URL_PAPER = "https://openapivts.koreainvestment.com:29443"
    
    def __init__(self, token_manager: TokenManager, 
                 hashkey_manager: HashkeyManager,
                 rate_limiter: RateLimiter,
                 mode: str = "PAPER"):
        self.token_manager = token_manager
        self.hashkey_manager = hashkey_manager
        self.rate_limiter = rate_limiter
        self.base_url = self.BASE_URL_LIVE if mode == "LIVE" else self.BASE_URL_PAPER
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def request(self, method: str, path: str, 
                      tr_id: str, body: dict = None,
                      params: dict = None) -> dict:
        """API ìš”ì²­ ì‹¤í–‰ (Throttling + ì¬ì‹œë„ í¬í•¨)"""
        
        # 1. Rate Limit ëŒ€ê¸°
        await self.rate_limiter.acquire()
        
        # 2. í—¤ë” êµ¬ì„±
        token = await self.token_manager.get_token()
        headers = {
            "authorization": f"Bearer {token}",
            "appkey": self.token_manager.app_key,
            "appsecret": self.token_manager.app_secret,
            "tr_id": tr_id,
            "content-type": "application/json; charset=utf-8",
            "custtype": "P"  # ê°œì¸
        }
        
        # 3. POST ìš”ì²­ ì‹œ í•´ì‹œí‚¤ ì¶”ê°€
        if method == "POST" and body:
            headers["hashkey"] = await self.hashkey_manager.get_hashkey(body)
        
        # 4. ì¬ì‹œë„ ë¡œì§ (Exponential Backoff)
        for attempt in range(3):
            try:
                async with self.session.request(
                    method, f"{self.base_url}{path}",
                    headers=headers, json=body, params=params
                ) as resp:
                    data = await resp.json()
                    
                    if data.get("rt_cd") != "0":
                        raise KISAPIError(data.get("msg_cd"), data.get("msg1"))
                    
                    return data
                    
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                if attempt == 2:
                    raise
                wait = 2 ** attempt
                logger.warning(f"API ìš”ì²­ ì‹¤íŒ¨ ({attempt+1}/3), {wait}ì´ˆ í›„ ì¬ì‹œë„: {e}")
                await asyncio.sleep(wait)
    
    # === ì£¼ìš” API ë©”ì„œë“œ ===
    
    async def get_current_price(self, stock_code: str) -> dict:
        """ì£¼ì‹ í˜„ì¬ê°€ ì¡°íšŒ [v1/trading/inquire-price]"""
        return await self.request("GET", 
            "/uapi/domestic-stock/v1/quotations/inquire-price",
            tr_id="FHKST01010100",
            params={"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": stock_code})
    
    async def get_asking_price(self, stock_code: str) -> dict:
        """ì£¼ì‹ í˜¸ê°€ ì¡°íšŒ"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/quotations/inquire-asking-price-exp-ccn",
            tr_id="FHKST01010200",
            params={"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": stock_code})
    
    async def get_daily_price(self, stock_code: str, 
                               period: str = "D", count: int = 100) -> dict:
        """ì£¼ì‹ ê¸°ê°„ë³„ ì‹œì„¸ (ì¼/ì£¼/ì›”ë´‰)"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/quotations/inquire-daily-price",
            tr_id="FHKST01010400",
            params={
                "FID_COND_MRKT_DIV_CODE": "J",
                "FID_INPUT_ISCD": stock_code,
                "FID_PERIOD_DIV_CODE": period,
                "FID_ORG_ADJ_PRC": "0"
            })
    
    async def place_order(self, stock_code: str, order_type: str,
                           quantity: int, price: int = 0) -> dict:
        """ì£¼ì‹ ë§¤ìˆ˜/ë§¤ë„ ì£¼ë¬¸"""
        tr_id = "TTTC0802U" if order_type == "BUY" else "TTTC0801U"
        # ê°€ìƒ ë§¤ë§¤ ëª¨ë“œ: VTTC0802U / VTTC0801U
        if self.base_url == self.BASE_URL_PAPER:
            tr_id = "VTTC0802U" if order_type == "BUY" else "VTTC0801U"
        
        body = {
            "CANO": self.account_no,
            "ACNT_PRDT_CD": self.account_product_code,
            "PDNO": stock_code,
            "ORD_DVSN": "00" if price > 0 else "01",  # 00: ì§€ì •ê°€, 01: ì‹œì¥ê°€
            "ORD_QTY": str(quantity),
            "ORD_UNPR": str(price)
        }
        return await self.request("POST",
            "/uapi/domestic-stock/v1/trading/order-cash",
            tr_id=tr_id, body=body)
    
    async def get_balance(self) -> dict:
        """ì£¼ì‹ ì”ê³  ì¡°íšŒ"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/trading/inquire-balance",
            tr_id="TTTC8434R",
            params={
                "CANO": self.account_no,
                "ACNT_PRDT_CD": self.account_product_code,
                "AFHR_FLPR_YN": "N",
                "OFL_YN": "",
                "INQR_DVSN": "02",
                "UNPR_DVSN": "01",
                "FUND_STTL_ICLD_YN": "N",
                "FNCG_AMT_AUTO_RDPT_YN": "N",
                "PRCS_DVSN": "01",
                "CTX_AREA_FK100": "",
                "CTX_AREA_NK100": ""
            })
    
    async def get_volume_rank(self) -> dict:
        """ê±°ë˜ëŸ‰ ìˆœìœ„ ì¡°íšŒ"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/quotations/volume-rank",
            tr_id="FHPST01710000",
            params={
                "FID_COND_MRKT_DIV_CODE": "J",
                "FID_COND_SCR_DIV_CODE": "20171",
                "FID_INPUT_ISCD": "0000",
                "FID_DIV_CLS_CODE": "0",
                "FID_BLNG_CLS_CODE": "0",
                "FID_TRGT_CLS_CODE": "111111111",
                "FID_TRGT_EXLS_CLS_CODE": "000000",
                "FID_INPUT_PRICE_1": "",
                "FID_INPUT_PRICE_2": "",
                "FID_VOL_CNT": "",
                "FID_INPUT_DATE_1": ""
            })
```

#### KISWebSocketClient í´ë˜ìŠ¤

```python
class KISWebSocketClient:
    """
    KIS WebSocket ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹ 
    - ì²´ê²° í†µë³´, í˜¸ê°€ ë³€í™” ì‹¤ì‹œê°„ ìˆ˜ì‹ 
    - ìë™ ì¬ì—°ê²° (Exponential Backoff + ìµœëŒ€ 30íšŒ)
    - Heartbeat ê¸°ë°˜ ì—°ê²° ìƒíƒœ ê°ì‹œ
    """
    
    WS_URL = "ws://ops.koreainvestment.com:21000"
    WS_URL_LIVE = "ws://ops.koreainvestment.com:21000"
    
    def __init__(self, approval_key: str):
        self.approval_key = approval_key
        self.ws: Optional[websockets.WebSocketClientProtocol] = None
        self.subscriptions: Dict[str, Set[str]] = {}  # {tr_id: {stock_codes}}
        self.reconnect_count = 0
        self.max_reconnects = 30
        self.callbacks: Dict[str, Callable] = {}
        self._running = False
    
    async def connect(self):
        """WebSocket ì—°ê²° ìˆ˜ë¦½"""
        self._running = True
        while self._running and self.reconnect_count < self.max_reconnects:
            try:
                async with websockets.connect(
                    self.WS_URL,
                    ping_interval=30,
                    ping_timeout=10,
                    close_timeout=5
                ) as ws:
                    self.ws = ws
                    self.reconnect_count = 0
                    logger.info("WebSocket ì—°ê²° ì„±ê³µ")
                    
                    # ê¸°ì¡´ êµ¬ë… ë³µì›
                    await self._restore_subscriptions()
                    
                    # ë©”ì‹œì§€ ìˆ˜ì‹  ë£¨í”„
                    async for message in ws:
                        await self._handle_message(message)
                        
            except (websockets.ConnectionClosed, ConnectionError) as e:
                self.reconnect_count += 1
                wait = min(2 ** self.reconnect_count, 60)  # ìµœëŒ€ 60ì´ˆ
                logger.warning(
                    f"WebSocket ì—°ê²° ëŠê¹€ ({self.reconnect_count}/{self.max_reconnects}), "
                    f"{wait}ì´ˆ í›„ ì¬ì—°ê²°: {e}"
                )
                await asyncio.sleep(wait)
        
        if self.reconnect_count >= self.max_reconnects:
            logger.critical("WebSocket ìµœëŒ€ ì¬ì—°ê²° íšŸìˆ˜ ì´ˆê³¼. ì‹œìŠ¤í…œ ì ê²€ í•„ìš”.")
            await self._notify_critical_error("WebSocket ì—°ê²° ë¶ˆê°€")
    
    async def subscribe_execution(self, stock_code: str):
        """ì²´ê²° í†µë³´ êµ¬ë… (tr_id: H0STCNT0)"""
        await self._subscribe("H0STCNT0", stock_code)
    
    async def subscribe_orderbook(self, stock_code: str):
        """í˜¸ê°€ ë³€í™” êµ¬ë… (tr_id: H0STASP0)"""
        await self._subscribe("H0STASP0", stock_code)
    
    async def _subscribe(self, tr_id: str, stock_code: str):
        """êµ¬ë… ë©”ì‹œì§€ ì „ì†¡"""
        msg = {
            "header": {
                "approval_key": self.approval_key,
                "custtype": "P",
                "tr_type": "1",  # 1: ë“±ë¡
                "content-type": "utf-8"
            },
            "body": {
                "input": {
                    "tr_id": tr_id,
                    "tr_key": stock_code
                }
            }
        }
        await self.ws.send(json.dumps(msg))
        self.subscriptions.setdefault(tr_id, set()).add(stock_code)
    
    async def _handle_message(self, raw: str):
        """ìˆ˜ì‹  ë©”ì‹œì§€ íŒŒì‹± ë° ì½œë°± ì‹¤í–‰"""
        if raw[0] in ('0', '1'):  # ì‹¤ì‹œê°„ ë°ì´í„°
            parts = raw.split('|')
            tr_id = parts[1]
            data = parts[3]
            
            if tr_id in self.callbacks:
                parsed = self._parse_realtime_data(tr_id, data)
                await self.callbacks[tr_id](parsed)
        else:
            # JSON ì‘ë‹µ (êµ¬ë… ê²°ê³¼ ë“±)
            data = json.loads(raw)
            if data.get("header", {}).get("tr_id") == "PINGPONG":
                await self.ws.send(raw)  # Heartbeat ì‘ë‹µ
    
    async def _restore_subscriptions(self):
        """ì¬ì—°ê²° í›„ ê¸°ì¡´ êµ¬ë… ë³µì›"""
        for tr_id, codes in self.subscriptions.items():
            for code in codes:
                await self._subscribe(tr_id, code)
        logger.info(f"êµ¬ë… ë³µì› ì™„ë£Œ: {sum(len(v) for v in self.subscriptions.values())}ê±´")
```

#### RateLimiter í´ë˜ìŠ¤

```python
class RateLimiter:
    """
    KIS API í˜¸ì¶œ ì œí•œ ê´€ë¦¬
    - REST API: ì´ˆë‹¹ 20íšŒ ì œí•œ
    - í˜¸ì¶œ ê°„ê²© ìë™ ì¡°ì ˆ
    - ë²„ìŠ¤íŠ¸ ë°©ì§€ë¥¼ ìœ„í•œ Token Bucket ì•Œê³ ë¦¬ì¦˜
    """
    
    def __init__(self, calls_per_second: int = 20):
        self.calls_per_second = calls_per_second
        self.min_interval = 1.0 / calls_per_second
        self.semaphore = asyncio.Semaphore(calls_per_second)
        self.last_call_time = 0.0
        self._lock = asyncio.Lock()
    
    async def acquire(self):
        """í˜¸ì¶œ ê¶Œí•œ íšë“ (í•„ìš” ì‹œ ëŒ€ê¸°)"""
        async with self._lock:
            now = time.monotonic()
            elapsed = now - self.last_call_time
            if elapsed < self.min_interval:
                await asyncio.sleep(self.min_interval - elapsed)
            self.last_call_time = time.monotonic()
```

### 4.3 ì‹œì¥ ë°ì´í„°ë¶€ (Market Data Hub)

#### StockScreener í´ë˜ìŠ¤

```python
class StockScreener:
    """
    ì¢…ëª© ìŠ¤ìºë‹ ì—”ì§„ â€” Minervini Trend Template + CAN SLIM í†µí•©
    
    í•„ìˆ˜ ìê²© ì¡°ê±´:
    - ì‹œê°€ì´ì•¡ 5,000ì–µì› ì´ìƒ
    - ì¼í‰ê·  ê±°ë˜ëŒ€ê¸ˆ 100ì–µì› ì´ìƒ (20ì¼)
    - ì¼í‰ê·  ê±°ë˜ëŸ‰ 100ë§Œì£¼ ì´ìƒ (ë˜ëŠ” íšŒì „ìœ¨ 0.5%+)
    - í˜¸ê°€ ìŠ¤í”„ë ˆë“œ 0.3% ì´ë‚´
    - ìƒì¥ 6ê°œì›” ì´ìƒ
    - ê´€ë¦¬ì¢…ëª©/íˆ¬ìê²½ê³  í•´ë‹¹ ì—†ìŒ
    
    ë“±ê¸‰ ë¶„ë¥˜:
    - Aë“±ê¸‰: ì‹œê°€ì´ì•¡ ìƒìœ„ 30ìœ„ (ì´ˆëŒ€í˜• ìš°ëŸ‰ì£¼)
    - Bë“±ê¸‰: ì‹œê°€ì´ì•¡ 30~100ìœ„ (ëª¨ë©˜í…€ ì¤‘í˜•ì£¼)
    - Cë“±ê¸‰: ì‹œê°€ì´ì•¡ 100~200ìœ„ (í…Œë§ˆ ì†Œí˜•ì£¼)
    - Dë“±ê¸‰: ë§¤ë§¤ ê¸ˆì§€
    """
    
    # Minervini Trend Template 8ê°€ì§€ ê¸°ìˆ ì  ì¡°ê±´
    TREND_TEMPLATE_CHECKS = [
        ("í˜„ì¬ê°€ > 50ì¼ì„ ", lambda s: s.price > s.ma_50),
        ("í˜„ì¬ê°€ > 150ì¼ì„ ", lambda s: s.price > s.ma_150),
        ("í˜„ì¬ê°€ > 200ì¼ì„ ", lambda s: s.price > s.ma_200),
        ("50ì¼ì„  > 150ì¼ì„  > 200ì¼ì„ ", lambda s: s.ma_50 > s.ma_150 > s.ma_200),
        ("200ì¼ì„  ìƒìŠ¹ ì¤‘ (1ê°œì›”)", lambda s: s.ma_200_slope > 0),
        ("í˜„ì¬ê°€ >= 52ì£¼ì €ì  +30%", lambda s: s.price >= s.week52_low * 1.3),
        ("í˜„ì¬ê°€ <= 52ì£¼ê³ ì  -25%", lambda s: s.price >= s.week52_high * 0.75),
        ("RS ì½”ìŠ¤í”¼ ëŒ€ë¹„ ìƒìœ„ 30%", lambda s: s.rs_rank >= 70),
    ]
    
    async def scan_daily(self) -> List[StockCandidate]:
        """ë‹¹ì¼ ë§¤ë§¤ í›„ë³´ ìŠ¤ìºë‹ (08:30~09:00 ì‹¤í–‰)"""
        # 1ë‹¨ê³„: ì „ì¼ ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ 50ì¢…ëª© ì¶”ì¶œ
        volume_rank = await self.rest_client.get_volume_rank()
        candidates = self._filter_top_50(volume_rank)
        
        # 2ë‹¨ê³„: ê¸°ë³¸ ìê²© ì¡°ê±´ í•„í„°ë§
        candidates = [c for c in candidates if self._check_basic_qualification(c)]
        
        # 3ë‹¨ê³„: Trend Template 8í•­ëª© ì²´í¬
        for c in candidates:
            c.trend_score = sum(1 for _, check in self.TREND_TEMPLATE_CHECKS if check(c))
        candidates = [c for c in candidates if c.trend_score >= 5]
        
        # 4ë‹¨ê³„: CAN SLIM ê¸°ë³¸ì  ì¡°ê±´ í™•ì¸
        for c in candidates:
            c.canslim_score = self._check_canslim(c)
        
        # 5ë‹¨ê³„: ë“±ê¸‰ ë¶„ë¥˜ ë° í™•ì‹ ë„ ì‚°ì •
        for c in candidates:
            c.grade = self._classify_grade(c)
            c.confidence = self._calculate_confidence(c)
        
        # 6ë‹¨ê³„: ìµœì¢… í›„ë³´ 3~5ì¢…ëª© ë°˜í™˜
        return sorted(candidates, key=lambda x: x.confidence, reverse=True)[:5]
    
    def _calculate_confidence(self, stock: StockCandidate) -> int:
        """
        í™•ì‹ ë„ ì ìˆ˜ ì‚°ì • (Minervini ë°©ì‹)
        â­â­â­â­â­: ê¸°ìˆ  8ì¡°ê±´ + ê¸°ë³¸ 5ì¡°ê±´ + VCP + ê¸°ê´€ì™¸êµ­ì¸ ë™ì‹œ ìˆœë§¤ìˆ˜
        â­â­â­â­: ê¸°ìˆ  6+ + ê¸°ë³¸ 3+ + ìˆ˜ê¸‰ ì–‘í˜¸
        â­â­â­: ê¸°ìˆ  5+ + ê¸°ë³¸ 2+ + ìˆ˜ê¸‰ ì¤‘ë¦½
        â­â­ ì´í•˜: ë§¤ë§¤ ê¸ˆì§€
        """
        if stock.trend_score >= 8 and stock.canslim_score >= 5 and stock.inst_foreign_flow == "BUY":
            return 5
        elif stock.trend_score >= 6 and stock.canslim_score >= 3:
            return 4
        elif stock.trend_score >= 5 and stock.canslim_score >= 2:
            return 3
        else:
            return 2  # ë§¤ë§¤ ê¸ˆì§€
```

#### IndicatorCalculator í´ë˜ìŠ¤

```python
class IndicatorCalculator:
    """
    ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° ì—”ì§„
    - ì´ë™í‰ê· ì„  (SMA, EMA): 5, 10, 20, 50, 150, 200ì¼
    - RSI (14ì¼)
    - VWAP (ë‹¹ì¼)
    - ë³¼ë¦°ì € ë°´ë“œ (20ì¼, 2Ïƒ)
    - MACD (12, 26, 9)
    - ATR (14ì¼)
    - ê±°ë˜ëŸ‰ ì´ë™í‰ê· 
    """
    
    @staticmethod
    def sma(prices: List[float], period: int) -> float:
        return sum(prices[-period:]) / period
    
    @staticmethod
    def ema(prices: List[float], period: int) -> float:
        multiplier = 2 / (period + 1)
        ema = prices[0]
        for price in prices[1:]:
            ema = (price - ema) * multiplier + ema
        return ema
    
    @staticmethod
    def rsi(prices: List[float], period: int = 14) -> float:
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        gains = [d if d > 0 else 0 for d in deltas[-period:]]
        losses = [-d if d < 0 else 0 for d in deltas[-period:]]
        avg_gain = sum(gains) / period
        avg_loss = sum(losses) / period
        if avg_loss == 0:
            return 100
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))
    
    @staticmethod
    def vwap(prices: List[float], volumes: List[int], highs: List[float], lows: List[float]) -> float:
        typical_prices = [(h + l + c) / 3 for h, l, c in zip(highs, lows, prices)]
        cumul_tp_vol = sum(tp * v for tp, v in zip(typical_prices, volumes))
        cumul_vol = sum(volumes)
        return cumul_tp_vol / cumul_vol if cumul_vol > 0 else 0
    
    @staticmethod
    def bollinger_bands(prices: List[float], period: int = 20, num_std: float = 2.0):
        sma = sum(prices[-period:]) / period
        std = (sum((p - sma) ** 2 for p in prices[-period:]) / period) ** 0.5
        return {
            "upper": sma + num_std * std,
            "middle": sma,
            "lower": sma - num_std * std
        }
    
    @staticmethod
    def atr(highs: List[float], lows: List[float], closes: List[float], period: int = 14) -> float:
        true_ranges = []
        for i in range(1, len(highs)):
            tr = max(highs[i] - lows[i], 
                     abs(highs[i] - closes[i-1]), 
                     abs(lows[i] - closes[i-1]))
            true_ranges.append(tr)
        return sum(true_ranges[-period:]) / period
    
    @staticmethod
    def macd(prices: List[float], fast=12, slow=26, signal=9):
        ema_fast = IndicatorCalculator.ema(prices, fast)
        ema_slow = IndicatorCalculator.ema(prices, slow)
        macd_line = ema_fast - ema_slow
        return {"macd": macd_line, "signal": None, "histogram": None}
```

---

## 5. KIS API íŠ¹í™” ì„¤ê³„

### 5.1 API í˜¸ì¶œ ì œí•œ(Throttling) ë°©ì§€ ë¡œì§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  API í˜¸ì¶œ   â”‚â”€â”€â”€â”€â–¶â”‚ Rate Limiter â”‚â”€â”€â”€â”€â–¶â”‚  KIS Server  â”‚
â”‚  ìš”ì²­ í    â”‚     â”‚ (Token       â”‚     â”‚              â”‚
â”‚             â”‚     â”‚  Bucket)     â”‚     â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                    â”‚ ì´ˆë‹¹ 20íšŒ â”‚
                    â”‚ ì œí•œ ê´€ë¦¬ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| ì œí•œ í•­ëª© | KIS ê¸°ì¤€ | ì‹œìŠ¤í…œ ì„¤ì • | ë°©ì§€ ì „ëµ |
|----------|---------|-----------|----------|
| REST API ì´ˆë‹¹ í˜¸ì¶œ | 20íšŒ/ì´ˆ | 18íšŒ/ì´ˆ (ì—¬ìœ ë¶„ í™•ë³´) | Token Bucket ì•Œê³ ë¦¬ì¦˜ |
| WebSocket êµ¬ë… ì¢…ëª© | 40ì¢…ëª©/ì—°ê²° | 35ì¢…ëª© (ì—¬ìœ ë¶„) | ë‹¤ì¤‘ ì—°ê²° í’€ ê´€ë¦¬ |
| í† í° ë°œê¸‰ | ë¶„ë‹¹ 1íšŒ | ë§Œë£Œ 1ì‹œê°„ ì „ 1íšŒ | ìºì‹œ íŒŒì¼ í™œìš© |

### 5.2 WebSocket ì¬ì—°ê²° ì „ëµ

```python
RECONNECT_STRATEGY = {
    "max_retries": 30,
    "initial_delay": 1,        # ì´ˆê¸° ëŒ€ê¸° (ì´ˆ)
    "max_delay": 60,           # ìµœëŒ€ ëŒ€ê¸° (ì´ˆ)
    "backoff_factor": 2,       # Exponential Backoff ë°°ìˆ˜
    "jitter": True,            # ëœë¤ ì§€í„° ì¶”ê°€ (Thundering Herd ë°©ì§€)
    "subscription_restore": True,  # ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë… ìë™ ë³µì›
    "heartbeat_interval": 30,  # Ping ê°„ê²© (ì´ˆ)
    "heartbeat_timeout": 10,   # Pong ëŒ€ê¸° (ì´ˆ)
}
```

### 5.3 REST + WebSocket ë³‘í–‰ ì„¤ê³„

| ë°ì´í„° ìœ í˜• | í†µì‹  ë°©ì‹ | API | ì£¼ê¸° |
|-----------|----------|-----|------|
| í˜„ì¬ê°€ ì¡°íšŒ | REST | FHKST01010100 | ìš”ì²­ ì‹œ |
| í˜¸ê°€ ì¡°íšŒ | REST | FHKST01010200 | ìš”ì²­ ì‹œ |
| ì¼ë´‰/ë¶„ë´‰ ë°ì´í„° | REST | FHKST01010400 | ìŠ¤ì¼€ì¤„ (1ë¶„/5ë¶„) |
| ì‹¤ì‹œê°„ ì²´ê²°ê°€ | **WebSocket** | H0STCNT0 | ì‹¤ì‹œê°„ (Push) |
| ì‹¤ì‹œê°„ í˜¸ê°€ ë³€ë™ | **WebSocket** | H0STASP0 | ì‹¤ì‹œê°„ (Push) |
| ì£¼ë¬¸ ì²´ê²° í†µë³´ | **WebSocket** | H0STCNC0 | ì‹¤ì‹œê°„ (Push) |
| ì£¼ë¬¸ ì‹¤í–‰ | REST | TTTC0802U/0801U | ìš”ì²­ ì‹œ |
| ì”ê³  ì¡°íšŒ | REST | TTTC8434R | ìš”ì²­ ì‹œ |
| ê±°ë˜ëŸ‰ ìˆœìœ„ | REST | FHPST01710000 | ìŠ¤ì¼€ì¤„ (10ë¶„) |

---

## 6. ì „ëµ ì—”ì§„ ìƒì„¸ ì„¤ê³„

### 6.1 ì „ëµ ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤

```python
from abc import ABC, abstractmethod
from enum import Enum
from dataclasses import dataclass

class MarketRegime(Enum):
    STRONG_BULL = "ê°•í•œ ìƒìŠ¹ì¥"
    BULL = "ì¼ë°˜ ìƒìŠ¹ì¥"
    SIDEWAYS = "ë³´í•©/íš¡ë³´ì¥"
    BEAR = "ì•½ì„¸ì¥"
    STRONG_BEAR = "ê°•í•œ í•˜ë½ì¥"

class StrategyCategory(Enum):
    BULL = "ìƒìŠ¹ì¥"       # S1~S5
    BEAR = "í•˜ë½ì¥"       # B1~B4
    NEUTRAL = "ì¤‘ë¦½"      # ê·¸ë¦¬ë“œ, ë°°ë‹¹ì£¼

@dataclass
class TradeSignal:
    stock_code: str
    action: str              # BUY / SELL
    strategy_code: str       # S1, S2, ..., B1, B2, ...
    entry_price: float
    stop_loss: float
    target_prices: List[float]  # [1ì°¨ ìµì ˆ, 2ì°¨ ìµì ˆ, 3ì°¨ ìµì ˆ]
    position_pct: float      # í¬ì§€ì…˜ ë¹„ì¤‘ (%)
    confidence: int          # í™•ì‹ ë„ (1~5)
    reason: str              # ì§„ì… ê·¼ê±° ì„¤ëª…
    indicators_snapshot: dict # ì§„ì… ì‹œì  ì§€í‘œ ìŠ¤ëƒ…ìƒ·

class BaseStrategy(ABC):
    """ëª¨ë“  ì „ëµì˜ ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤"""
    
    def __init__(self, strategy_code: str, category: StrategyCategory):
        self.strategy_code = strategy_code
        self.category = category
        self.is_active = True
    
    @abstractmethod
    async def scan(self, candidates: List[StockCandidate]) -> List[StockCandidate]:
        """ì „ëµ ì¡°ê±´ì— ë§ëŠ” ì¢…ëª© í•„í„°ë§"""
        pass
    
    @abstractmethod
    async def generate_signal(self, stock: StockCandidate, 
                               market_data: MarketData) -> Optional[TradeSignal]:
        """ë§¤ë§¤ ì‹ í˜¸ ìƒì„±"""
        pass
    
    @abstractmethod
    def get_exit_rules(self) -> dict:
        """ì²­ì‚° ê·œì¹™ ë°˜í™˜ (ì†ì ˆ/ìµì ˆ/íŠ¸ë ˆì¼ë§)"""
        pass
    
    def is_applicable(self, regime: MarketRegime) -> bool:
        """í˜„ì¬ ì¥ì„¸ì—ì„œ ì ìš© ê°€ëŠ¥ ì—¬ë¶€"""
        if self.category == StrategyCategory.BULL:
            return regime in (MarketRegime.STRONG_BULL, MarketRegime.BULL)
        elif self.category == StrategyCategory.BEAR:
            return regime in (MarketRegime.BEAR, MarketRegime.STRONG_BEAR)
        return True  # NEUTRALì€ í•­ìƒ ì ìš©
```

### 6.2 ìƒìŠ¹ì¥ ì „ëµ êµ¬í˜„

#### S1. SEPA ëª¨ë©˜í…€ ëŒíŒŒ (Minervini)

```python
class SEPAMomentumStrategy(BaseStrategy):
    """
    Mark Minervini SEPA ëª¨ë©˜í…€ ëŒíŒŒ ì „ëµ
    - VCP(Volatility Contraction Pattern) íŒ¨í„´ í˜•ì„± í™•ì¸
    - í”¼ë²— í¬ì¸íŠ¸ ëŒíŒŒ ì‹œ ì§„ì…
    - EPS +20%, ë§¤ì¶œ +15% ì´ìƒ í™•ì¸ í•„ìˆ˜
    - ì½”ìŠ¤í”¼ ì ìš©: Bë“±ê¸‰ ì¤‘ì‹¬, íˆ¬ì… ë¹„ì¤‘ 15~20%
    """
    
    def __init__(self):
        super().__init__("S1", StrategyCategory.BULL)
        self.params = {
            "vcp_contractions": 3,       # VCP ìˆ˜ì¶• íšŸìˆ˜
            "volume_breakout_ratio": 1.5, # ëŒíŒŒ ì‹œ ê±°ë˜ëŸ‰ ë°°ìˆ˜
            "eps_min_growth": 20,         # ìµœì†Œ EPS ì„±ì¥ë¥  (%)
            "revenue_min_growth": 15,     # ìµœì†Œ ë§¤ì¶œ ì„±ì¥ë¥  (%)
            "stop_loss_pct": 7,           # ì†ì ˆ (í”¼ë²— í•˜ë‹¨ %)
            "target_1_pct": 10,           # 1ì°¨ ìµì ˆ (%)
            "target_2_pct": 20,           # 2ì°¨ ìµì ˆ (%)
            "grade_target": ["B"],        # ëŒ€ìƒ ë“±ê¸‰
            "position_pct": 17.5,         # ê¸°ë³¸ í¬ì§€ì…˜ ë¹„ì¤‘ (%)
        }
    
    async def generate_signal(self, stock, market_data) -> Optional[TradeSignal]:
        indicators = market_data.indicators
        
        # 1. VCP íŒ¨í„´ í™•ì¸ (ë³€ë™í­ ìˆ˜ì¶• 3íšŒ ì´ìƒ)
        if not self._detect_vcp(market_data.daily_prices):
            return None
        
        # 2. í”¼ë²— í¬ì¸íŠ¸ ëŒíŒŒ í™•ì¸
        pivot = self._calculate_pivot(market_data.daily_prices)
        if market_data.current_price < pivot:
            return None
        
        # 3. ëŒíŒŒ ì‹œ ê±°ë˜ëŸ‰ í™•ì¸ (í‰ì†Œ 1.5ë°° ì´ìƒ)
        if market_data.current_volume < stock.avg_volume_20d * self.params["volume_breakout_ratio"]:
            return None
        
        # 4. ê¸°ë³¸ì  ì¡°ê±´ í™•ì¸
        if stock.eps_growth_qoq < self.params["eps_min_growth"]:
            return None
        if stock.revenue_growth < self.params["revenue_min_growth"]:
            return None
        
        stop_loss = pivot * (1 - self.params["stop_loss_pct"] / 100)
        
        return TradeSignal(
            stock_code=stock.stock_code,
            action="BUY",
            strategy_code="S1",
            entry_price=market_data.current_price,
            stop_loss=stop_loss,
            target_prices=[
                market_data.current_price * 1.10,  # +10%
                market_data.current_price * 1.20,  # +20%
                0  # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘
            ],
            position_pct=self._adjust_position(stock.confidence, stock.grade),
            confidence=stock.confidence,
            reason=f"SEPA ëª¨ë©˜í…€ ëŒíŒŒ: VCP íŒ¨í„´ ì™„ì„±, í”¼ë²— {pivot:,.0f}ì› ëŒíŒŒ, "
                   f"ê±°ë˜ëŸ‰ {market_data.current_volume/stock.avg_volume_20d:.1f}ë°°",
            indicators_snapshot=self._capture_snapshot(indicators)
        )
```

#### S5. VWAP ë°”ìš´ìŠ¤ (Carter/Aziz)

```python
class VWAPBounceStrategy(BaseStrategy):
    """
    VWAP ë°”ìš´ìŠ¤ + ëª¨ë©˜í…€ ë§¤ë§¤ (Carter/Aziz)
    - VWAP ìœ„ì—ì„œ ì›€ì§ì´ëŠ” ê°•í•œ ì¢…ëª©ì´ VWAP ë¶€ê·¼ ëˆŒë¦¼ ì‹œ ë§¤ìˆ˜
    - ê¸°ê´€ ë§¤ìˆ˜ì„¸ì˜ VWAP ì§€ì§€ í™•ì¸ì´ í•µì‹¬
    - ì½”ìŠ¤í”¼ ì ìš©: Aë“±ê¸‰ ëŒ€í˜•ì£¼ ì¤‘ì‹¬, íˆ¬ì… ë¹„ì¤‘ 20~30%
    """
    
    def __init__(self):
        super().__init__("S5", StrategyCategory.BULL)
        self.params = {
            "vwap_proximity_pct": 0.5,   # VWAP ëŒ€ë¹„ í—ˆìš© ê±°ë¦¬ (%)
            "bounce_candles": 2,          # ë°˜ë“± í™•ì¸ ìº”ë“¤ ìˆ˜
            "stop_loss_rule": "VWAP_BREAK", # VWAP ì´íƒˆ ì‹œ ì¦‰ì‹œ ì²­ì‚°
            "grade_target": ["A"],
            "position_pct": 25,
        }
    
    async def generate_signal(self, stock, market_data) -> Optional[TradeSignal]:
        vwap = market_data.indicators["vwap"]
        price = market_data.current_price
        
        # 1. í˜„ì¬ê°€ê°€ VWAP ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
        if price < vwap:
            return None
        
        # 2. VWAP ê·¼ì²˜ ëˆŒë¦¼ëª© í™•ì¸ (VWAP ëŒ€ë¹„ 0.5% ì´ë‚´)
        distance = (price - vwap) / vwap * 100
        if distance > self.params["vwap_proximity_pct"]:
            return None
        
        # 3. ë°˜ë“± ìº”ë“¤ 2ê°œ í™•ì¸
        if not self._confirm_bounce(market_data.minute_candles, vwap):
            return None
        
        return TradeSignal(
            stock_code=stock.stock_code,
            action="BUY",
            strategy_code="S5",
            entry_price=price,
            stop_loss=vwap * 0.995,  # VWAP ì‚´ì§ ì•„ë˜
            target_prices=[price * 1.05, price * 1.10, 0],
            position_pct=self._adjust_position(stock.confidence, stock.grade),
            confidence=stock.confidence,
            reason=f"VWAP ë°”ìš´ìŠ¤: VWAP {vwap:,.0f}ì› ì§€ì§€ í™•ì¸, "
                   f"ê±°ë¦¬ {distance:.2f}%, ë°˜ë“± ìº”ë“¤ í™•ì¸",
            indicators_snapshot=self._capture_snapshot(market_data.indicators)
        )
```

### 6.3 í•˜ë½ì¥ ì „ëµ êµ¬í˜„

#### B1. ë°ë“œìº£ ë°”ìš´ìŠ¤ (Staley/Turner)

```python
class DeadCatBounceStrategy(BaseStrategy):
    """
    ë°ë“œìº£ ë°”ìš´ìŠ¤ ë§¤ë§¤ (Staley/Turner)
    - ì „ì¼ ëŒ€ë¹„ 5~10% ê¸‰ë½ ì¢…ëª©ì˜ ê¸°ìˆ ì  ë°˜ë“± í¬ì°©
    - RSI 30 ì´í•˜ ê³¼ë§¤ë„ + ê±°ë˜ëŸ‰ ë°˜ë“± í™•ì¸
    - ëª©í‘œ ìˆ˜ìµë¥  3~5%, ì†ì ˆ -2% ì´ë‚´
    - ì½”ìŠ¤í”¼ ì ìš©: Aë“±ê¸‰ ëŒ€í˜•ì£¼ í•œì •, íˆ¬ì… ë¹„ì¤‘ 10~15%
    """
    
    def __init__(self):
        super().__init__("B1", StrategyCategory.BEAR)
        self.params = {
            "min_drop_pct": 5,           # ìµœì†Œ í•˜ë½ë¥  (%)
            "max_drop_pct": 10,          # ìµœëŒ€ í•˜ë½ë¥  (%)
            "rsi_threshold": 30,         # RSI ê³¼ë§¤ë„ ê¸°ì¤€
            "target_pct": 4,             # ëª©í‘œ ìˆ˜ìµë¥  (%)
            "stop_loss_pct": 2,          # ì†ì ˆ (%)
            "max_holding_hours": 4,      # ìµœëŒ€ ë³´ìœ  ì‹œê°„
            "grade_target": ["A"],
            "position_pct": 12.5,
        }
```

### 6.4 ë³€ë™ì„± ëŒíŒŒ ì „ëµ (ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤)

```python
class VolatilityBreakoutStrategy(BaseStrategy):
    """
    ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤ ë³€ë™ì„± ëŒíŒŒ ì „ëµ
    - ì „ì¼ ë³€ë™í­(ê³ ê°€-ì €ê°€) Ã— K(ê³„ìˆ˜) ë§Œí¼ ë‹¹ì¼ ì‹œê°€ì—ì„œ ëŒíŒŒ ì‹œ ë§¤ìˆ˜
    - ì¥ ë§ˆê° ì‹œ ì²­ì‚° (ë‹¹ì¼ ë§¤ë§¤ ì›ì¹™)
    - Kê°’: 0.3~0.6 (ë°±í…ŒìŠ¤íŠ¸ ìµœì í™”)
    """
    
    def __init__(self):
        super().__init__("VB", StrategyCategory.NEUTRAL)
        self.params = {
            "k_factor": 0.5,             # ë³€ë™í­ ê³„ìˆ˜
            "min_range_pct": 1.0,        # ìµœì†Œ ì „ì¼ ë³€ë™í­ (%)
        }
    
    async def generate_signal(self, stock, market_data) -> Optional[TradeSignal]:
        prev_high = market_data.prev_day["high"]
        prev_low = market_data.prev_day["low"]
        prev_range = prev_high - prev_low
        today_open = market_data.today_open
        
        # ëŒíŒŒ ëª©í‘œê°€ ê³„ì‚°
        breakout_price = today_open + prev_range * self.params["k_factor"]
        
        if market_data.current_price >= breakout_price:
            return TradeSignal(
                stock_code=stock.stock_code,
                action="BUY",
                strategy_code="VB",
                entry_price=market_data.current_price,
                stop_loss=today_open * 0.98,
                target_prices=[0],  # ì¥ ë§ˆê° ì‹œ ì²­ì‚°
                position_pct=self._adjust_position(stock.confidence, stock.grade),
                confidence=stock.confidence,
                reason=f"ë³€ë™ì„± ëŒíŒŒ: ì‹œê°€ {today_open:,.0f} + ì „ì¼ë³€ë™í­ "
                       f"{prev_range:,.0f} Ã— K({self.params['k_factor']}) = "
                       f"ëª©í‘œê°€ {breakout_price:,.0f}ì› ëŒíŒŒ",
                indicators_snapshot=self._capture_snapshot(market_data.indicators)
            )
        return None
```

### 6.5 ê·¸ë¦¬ë“œ ë§¤ë§¤ ì „ëµ

```python
class GridTradingStrategy(BaseStrategy):
    """
    ê·¸ë¦¬ë“œ ë§¤ë§¤ ì „ëµ â€” ë°•ìŠ¤ê¶Œ ì¥ì„¸ ìµœì í™”
    - ì •í•´ì§„ ê°€ê²©ëŒ€ë§ˆë‹¤ ì´˜ì´˜í•˜ê²Œ ë§¤ìˆ˜/ë§¤ë„ ë°˜ë³µ
    - ìƒ/í•˜í•œ ê°€ê²© ë²”ìœ„ ë‚´ ê· ë“± ë¶„í• 
    - ê·¸ë¦¬ë“œ ì´íƒˆ ì‹œ ì „ëµ ì¤‘ë‹¨
    """
    
    def __init__(self):
        super().__init__("GR", StrategyCategory.NEUTRAL)
        self.params = {
            "grid_count": 10,            # ê·¸ë¦¬ë“œ ìˆ˜
            "grid_range_pct": 10,        # ê·¸ë¦¬ë“œ ë²”ìœ„ (ìƒí•˜ %)
            "order_size_pct": 5,         # ê·¸ë¦¬ë“œë‹¹ ì£¼ë¬¸ ë¹„ì¤‘ (%)
            "max_position_pct": 30,      # ìµœëŒ€ í¬ì§€ì…˜ ë¹„ì¤‘ (%)
        }
    
    def calculate_grid(self, center_price: float) -> List[dict]:
        """ê·¸ë¦¬ë“œ ê°€ê²© ë ˆë²¨ ê³„ì‚°"""
        half_range = center_price * self.params["grid_range_pct"] / 100 / 2
        grid_step = half_range * 2 / self.params["grid_count"]
        
        grids = []
        for i in range(self.params["grid_count"] + 1):
            price = center_price - half_range + (grid_step * i)
            action = "BUY" if price < center_price else "SELL"
            grids.append({
                "level": i,
                "price": round(price),
                "action": action,
                "filled": False
            })
        return grids
```

### 6.6 ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ì „ëµ

```python
class DividendSwitchingStrategy(BaseStrategy):
    """
    ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ì „ëµ
    - ì›” ì´ˆ/ì›” ë§ ë°°ë‹¹ ì¼ì • ê¸°ë°˜ ì¢…ëª© ìë™ êµì²´
    - ë°°ë‹¹ë½ì¼ ì „ ì§„ì… â†’ ë°°ë‹¹ ìˆ˜ë ¹ í›„ êµì²´
    - ê³ ë°°ë‹¹ ìš°ëŸ‰ì£¼(Aë“±ê¸‰) ì¤‘ì‹¬ ìš´ìš©
    """
    
    def __init__(self):
        super().__init__("DS", StrategyCategory.NEUTRAL)
        self.dividend_calendar = {}  # {stock_code: [ë°°ë‹¹ì¼ ëª©ë¡]}
    
    async def check_switching_signal(self, date: datetime.date) -> List[TradeSignal]:
        """ë°°ë‹¹ ì¼ì • ê¸°ë°˜ êµì²´ ë§¤ë§¤ ì‹ í˜¸ ìƒì„±"""
        signals = []
        
        # ë°°ë‹¹ë½ 2ì¼ ì „: ê³ ë°°ë‹¹ì£¼ ë§¤ìˆ˜
        upcoming = self._get_upcoming_dividends(date, days_ahead=2)
        for stock in upcoming:
            if stock.dividend_yield >= 3.0:  # ë°°ë‹¹ìˆ˜ìµë¥  3% ì´ìƒ
                signals.append(self._create_buy_signal(stock))
        
        # ë°°ë‹¹ë½ ë‹¤ìŒ ë‚ : ê³¼ë§¤ë„ ë°˜ë“± ê¸°íšŒ íƒìƒ‰
        post_ex = self._get_post_ex_dividend(date)
        for stock in post_ex:
            if self._is_oversold_bounce(stock):
                signals.append(self._create_bounce_signal(stock))
        
        return signals
```

### 6.7 ì „ëµ ìë™ ì„ íƒê¸°

```python
class StrategySelector:
    """
    ì¥ì„¸ë³„ ì „ëµ ìë™ ì„ íƒê¸°
    - ì‹œì¥ ë ˆì§(ì¥ì„¸) íŒë‹¨ â†’ ì ìš© ê°€ëŠ¥ ì „ëµ í•„í„°ë§
    - ì¥ì„¸ íŒë‹¨ ê¸°ì¤€: ì½”ìŠ¤í”¼ ì´ë™í‰ê· ì„ , ìƒìŠ¹/í•˜ë½ ì¢…ëª© ë¹„ìœ¨, VIX
    """
    
    STRATEGY_MAP = {
        MarketRegime.STRONG_BULL: ["S1","S2","S3","S4","S5","VB","GR"],
        MarketRegime.BULL:        ["S1","S3","S4","S5","VB","GR"],
        MarketRegime.SIDEWAYS:    ["S5","VB","GR","B3"],
        MarketRegime.BEAR:        ["B1","B2","B3","B4","GR"],
        MarketRegime.STRONG_BEAR: ["B1","B2","B4"],
    }
    
    def detect_regime(self, kospi_data: dict) -> MarketRegime:
        """
        ì¥ì„¸ íŒë‹¨ (Elder Triple Screen 1ì°¨ í•„í„° + O'Neil Mìš”ì†Œ)
        """
        price = kospi_data["close"]
        ma50 = kospi_data["ma_50"]
        ma200 = kospi_data["ma_200"]
        advance_decline = kospi_data["advance_decline_ratio"]
        
        if price > ma50 > ma200 and advance_decline > 1.5:
            return MarketRegime.STRONG_BULL
        elif price > ma50 and price > ma200:
            return MarketRegime.BULL
        elif price < ma50 and price < ma200 and advance_decline < 0.5:
            return MarketRegime.STRONG_BEAR
        elif price < ma200:
            return MarketRegime.BEAR
        else:
            return MarketRegime.SIDEWAYS
    
    def select_strategies(self, regime: MarketRegime) -> List[BaseStrategy]:
        """í˜„ì¬ ì¥ì„¸ì— ì í•©í•œ ì „ëµ ëª©ë¡ ë°˜í™˜"""
        codes = self.STRATEGY_MAP[regime]
        return [s for s in self.all_strategies if s.strategy_code in codes]
```

---

## 7. ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—”ì§„

### 7.1 í†µí•© ë¦¬ìŠ¤í¬ ê´€ë¦¬ í”„ë ˆì„ì›Œí¬

```
[ë§¤ë§¤ ì‹ í˜¸] â”€â”€â–¶ [Position Sizer] â”€â”€â–¶ [Grade Allocator] â”€â”€â–¶ [Risk Check] â”€â”€â–¶ [ì£¼ë¬¸ ì‹¤í–‰]
                    â”‚                      â”‚                     â”‚
               Rë°°ìˆ˜ ê¸°ë°˜            ë“±ê¸‰ë³„ ë¹„ì¤‘ í•œë„      ë‹¤ë‹¨ê³„ ë¦¬ìŠ¤í¬ ê²€ì¦
               í¬ì§€ì…˜ í¬ê¸° ì‚°ì¶œ       í™•ì‹ ë„ ë°˜ì˜          (ì•„ë˜ 6ë‹¨ê³„)
```

#### 6ë‹¨ê³„ ë¦¬ìŠ¤í¬ ê²€ì¦ íŒŒì´í”„ë¼ì¸

| ë‹¨ê³„ | í•­ëª© | ê·œì¹™ | ì‹¤íŒ¨ ì‹œ ì¡°ì¹˜ | ê·¼ê±° |
|------|------|------|------------|------|
| 1 | ê±°ë˜ë‹¹ ë¦¬ìŠ¤í¬ | ì´ ìë³¸ì˜ 1~2% | í¬ì§€ì…˜ ì¶•ì†Œ | Elder 2% + Van Tharp |
| 2 | ì›”ê°„ ëˆ„ì  ì†ì‹¤ | ì´ ìë³¸ì˜ 6% | í•´ë‹¹ ì›” ë§¤ë§¤ ì¤‘ë‹¨ | Elder 6% Rule |
| 3 | ì¼ì¼ ìµœëŒ€ ì†ì‹¤ | ìë³¸ì˜ 3~5% | ë‹¹ì¼ ë§¤ë§¤ ì¤‘ë‹¨ | Cameron |
| 4 | ë“±ê¸‰ë³„ ë¹„ì¤‘ í•œë„ | A:30%, B:20%, C:10% | ë¹„ì¤‘ ì´ˆê³¼ë¶„ ê±°ë¶€ | Minervini/Elder |
| 5 | ì„¹í„° í¸ì¤‘ | ë™ì¼ ì„¹í„° 40% ì´ë‚´ | ì§„ì… ê±°ë¶€ | í¬íŠ¸í´ë¦¬ì˜¤ ì´ë¡  |
| 6 | íŠ¹ìˆ˜ ì´ë²¤íŠ¸ | ë§Œê¸°ì¼/FOMC ë“± | í˜„ê¸ˆ ë¹„ì¤‘ ì¶”ê°€ í™•ë³´ | Carter/Elder |

### 7.2 í¬ì§€ì…˜ ì‚¬ì´ì € (Van Tharp Rë°°ìˆ˜)

```python
class PositionSizer:
    """
    Van Tharp Rë°°ìˆ˜ ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•
    
    ê³µì‹: 1ê±´ë‹¹ íˆ¬ì…ê¸ˆì•¡ = ì´ìë³¸ Ã— ë¦¬ìŠ¤í¬ë¹„ìœ¨(%) Ã· ì†ì ˆí­(%)
    
    ì¥ì„¸ë³„ ë¦¬ìŠ¤í¬ ë¹„ìœ¨:
    - ìƒìŠ¹ì¥: 1.5~2%
    - ë³´í•©ì¥: 1~1.5%
    - í•˜ë½ì¥: 0.5~1%
    """
    
    RISK_BY_REGIME = {
        MarketRegime.STRONG_BULL: 0.02,
        MarketRegime.BULL:        0.018,
        MarketRegime.SIDEWAYS:    0.012,
        MarketRegime.BEAR:        0.008,
        MarketRegime.STRONG_BEAR: 0.005,
    }
    
    def calculate(self, total_capital: float, regime: MarketRegime,
                  entry_price: float, stop_loss: float,
                  grade: str, confidence: int) -> dict:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
        
        # 1. Rë°°ìˆ˜ ê¸°ë°˜ ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸°
        risk_pct = self.RISK_BY_REGIME[regime]
        max_risk_amount = total_capital * risk_pct       # 1R = ìµœëŒ€ ì†ì‹¤ í—ˆìš©ì•¡
        stop_loss_pct = abs(entry_price - stop_loss) / entry_price
        
        if stop_loss_pct == 0:
            return {"error": "ì†ì ˆí­ì´ 0ì…ë‹ˆë‹¤"}
        
        raw_position = max_risk_amount / stop_loss_pct   # íˆ¬ì… ê¸ˆì•¡
        raw_position_pct = raw_position / total_capital * 100
        
        # 2. ë“±ê¸‰ë³„ ìµœëŒ€ ë¹„ì¤‘ ì ìš©
        grade_limits = {"A": 30, "B": 20, "C": 10}
        max_grade_pct = grade_limits.get(grade, 10)
        
        # 3. í™•ì‹ ë„ ë°°ìˆ˜ ì ìš©
        confidence_multiplier = {5: 1.0, 4: 0.75, 3: 0.5}
        multiplier = confidence_multiplier.get(confidence, 0)
        
        if multiplier == 0:
            return {"error": "í™•ì‹ ë„ ë¶€ì¡± (â­2 ì´í•˜) â€” ë§¤ë§¤ ê¸ˆì§€"}
        
        adjusted_pct = min(raw_position_pct, max_grade_pct) * multiplier
        position_amount = total_capital * adjusted_pct / 100
        quantity = int(position_amount / entry_price)
        
        return {
            "position_amount": position_amount,
            "position_pct": adjusted_pct,
            "quantity": quantity,
            "risk_amount_1r": max_risk_amount,         # 1R ê¸ˆì•¡
            "stop_loss_pct": stop_loss_pct * 100,
            "r_multiple_target": [1, 2, 3],            # ëª©í‘œ Rë°°ìˆ˜
            "regime_risk_pct": risk_pct * 100,
            "grade_limit_pct": max_grade_pct,
            "confidence_multiplier": multiplier,
        }
```

### 7.3 íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘

```python
class TrailingStop:
    """
    ë‹¤ì¤‘ ë°©ì‹ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê´€ë¦¬
    
    | ë°©ì‹ | ì„¤ì • ê¸°ì¤€ | ì í•© ìƒí™© |
    |------|----------|----------|
    | ê³ ì • í¼ì„¼íŠ¸ | ê³ ì  ëŒ€ë¹„ -5~8% | ì¼ë°˜ ì¶”ì„¸ ì¶”ì¢… |
    | ì´ë™í‰ê· ì„  | 10ì¼/21ì¼ì„  ì¢…ê°€ ì´íƒˆ | ì¤‘ê¸° ìŠ¤ìœ™ |
    | ATR ê¸°ë°˜ | ê³ ì  ëŒ€ë¹„ 2Ã—ATR(14) | ë³€ë™ì„± ì ì‘í˜• |
    | ìº”ë“¤ íŒ¨í„´ | ì¥ëŒ€ìŒë´‰, ì„ë³„í˜• ì¶œí˜„ | ë‹¨ê¸° ë°˜ì „ ì‹ í˜¸ |
    | ê±°ë˜ëŸ‰ ì´ìƒ | ëŒ€ëŸ‰ê±°ë˜+ì¥ëŒ€ìŒë´‰ | ì„¸ë ¥ ë§¤ë„ ì‹ í˜¸ |
    """
    
    class Method(Enum):
        FIXED_PCT = "fixed_pct"
        MOVING_AVG = "moving_avg"
        ATR_BASED = "atr_based"
        CANDLE_PATTERN = "candle_pattern"
        VOLUME_ANOMALY = "volume_anomaly"
    
    def __init__(self, method: Method, params: dict):
        self.method = method
        self.params = params
        self.highest_price = 0.0  # ë³´ìœ  ì¤‘ ìµœê³ ê°€ ì¶”ì 
    
    def update_and_check(self, current_price: float, 
                          market_data: dict) -> Tuple[bool, str]:
        """ê°€ê²© ì—…ë°ì´íŠ¸ ë° ìŠ¤íƒ‘ ë°œë™ í™•ì¸"""
        self.highest_price = max(self.highest_price, current_price)
        
        if self.method == self.Method.FIXED_PCT:
            stop_price = self.highest_price * (1 - self.params["pct"] / 100)
            if current_price <= stop_price:
                return True, f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°œë™: ê³ ì  {self.highest_price:,.0f} â†’ í˜„ì¬ {current_price:,.0f} (âˆ’{self.params['pct']}%)"
        
        elif self.method == self.Method.ATR_BASED:
            atr = market_data["atr_14"]
            stop_price = self.highest_price - (atr * self.params["multiplier"])
            if current_price <= stop_price:
                return True, f"ATR íŠ¸ë ˆì¼ë§ ë°œë™: ê³ ì  {self.highest_price:,.0f} âˆ’ {self.params['multiplier']}Ã—ATR({atr:,.0f})"
        
        elif self.method == self.Method.MOVING_AVG:
            ma = market_data[f"ma_{self.params['period']}"]
            if current_price < ma:
                return True, f"{self.params['period']}ì¼ì„  ì´íƒˆ ({ma:,.0f}ì›)"
        
        return False, ""
```

### 7.4 ì¼ì¼ ì†ì‹¤ ì°¨ë‹¨ (Kill-Switch)

```python
class DailyKillSwitch:
    """
    ì¼ì¼ ì†ì‹¤ ì°¨ë‹¨ ì‹œìŠ¤í…œ (Cameron ë°©ì‹)
    - ë‹¹ì¼ ìì‚° ëŒ€ë¹„ ì„¤ì • % ì´ìƒ ì†ì‹¤ ì‹œ ë§¤ë§¤ ì¤‘ë‹¨
    - ëª¨ë“  ë¯¸ì²´ê²° ì£¼ë¬¸ ìë™ ì·¨ì†Œ
    - ì‹ ê·œ ì£¼ë¬¸ ì°¨ë‹¨
    """
    
    def __init__(self, daily_loss_limit_pct: float = 3.0):
        self.daily_loss_limit_pct = daily_loss_limit_pct
        self.is_killed = False
        self.start_of_day_capital = 0.0
    
    async def check(self, current_capital: float) -> bool:
        """Kill-Switch ë°œë™ ì—¬ë¶€ í™•ì¸"""
        if self.is_killed:
            return True
        
        daily_pnl_pct = ((current_capital - self.start_of_day_capital) 
                          / self.start_of_day_capital * 100)
        
        if daily_pnl_pct <= -self.daily_loss_limit_pct:
            self.is_killed = True
            logger.critical(
                f"ğŸš¨ KILL-SWITCH ë°œë™: ë‹¹ì¼ ì†ì‹¤ {daily_pnl_pct:.2f}% "
                f"(í•œë„: -{self.daily_loss_limit_pct}%)"
            )
            await self._emergency_shutdown()
            return True
        
        return False
    
    async def _emergency_shutdown(self):
        """ê¸´ê¸‰ ë§¤ë§¤ ì¤‘ë‹¨"""
        # 1. ëª¨ë“  ë¯¸ì²´ê²° ì£¼ë¬¸ ì·¨ì†Œ
        await self.order_manager.cancel_all_pending()
        # 2. ì‹ ê·œ ì£¼ë¬¸ ì°¨ë‹¨
        self.order_manager.block_new_orders = True
        # 3. ì•Œë¦¼ ì „ì†¡
        await self.notifier.send_critical(
            "ğŸš¨ ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼ â€” ë‹¹ì¼ ë§¤ë§¤ ì¤‘ë‹¨\n"
            "Cameron: 'ì˜¤ëŠ˜ ìƒì€ ëˆì€ ë‚´ì¼ ë²Œë©´ ëœë‹¤. ì˜¤ëŠ˜ ë” ìƒìœ¼ë©´ ë‚´ì¼ë„ ìœ„í—˜í•˜ë‹¤'"
        )
```

### 7.5 ë“œë¡œìš°ë‹¤ìš´ ëŒ€ì‘ í”„ë¡œí† ì½œ

```python
class DrawdownProtocol:
    """
    ë‹¨ê³„ë³„ ë“œë¡œìš°ë‹¤ìš´ ëŒ€ì‘ ë§¤ë‰´ì–¼
    
    | ìˆ˜ì¤€ | ìƒíƒœ | ëŒ€ì‘ |
    |------|------|------|
    | -2% (ì¼ì¼) | ğŸŸ¢ ì •ìƒ | ì¶”ê°€ ì§„ì… ì‹œ 50% ì¶•ì†Œ |
    | -3~5% (ì¼ì¼) | ğŸŸ¡ ê²½ê³„ | ë‹¹ì¼ ë§¤ë§¤ ì¤‘ë‹¨ |
    | -6% (ì›”ê°„) | ğŸŸ  ìœ„í—˜ | í•´ë‹¹ ì›” ë§¤ë§¤ ì¤‘ë‹¨ (Elder 6%) |
    | -10% (ëˆ„ì ) | ğŸ”´ ì‹¬ê° | 1ì£¼ ì¤‘ë‹¨ + ì‹œìŠ¤í…œ ì ê²€ + ëª¨ì˜íˆ¬ì ì „í™˜ |
    | -15%+ | âš« ë¹„ìƒ | ë¬´ê¸°í•œ ì¤‘ë‹¨ + ì „ëµ ì¬ê²€ì¦ |
    """
    
    class Level(Enum):
        GREEN = ("GREEN", -2, "ì •ìƒ")
        YELLOW = ("YELLOW", -5, "ê²½ê³„")
        ORANGE = ("ORANGE", -6, "ìœ„í—˜")
        RED = ("RED", -10, "ì‹¬ê°")
        BLACK = ("BLACK", -15, "ë¹„ìƒ")
    
    async def evaluate_and_respond(self, daily_pnl_pct: float, 
                                     monthly_pnl_pct: float,
                                     cumulative_pnl_pct: float) -> dict:
        """ë“œë¡œìš°ë‹¤ìš´ ìˆ˜ì¤€ í‰ê°€ ë° ëŒ€ì‘ ì¡°ì¹˜"""
        
        # ë¹„ìƒ (ëˆ„ì  -15% ì´ìƒ)
        if cumulative_pnl_pct <= -15:
            return await self._respond_black(cumulative_pnl_pct)
        
        # ì‹¬ê° (ëˆ„ì  -10%)
        if cumulative_pnl_pct <= -10:
            return await self._respond_red(cumulative_pnl_pct)
        
        # ìœ„í—˜ (ì›”ê°„ -6%)
        if monthly_pnl_pct <= -6:
            return await self._respond_orange(monthly_pnl_pct)
        
        # ê²½ê³„ (ì¼ì¼ -3~5%)
        if daily_pnl_pct <= -3:
            return await self._respond_yellow(daily_pnl_pct)
        
        # ì •ìƒ
        return {"level": "GREEN", "action": "continue", "position_reduction": 0}
    
    async def _respond_red(self, pnl_pct: float) -> dict:
        """ğŸ”´ ì‹¬ê°: 1ì£¼ì¼ ë§¤ë§¤ ì¤‘ë‹¨"""
        logger.critical(f"ğŸ”´ ë“œë¡œìš°ë‹¤ìš´ ì‹¬ê°: {pnl_pct:.2f}%")
        
        # ëª¨ë“  í¬ì§€ì…˜ ì²­ì‚°
        await self.order_manager.close_all_positions()
        # ë§¤ë§¤ ëª¨ë“œë¥¼ PAPERë¡œ ì „í™˜
        await self.config.set("trade_mode", "PAPER")
        # ë³µê·€ ì¡°ê±´: ëª¨ì˜íˆ¬ì 5ì—°ìŠ¹
        
        await self.notifier.send_critical(
            f"ğŸ”´ ëˆ„ì  ì†ì‹¤ {pnl_pct:.2f}% â€” ìµœì†Œ 1ì£¼ì¼ ë§¤ë§¤ ì¤‘ë‹¨\n"
            f"Van Tharp: 'ì‹œìŠ¤í…œì´ ì•„ë‹ˆë¼ ë‹¹ì‹ ì´ ë¬¸ì œì¼ ìˆ˜ ìˆë‹¤'\n"
            f"ë³µê·€ ì¡°ê±´: ëª¨ì˜íˆ¬ì 5ì—°ìŠ¹ ë‹¬ì„±"
        )
        
        # ë“œë¡œìš°ë‹¤ìš´ ì´ë ¥ ê¸°ë¡
        await self.db.insert_drawdown_log("RED", pnl_pct, "1ì£¼ì¼ ë§¤ë§¤ ì¤‘ë‹¨, ëª¨ì˜íˆ¬ì ì „í™˜")
        
        return {
            "level": "RED",
            "action": "halt_1_week",
            "switch_to_paper": True,
            "recovery_condition": "paper_5_consecutive_wins"
        }
```

### 7.6 ë“±ê¸‰ë³„ ë¹„ì¤‘ ë°°ë¶„ê¸°

```python
class GradeAllocator:
    """
    ì¢…ëª© ë“±ê¸‰ë³„ íˆ¬ì ë¹„ì¤‘ ê´€ë¦¬ (A/B/C)
    
    | ë“±ê¸‰ | ë‹¨ì¼ ì¢…ëª© ìµœëŒ€ | ë™ì‹œ ë³´ìœ  | ë“±ê¸‰ ì´ ë¹„ì¤‘ |
    |------|--------------|----------|------------|
    | Aë“±ê¸‰ | 30% | 1~2ì¢…ëª© | 50% |
    | Bë“±ê¸‰ | 20% | 2~3ì¢…ëª© | 40% |
    | Cë“±ê¸‰ | 10% | 1~2ì¢…ëª© | 15% |
    """
    
    # ì¥ì„¸ë³„ ë¹„ì¤‘ ì¡°ì • í…Œì´ë¸”
    REGIME_ALLOCATION = {
        MarketRegime.STRONG_BULL: {"A": 35, "B": 30, "C": 10, "cash": 30},
        MarketRegime.BULL:        {"A": 30, "B": 25, "C": 5,  "cash": 40},
        MarketRegime.SIDEWAYS:    {"A": 25, "B": 20, "C": 5,  "cash": 50},
        MarketRegime.BEAR:        {"A": 20, "B": 15, "C": 0,  "cash": 65},
        MarketRegime.STRONG_BEAR: {"A": 15, "B": 10, "C": 0,  "cash": 80},
    }
    
    def validate_allocation(self, signal: TradeSignal, 
                             current_positions: List[dict],
                             regime: MarketRegime) -> Tuple[bool, str]:
        """ë¹„ì¤‘ ë°°ë¶„ ìœ íš¨ì„± ê²€ì¦"""
        alloc = self.REGIME_ALLOCATION[regime]
        grade = signal.grade
        
        # 1. ë“±ê¸‰ ì´ ë¹„ì¤‘ í•œë„ í™•ì¸
        current_grade_pct = sum(
            p["position_pct"] for p in current_positions if p["grade"] == grade
        )
        if current_grade_pct + signal.position_pct > alloc[grade]:
            return False, f"{grade}ë“±ê¸‰ ì´ ë¹„ì¤‘ ì´ˆê³¼: {current_grade_pct + signal.position_pct:.1f}% > {alloc[grade]}%"
        
        # 2. ë™ì¼ ì„¹í„° 40% í•œë„ í™•ì¸
        same_sector_pct = sum(
            p["position_pct"] for p in current_positions 
            if p["sector"] == signal.sector
        )
        if same_sector_pct + signal.position_pct > 40:
            return False, f"ë™ì¼ ì„¹í„°({signal.sector}) í¸ì¤‘: {same_sector_pct + signal.position_pct:.1f}% > 40%"
        
        # 3. í˜„ê¸ˆ ë¹„ì¤‘ ìµœì†Œ ìš”ê±´ í™•ì¸
        total_invested = sum(p["position_pct"] for p in current_positions)
        if total_invested + signal.position_pct > (100 - alloc["cash"]):
            return False, f"í˜„ê¸ˆ ë¹„ì¤‘ ë¶€ì¡±: ìµœì†Œ {alloc['cash']}% ìœ ì§€ í•„ìš”"
        
        return True, "OK"
```

---

## 8. ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ

### 8.1 ë§¤ë§¤ ë³µê¸°ìš© ë¡œê·¸ (ìë™ ë§¤ë§¤ì¼ì§€)

```python
class TradeJournal:
    """
    ìë™ ë§¤ë§¤ì¼ì§€ ì‹œìŠ¤í…œ (Steenbarger + Van Tharp í†µí•©)
    
    ë§¤ ê±°ë˜ ì™„ë£Œ ì‹œ ìë™ ê¸°ë¡:
    - ê±°ë˜ ê¸°ë¡: ì¢…ëª©, ê°€ê²©, ìˆ˜ëŸ‰, Rë°°ìˆ˜, ë³´ìœ ê¸°ê°„, ì§„ì…ì „ëµ
    - ì‹œì¥ ì§€í‘œ ìŠ¤ëƒ…ìƒ·: MA, RSI, VWAP, BB, ê±°ë˜ëŸ‰, ìˆ˜ê¸‰ ë“±
    - ì‹¬ë¦¬ ê¸°ë¡ì€ ì‚¬ìš©ì ì…ë ¥ìœ¼ë¡œ ë³´ì™„ (ì„ íƒì‚¬í•­)
    """
    
    async def record_trade(self, trade: Trade, market_snapshot: dict):
        """ë§¤ë§¤ ì™„ë£Œ ì‹œ ìë™ ê¸°ë¡"""
        
        # Rë°°ìˆ˜ ê³„ì‚°
        risk_1r = abs(trade.entry_price - trade.stop_loss) * trade.quantity
        actual_pnl = (trade.exit_price - trade.entry_price) * trade.quantity
        r_multiple = actual_pnl / risk_1r if risk_1r > 0 else 0
        
        journal_entry = {
            "trade_id": trade.trade_id,
            "stock_code": trade.stock_code,
            "stock_grade": trade.grade,
            "entry_strategy": trade.strategy_code,
            "entry_price": trade.entry_price,
            "exit_price": trade.exit_price,
            "quantity": trade.quantity,
            "pnl_amount": actual_pnl,
            "r_multiple": r_multiple,
            "holding_period": trade.holding_period,
            "checklist_score": trade.checklist_score,
            # ì‹œì¥ ì§€í‘œ ìŠ¤ëƒ…ìƒ· (ë§¤ë§¤ ì‹œì )
            "snapshot_json": {
                "ma_5": market_snapshot["ma_5"],
                "ma_20": market_snapshot["ma_20"],
                "ma_50": market_snapshot["ma_50"],
                "rsi_14": market_snapshot["rsi_14"],
                "vwap": market_snapshot["vwap"],
                "bollinger": market_snapshot["bollinger"],
                "volume": market_snapshot["volume"],
                "volume_ratio": market_snapshot["volume_ratio"],  # í‰ê·  ëŒ€ë¹„ ë°°ìˆ˜
                "foreign_flow": market_snapshot["foreign_flow"],
                "inst_flow": market_snapshot["inst_flow"],
                "kospi_close": market_snapshot["kospi_close"],
                "market_regime": market_snapshot["regime"],
            },
            "market_regime": market_snapshot["regime"],
        }
        
        await self.db.insert_journal(journal_entry)
        
        # Rë°°ìˆ˜ ì´ìƒ ê°ì§€ ê²½ê³ 
        if r_multiple < -1:
            logger.warning(
                f"âš ï¸ ê³¼ëŒ€ ì†ì‹¤ ê²½ê³ : {trade.stock_code} Rë°°ìˆ˜ = {r_multiple:.2f} "
                f"(-1R ì´ˆê³¼ â€” ì†ì ˆ ê·œì¹™ ìœ„ë°˜ ê°€ëŠ¥ì„±)"
            )
```

### 8.2 ì„±ê³¼ ë¶„ì„ê¸°

```python
class PerformanceAnalyzer:
    """
    Rë°°ìˆ˜, SQN, ìŠ¹ë¥  ë“± ì„±ê³¼ ë¶„ì„
    
    SQN = (Rë°°ìˆ˜ í‰ê·  Ã· Rë°°ìˆ˜ í‘œì¤€í¸ì°¨) Ã— âˆšë§¤ë§¤íšŸìˆ˜
    
    | SQN | í’ˆì§ˆ | ëŒ€ì‘ |
    |-----|------|------|
    | <1.6 | ë‚˜ì¨ | ì „ëµ ì¬ê²€í†  |
    | 1.6~2.0 | í‰ê·  ì´í•˜ | ê°œì„  í•„ìš” |
    | 2.0~3.0 | ì–‘í˜¸ | ì •ìƒ ìš´ìš© |
    | 3.0~5.0 | ìš°ìˆ˜ | ê³µê²©ì  í™•ëŒ€ ê°€ëŠ¥ |
    | 5.0~7.0 | íƒì›” | ë§¤ìš° ë“œë¬¸ ìˆ˜ì¤€ |
    | >7.0 | ì„±ë°° | ê³¼ìµœì í™” ì ê²€ |
    """
    
    def calculate_sqn(self, r_multiples: List[float]) -> dict:
        """SQN (System Quality Number) ê³„ì‚°"""
        n = len(r_multiples)
        if n < 30:
            return {"sqn": None, "note": f"ìµœì†Œ 30íšŒ í•„ìš” (í˜„ì¬ {n}íšŒ)"}
        
        avg_r = sum(r_multiples) / n
        std_r = (sum((r - avg_r) ** 2 for r in r_multiples) / n) ** 0.5
        
        if std_r == 0:
            return {"sqn": None, "note": "í‘œì¤€í¸ì°¨ 0"}
        
        sqn = (avg_r / std_r) * (n ** 0.5)
        
        quality = self._interpret_sqn(sqn)
        
        return {
            "sqn": round(sqn, 4),
            "avg_r": round(avg_r, 4),
            "std_r": round(std_r, 4),
            "trade_count": n,
            "quality": quality,
            "win_rate": sum(1 for r in r_multiples if r > 0) / n * 100,
        }
    
    async def generate_weekly_review(self, week_start: date) -> dict:
        """ì£¼ê°„ ì„±ê³¼ ë¦¬ë·° ìë™ ìƒì„±"""
        trades = await self.db.get_trades_in_range(week_start, week_start + timedelta(days=7))
        r_multiples = [t.r_multiple for t in trades]
        
        return {
            "period": f"{week_start} ~ {week_start + timedelta(days=6)}",
            "total_trades": len(trades),
            "win_count": sum(1 for r in r_multiples if r > 0),
            "loss_count": sum(1 for r in r_multiples if r <= 0),
            "win_rate": sum(1 for r in r_multiples if r > 0) / max(len(trades), 1) * 100,
            "avg_r_multiple": sum(r_multiples) / max(len(r_multiples), 1),
            "max_r": max(r_multiples, default=0),
            "min_r": min(r_multiples, default=0),
            "rule_violations": sum(1 for t in trades if not t.rule_compliance),
            "best_trade": self._get_best_trade(trades),
            "worst_trade": self._get_worst_trade(trades),
            "strategy_breakdown": self._strategy_performance(trades),
        }
```

### 8.3 ì•Œë¦¼ ì„œë¹„ìŠ¤

```python
class NotificationService:
    """
    ë§¤ë§¤ ì•Œë¦¼ í†µí•© ì„œë¹„ìŠ¤
    - ë§¤ë§¤ ì²´ê²° ì•Œë¦¼ (ë§¤ìˆ˜/ë§¤ë„/ì†ì ˆ/ìµì ˆ)
    - ë¦¬ìŠ¤í¬ ê²½ê³  (Kill-Switch, ë“œë¡œìš°ë‹¤ìš´)
    - ì¼ê°„/ì£¼ê°„ ì„±ê³¼ ë¦¬í¬íŠ¸
    - íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ì•Œë¦¼ (FOMC, ë§Œê¸°ì¼ ë“±)
    """
    
    class Priority(Enum):
        INFO = "info"           # ì¼ë°˜ ë§¤ë§¤ ì²´ê²°
        WARNING = "warning"     # ì—°ì† ì†ì‹¤, ë¹„ì¤‘ ì´ˆê³¼ ë“±
        CRITICAL = "critical"   # Kill-Switch, ë“œë¡œìš°ë‹¤ìš´ ì‹¬ê°
    
    async def send_trade_notification(self, trade: Trade, r_multiple: float):
        """ë§¤ë§¤ ì²´ê²° ì•Œë¦¼"""
        emoji = "ğŸ“ˆ" if trade.pnl_amount >= 0 else "ğŸ“‰"
        
        message = (
            f"{emoji} [{trade.strategy_code}] {trade.stock_name} "
            f"{'ë§¤ìˆ˜' if trade.order_type == 'BUY' else 'ë§¤ë„'}\n"
            f"ê°€ê²©: {trade.exit_price:,.0f}ì› | ìˆ˜ëŸ‰: {trade.quantity}ì£¼\n"
            f"ì†ìµ: {trade.pnl_amount:+,.0f}ì› ({trade.pnl_percent:+.2f}%)\n"
            f"Rë°°ìˆ˜: {r_multiple:+.2f}R"
        )
        
        await self._send(message, self.Priority.INFO)
    
    async def send_event_alert(self, event: dict):
        """íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ì‚¬ì „ ì•Œë¦¼"""
        message = (
            f"ğŸ“… [{event['event_type']}] {event['event_name']}\n"
            f"ì¼ì‹œ: {event['event_date']}\n"
            f"ì˜í–¥: {event['market_impact']}\n"
            f"ëŒ€ì‘: {event['trading_action']}\n"
            f"í˜„ê¸ˆ ì¶”ê°€ í™•ë³´: +{event['cash_adjust_pct']}%"
        )
        await self._send(message, self.Priority.WARNING)
```

---

## 9. AI ìì—°ì–´ ì²˜ë¦¬ (MCP í†µí•©)

### 9.1 MCP í•¸ë“¤ëŸ¬

```python
class MCPHandler:
    """
    MCP(Model Context Protocol) ê¸°ë°˜ ìì—°ì–´ ë§¤ë§¤ ëª…ë ¹ ì²˜ë¦¬
    
    ì˜ˆì‹œ ëª…ë ¹:
    - "ì‚¼ì„±ì „ìê°€ 3% ì˜¤ë¥´ë©´ 10ì£¼ ì‚¬ì¤˜"
    - "í˜„ì¬ ë³´ìœ  ì¢…ëª© ì „ì²´ ì†ì ˆê°€ 5%ë¡œ ì¡°ì •í•´ì¤˜"
    - "ì˜¤ëŠ˜ ë§¤ë§¤ ì„±ê³¼ ìš”ì•½í•´ì¤˜"
    - "SKí•˜ì´ë‹‰ìŠ¤ VWAP ì „ëµìœ¼ë¡œ ë§¤ìˆ˜ ì¤€ë¹„í•´ì¤˜"
    """
    
    SUPPORTED_INTENTS = {
        "conditional_buy":  "ì¡°ê±´ë¶€ ë§¤ìˆ˜",
        "conditional_sell": "ì¡°ê±´ë¶€ ë§¤ë„",
        "modify_stop_loss": "ì†ì ˆê°€ ë³€ê²½",
        "status_inquiry":   "ìƒíƒœ ì¡°íšŒ",
        "performance_report": "ì„±ê³¼ ë³´ê³ ",
        "strategy_setup":   "ì „ëµ ì„¤ì •",
        "cancel_order":     "ì£¼ë¬¸ ì·¨ì†Œ",
    }
    
    async def process_command(self, natural_language: str) -> dict:
        """ìì—°ì–´ â†’ ë§¤ë§¤ ëª…ë ¹ ë³€í™˜ ë° ì‹¤í–‰"""
        
        # 1. ì˜ë„ íŒŒì‹±
        intent = await self.nlp_parser.parse_intent(natural_language)
        
        # 2. ì—”í‹°í‹° ì¶”ì¶œ (ì¢…ëª©ëª…, ê°€ê²©, ìˆ˜ëŸ‰, ì¡°ê±´ ë“±)
        entities = await self.nlp_parser.extract_entities(natural_language)
        
        # 3. ëª…ë ¹ ê²€ì¦
        validation = self._validate_command(intent, entities)
        if not validation["is_valid"]:
            return {"status": "error", "message": validation["error"]}
        
        # 4. ì‚¬ìš©ì í™•ì¸ (ì‹¤ì „ ëª¨ë“œì—ì„œ ì¤‘ìš” ëª…ë ¹)
        if self.trade_mode == "LIVE" and intent in ("conditional_buy", "conditional_sell"):
            return {
                "status": "pending_confirmation",
                "message": f"ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n{self._format_command(intent, entities)}",
                "command": {"intent": intent, "entities": entities}
            }
        
        # 5. ì‹¤í–‰
        return await self._execute_command(intent, entities)
    
    async def _execute_command(self, intent: str, entities: dict) -> dict:
        """íŒŒì‹±ëœ ëª…ë ¹ ì‹¤í–‰"""
        
        if intent == "conditional_buy":
            # "ì‚¼ì„±ì „ìê°€ 3% ì˜¤ë¥´ë©´ 10ì£¼ ì‚¬ì¤˜"
            stock_code = entities["stock_code"]       # 005930
            condition = entities["condition"]          # price_change >= 3%
            quantity = entities["quantity"]             # 10
            
            # ì¡°ê±´ ê°ì‹œ ë“±ë¡
            await self.condition_monitor.register({
                "stock_code": stock_code,
                "condition_type": "price_change_pct",
                "threshold": entities["threshold"],    # 3.0
                "direction": entities["direction"],    # "up"
                "action": "BUY",
                "quantity": quantity,
            })
            
            return {
                "status": "registered",
                "message": f"{entities['stock_name']} {entities['threshold']}% ìƒìŠ¹ ì‹œ "
                           f"{quantity}ì£¼ ë§¤ìˆ˜ ì¡°ê±´ ë“±ë¡ ì™„ë£Œ"
            }
```

### 9.2 ìì—°ì–´ íŒŒì„œ

```python
class NLPParser:
    """
    ìì—°ì–´ ë§¤ë§¤ ëª…ë ¹ íŒŒì‹± ì—”ì§„
    - ì¢…ëª©ëª… â†’ ì¢…ëª©ì½”ë“œ ë§¤í•‘
    - ê°€ê²© ì¡°ê±´ ì¶”ì¶œ (% ë³€ë™, ì ˆëŒ€ê°€ê²©)
    - ìˆ˜ëŸ‰/ê¸ˆì•¡ ì¶”ì¶œ
    - ì „ëµëª… ì¸ì‹
    """
    
    STOCK_ALIASES = {
        "ì‚¼ì„±ì „ì": "005930", "ì‚¼ì „": "005930",
        "SKí•˜ì´ë‹‰ìŠ¤": "000660", "í•˜ì´ë‹‰ìŠ¤": "000660",
        "í˜„ëŒ€ì°¨": "005380", "í˜„ëŒ€ìë™ì°¨": "005380",
        # ... (ì£¼ìš” ì¢…ëª© ì‚¬ì „)
    }
    
    CONDITION_PATTERNS = [
        (r"(\d+(?:\.\d+)?)\s*%\s*(ì˜¤ë¥´|ìƒìŠ¹|ì˜¬ë¼)", "price_up_pct"),
        (r"(\d+(?:\.\d+)?)\s*%\s*(ë‚´ë¦¬|í•˜ë½|ë–¨ì–´)", "price_down_pct"),
        (r"(\d+(?:,\d+)?)\s*ì›\s*(ì´ìƒ|ë„˜ìœ¼|ëŒíŒŒ)", "price_above"),
        (r"(\d+(?:,\d+)?)\s*ì›\s*(ì´í•˜|ë°‘ìœ¼)", "price_below"),
    ]
    
    async def parse_intent(self, text: str) -> str:
        """ì˜ë„ ë¶„ë¥˜"""
        if any(kw in text for kw in ["ì‚¬ì¤˜", "ë§¤ìˆ˜", "ì‚¬"]):
            return "conditional_buy" if "ë©´" in text or "ì‹œ" in text else "buy"
        elif any(kw in text for kw in ["íŒ”ì•„", "ë§¤ë„", "íŒ”"]):
            return "conditional_sell" if "ë©´" in text or "ì‹œ" in text else "sell"
        elif any(kw in text for kw in ["ì†ì ˆ", "ìŠ¤íƒ‘"]):
            return "modify_stop_loss"
        elif any(kw in text for kw in ["ì„±ê³¼", "ìˆ˜ìµ", "ê²°ê³¼"]):
            return "performance_report"
        elif any(kw in text for kw in ["ìƒíƒœ", "ì”ê³ ", "í¬ì§€ì…˜"]):
            return "status_inquiry"
        return "unknown"
```

---

## 10. ì˜ˆì™¸ ì²˜ë¦¬ ë° ì¥ì•  ëŒ€ì‘

### 10.1 ì˜ˆì™¸ ì²˜ë¦¬ ì‹œë‚˜ë¦¬ì˜¤

| ì‹œë‚˜ë¦¬ì˜¤ | ê°ì§€ ë°©ë²• | ëŒ€ì‘ ì¡°ì¹˜ | ë³µêµ¬ ì „ëµ |
|---------|----------|----------|----------|
| **ë„¤íŠ¸ì›Œí¬ ë‹¨ì ˆ** | aiohttp.ClientError, TimeoutError | ë¯¸ì²´ê²° ì£¼ë¬¸ ìƒíƒœ í™•ì¸ í›„ ì¬ì—°ê²° | Exponential Backoff (ìµœëŒ€ 60ì´ˆ) |
| **ì¦ê¶Œì‚¬ ì„œë²„ ì ê²€** | HTTP 503, íŠ¹ì • ì‹œê°„ëŒ€ (06:30~08:00) | ë§¤ë§¤ ì¼ì‹œ ì¤‘ì§€, ì ê²€ ì™„ë£Œ í›„ ìë™ ì¬ê°œ | ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ìë™ ë³µêµ¬ |
| **ì£¼ë¬¸ ì‹¤íŒ¨** | rt_cd != "0", msg_cd ë¶„ì„ | ì‹¤íŒ¨ ì›ì¸ë³„ ë¶„ê¸° ì²˜ë¦¬ (ì•„ë˜ ìƒì„¸) | ì¬ì£¼ë¬¸ ë˜ëŠ” í¬ê¸° |
| **í† í° ë§Œë£Œ** | 401 Unauthorized | ì¦‰ì‹œ í† í° ì¬ë°œê¸‰ í›„ ì¬ì‹œë„ | TokenManager ìë™ ê°±ì‹  |
| **WebSocket ì—°ê²° ëŠê¹€** | ConnectionClosed | êµ¬ë… ëª©ë¡ ë³´ì¡´ í›„ ì¬ì—°ê²° | ì¬ì—°ê²° í›„ êµ¬ë… ìë™ ë³µì› |
| **ë°ì´í„° ëˆ„ë½** | ì‹œì„¸ ë°ì´í„° None/ë¹„ì •ìƒê°’ | í•´ë‹¹ ì¢…ëª© ì‹ í˜¸ ìƒì„± ìŠ¤í‚µ | REST API ë³´ì¡° ì¡°íšŒ |
| **DB ì¥ì• ** | OperationalError | ë§¤ë§¤ ì¤‘ë‹¨ (ê¸°ë¡ ë¶ˆê°€ ì‹œ ë§¤ë§¤ ë¶ˆê°€) | íŒŒì¼ ë¡œê·¸ ëŒ€ì²´ í›„ ë³µêµ¬ ì‹œ ë™ê¸°í™” |

### 10.2 ì£¼ë¬¸ ì‹¤íŒ¨ ìƒì„¸ ì²˜ë¦¬

```python
class OrderErrorHandler:
    """ì£¼ë¬¸ ì‹¤íŒ¨ ì›ì¸ë³„ ë¶„ê¸° ì²˜ë¦¬"""
    
    ERROR_RESPONSES = {
        "OPSQ0004": {  # ë§¤ë§¤ì œí•œì¢…ëª©
            "action": "skip",
            "message": "ë§¤ë§¤ì œí•œì¢…ëª© â€” í•´ë‹¹ ì¢…ëª© ì œì™¸"
        },
        "OPSQ0005": {  # ê°€ê²©ì œí•œ ì´ˆê³¼
            "action": "adjust_price",
            "message": "ê°€ê²© ë²”ìœ„ ì´ˆê³¼ â€” ì‹œì¥ê°€ë¡œ ì¬ì£¼ë¬¸"
        },
        "OPSQ0009": {  # ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ ì´ˆê³¼
            "action": "reduce_quantity",
            "message": "ì£¼ë¬¸ê¸ˆì•¡ ì´ˆê³¼ â€” ìˆ˜ëŸ‰ ì¶•ì†Œ í›„ ì¬ì£¼ë¬¸"
        },
        "OPSQ0099": {  # ì‹œìŠ¤í…œ ì˜¤ë¥˜
            "action": "retry",
            "message": "ì¦ê¶Œì‚¬ ì‹œìŠ¤í…œ ì˜¤ë¥˜ â€” 3ì´ˆ í›„ ì¬ì‹œë„",
            "retry_count": 3,
            "retry_delay": 3
        },
    }
    
    async def handle_error(self, error_code: str, original_order: dict) -> dict:
        """ì—ëŸ¬ ì½”ë“œë³„ ìë™ ëŒ€ì‘"""
        handler = self.ERROR_RESPONSES.get(error_code)
        if not handler:
            logger.error(f"ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ ì½”ë“œ: {error_code}")
            return {"action": "manual_review", "order": original_order}
        
        if handler["action"] == "retry":
            for i in range(handler["retry_count"]):
                await asyncio.sleep(handler["retry_delay"])
                result = await self.order_manager.retry_order(original_order)
                if result["success"]:
                    return result
        
        elif handler["action"] == "reduce_quantity":
            reduced = original_order.copy()
            reduced["quantity"] = int(original_order["quantity"] * 0.8)
            return await self.order_manager.place_order(**reduced)
        
        return {"action": handler["action"], "message": handler["message"]}
```

### 10.3 ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬

```python
class HealthChecker:
    """ì‹œìŠ¤í…œ ìƒíƒœ ì£¼ê¸°ì  ì ê²€ (ë§¤ 5ë¶„)"""
    
    async def check_all(self) -> dict:
        return {
            "api_connection": await self._check_api(),
            "websocket": await self._check_websocket(),
            "database": await self._check_database(),
            "token_valid": self._check_token(),
            "disk_space": self._check_disk(),
            "memory_usage": self._check_memory(),
            "timestamp": datetime.now().isoformat(),
        }
    
    async def _check_api(self) -> dict:
        """REST API ì—°ê²° ìƒíƒœ í™•ì¸ (ì½”ìŠ¤í”¼ ì§€ìˆ˜ ì¡°íšŒ)"""
        try:
            start = time.monotonic()
            result = await self.rest_client.get_current_price("0001")  # ì½”ìŠ¤í”¼ ì§€ìˆ˜
            latency = (time.monotonic() - start) * 1000
            return {"status": "OK", "latency_ms": round(latency, 1)}
        except Exception as e:
            return {"status": "ERROR", "error": str(e)}
```

---

## 11. ë°°í¬ ë° ìš´ì˜

### 11.1 ì‹¤í–‰ ìŠ¤ì¼€ì¤„

```python
DAILY_SCHEDULE = {
    "06:30": "ì‹œìŠ¤í…œ ê¸°ë™ + í—¬ìŠ¤ì²´í¬",
    "08:00": "í† í° ê°±ì‹  í™•ì¸",
    "08:30": "ì¢…ëª© ìŠ¤ìºë‹ (StockScreener.scan_daily)",
    "08:50": "ì „ëµ ì„ íƒ + ë§¤ë§¤ ì‹œë‚˜ë¦¬ì˜¤ ì¤€ë¹„",
    "09:00": "WebSocket êµ¬ë… ì‹œì‘ + ì‹œì¥ ê°ì‹œ ê°œì‹œ",
    "09:00~15:30": "ì‹¤ì‹œê°„ ë§¤ë§¤ ë£¨í”„",
    "15:30": "ì¥ ë§ˆê° â€” ë¯¸ì²´ê²° ì£¼ë¬¸ ì²˜ë¦¬",
    "15:40": "ì¼ê°„ í†µê³„ ì§‘ê³„ + ë§¤ë§¤ì¼ì§€ ë§ˆê°",
    "16:00": "ì„±ê³¼ ë¦¬í¬íŠ¸ ìƒì„± + ì•Œë¦¼ ì „ì†¡",
    "16:30": "WebSocket ì—°ê²° ì¢…ë£Œ",
    "ë§¤ì£¼ ê¸ˆìš”ì¼ 16:00": "ì£¼ê°„ ë¦¬ë·° ìƒì„±",
    "ë§¤ì›” ë§ 16:00": "ì›”ê°„ ë¦¬ë·° + SQN ì‚°ì¶œ",
}
```

### 11.2 í™˜ê²½ ì„¤ì •

```python
# config/settings.py
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    # KIS API
    KIS_APP_KEY = os.getenv("KIS_APP_KEY")
    KIS_APP_SECRET = os.getenv("KIS_APP_SECRET")
    KIS_ACCOUNT_NO = os.getenv("KIS_ACCOUNT_NO")
    KIS_ACCOUNT_PROD_CODE = os.getenv("KIS_ACCOUNT_PROD_CODE", "01")
    
    # ë§¤ë§¤ ëª¨ë“œ
    TRADE_MODE = os.getenv("TRADE_MODE", "PAPER")  # LIVE / PAPER
    
    # ë°ì´í„°ë² ì´ìŠ¤
    DB_TYPE = os.getenv("DB_TYPE", "sqlite")  # sqlite / postgresql
    DB_URL = os.getenv("DB_URL", "sqlite:///kats.db")
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    TOTAL_CAPITAL = int(os.getenv("TOTAL_CAPITAL", "100000000"))
    RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.02"))
    DAILY_LOSS_LIMIT = float(os.getenv("DAILY_LOSS_LIMIT", "0.03"))
    MONTHLY_LOSS_LIMIT = float(os.getenv("MONTHLY_LOSS_LIMIT", "0.06"))
    
    # ì•Œë¦¼
    SLACK_WEBHOOK_URL = os.getenv("SLACK_WEBHOOK_URL")
    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
```

### 11.3 ì˜ì¡´ì„± íŒ¨í‚¤ì§€

```
# requirements.txt
aiohttp>=3.9.0          # ë¹„ë™ê¸° HTTP í´ë¼ì´ì–¸íŠ¸
websockets>=12.0        # WebSocket í´ë¼ì´ì–¸íŠ¸
sqlalchemy>=2.0         # ORM
asyncpg>=0.29           # PostgreSQL ë¹„ë™ê¸° ë“œë¼ì´ë²„
aiosqlite>=0.20         # SQLite ë¹„ë™ê¸° ë“œë¼ì´ë²„
apscheduler>=3.10       # ìŠ¤ì¼€ì¤„ëŸ¬
python-dotenv>=1.0      # í™˜ê²½ ë³€ìˆ˜
numpy>=1.26             # ìˆ˜ì¹˜ ê³„ì‚° (ì§€í‘œ)
pandas>=2.1             # ë°ì´í„° ë¶„ì„
pydantic>=2.5           # ë°ì´í„° ê²€ì¦
structlog>=23.2         # êµ¬ì¡°í™” ë¡œê¹…
```

### 11.4 ê°€ìƒ ë§¤ë§¤ (Paper Trading) ì„¤ê³„

```python
class PaperTradingEngine:
    """
    ê°€ìƒ ë§¤ë§¤ ì—”ì§„
    - ì‹¤ì‹œê°„ í˜¸ê°€ ë°ì´í„° ê¸°ë°˜ ê°€ìƒ ì²´ê²°
    - DB ê°€ìƒ ê³„ì¢Œ ì—…ë°ì´íŠ¸
    - ì‹¤ì „ê³¼ ë™ì¼í•œ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì ìš©
    - ìŠ¬ë¦¬í”¼ì§€ ì‹œë®¬ë ˆì´ì…˜ (0.1~0.3%)
    """
    
    SIMULATED_SLIPPAGE_PCT = 0.1  # ê°€ìƒ ìŠ¬ë¦¬í”¼ì§€
    
    async def execute_virtual_order(self, order: dict) -> dict:
        """ê°€ìƒ ì£¼ë¬¸ ì²´ê²° ì²˜ë¦¬"""
        # ì‹¤ì‹œê°„ í˜¸ê°€ ì¡°íšŒ (REST API â€” ì‹œì„¸ë§Œ)
        asking_price = await self.rest_client.get_asking_price(order["stock_code"])
        
        if order["order_type"] == "BUY":
            # ë§¤ìˆ˜: ë§¤ë„í˜¸ê°€ 1ìˆœìœ„ + ìŠ¬ë¦¬í”¼ì§€
            fill_price = float(asking_price["askp1"]) * (1 + self.SIMULATED_SLIPPAGE_PCT / 100)
        else:
            # ë§¤ë„: ë§¤ìˆ˜í˜¸ê°€ 1ìˆœìœ„ - ìŠ¬ë¦¬í”¼ì§€
            fill_price = float(asking_price["bidp1"]) * (1 - self.SIMULATED_SLIPPAGE_PCT / 100)
        
        # ê°€ìƒ ê³„ì¢Œ DB ì—…ë°ì´íŠ¸
        await self._update_paper_account(order, fill_price)
        
        return {
            "success": True,
            "fill_price": fill_price,
            "simulated_slippage": self.SIMULATED_SLIPPAGE_PCT,
            "mode": "PAPER"
        }
```

---

## ë¶€ë¡ A: ì „ëµ ì½”ë“œ ë§¤í•‘

| ì½”ë“œ | ì „ëµëª… | ì¹´í…Œê³ ë¦¬ | ê·¼ê±° ë„ì„œ | ëŒ€ìƒ ë“±ê¸‰ | ê¸°ë³¸ ë¹„ì¤‘ |
|------|--------|---------|----------|----------|----------|
| S1 | SEPA ëª¨ë©˜í…€ ëŒíŒŒ | ìƒìŠ¹ì¥ | Minervini | B | 15~20% |
| S2 | Gap & Go ëˆŒë¦¼ëª© ë§¤ìˆ˜ | ìƒìŠ¹ì¥ | Cameron, Aziz | B~C | 10~15% |
| S3 | CAN SLIM ëŒíŒŒ ë§¤ë§¤ | ìƒìŠ¹ì¥ | O'Neil | A | 20~30% |
| S4 | Triple Screen ì¶”ì„¸ ì¶”ì¢… | ìƒìŠ¹ì¥ | Elder | A~B | 20~25% |
| S5 | VWAP ë°”ìš´ìŠ¤ | ìƒìŠ¹ì¥ | Carter, Aziz | A | 20~30% |
| B1 | ë°ë“œìº£ ë°”ìš´ìŠ¤ | í•˜ë½ì¥ | Staley, Turner | A | 10~15% |
| B2 | ì¸ë²„ìŠ¤ ETF | í•˜ë½ì¥ | Staley, Pring | ETF | 15~20% |
| B3 | ë°•ìŠ¤ê¶Œ ë ˆì¸ì§€ ë§¤ë§¤ | í•˜ë½ì¥ | Nison, Murphy | A~B | 10~15% |
| B4 | ê³¼ë§¤ë„ ì—­ë°œìƒ | í•˜ë½ì¥ | Steenbarger | A(ë°©ì–´ì£¼) | 10~15% |
| VB | ë³€ë™ì„± ëŒíŒŒ | ì¤‘ë¦½ | ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤ | A~B | ê°€ë³€ |
| GR | ê·¸ë¦¬ë“œ ë§¤ë§¤ | ì¤‘ë¦½ | (ë°•ìŠ¤ê¶Œ ì „ëµ) | A~B | ê·¸ë¦¬ë“œë‹¹ 5% |
| DS | ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ | ì¤‘ë¦½ | (ë°°ë‹¹ ìº˜ë¦°ë”) | A | ê°€ë³€ |

## ë¶€ë¡ B: ì½”ìŠ¤í”¼ ìµœì  ë§¤ë§¤ ì‹œê°„ëŒ€

| ì‹œê°„ëŒ€ | íŠ¹ì„± | ì í•© ì „ëµ | ì‹œìŠ¤í…œ ë™ì‘ |
|--------|------|----------|-----------|
| 09:00~09:15 | ê°­ í˜•ì„± + ìµœëŒ€ ë³€ë™ì„± ë…¸ì´ì¦ˆ | **ê´€ì°°ë§Œ (ë§¤ìˆ˜ ê¸ˆì§€)** | ë°ì´í„° ìˆ˜ì§‘ë§Œ, ì‹ í˜¸ ìƒì„± ì°¨ë‹¨ |
| 09:15~09:30 | ì´ˆë°˜ ìˆ˜ê¸‰ ë°©í–¥ í™•ì¸ | Gap & Go (ê²½í—˜ì í•œì •) | S2 ì „ëµë§Œ í™œì„±í™” |
| 09:30~10:30 | â­ **ìŠ¹ë¥  ìµœê³  êµ¬ê°„** | VWAP, SEPA, CAN SLIM | ì „ ì „ëµ í™œì„±í™” |
| 10:30~14:00 | ê±°ë˜ëŸ‰ ê°ì†Œ, íš¡ë³´ | ë°•ìŠ¤ê¶Œ ë§¤ë§¤, ê´€ë§ | GR, B3ë§Œ í™œì„±í™” |
| 14:00~15:20 | ë§ˆê° ì „ ê±°ë˜ëŸ‰ ì¦ê°€ | ì¢…ê°€ ë§¤ë§¤, ì¶”ì„¸ í™•ì¸ | ì²­ì‚° ìœ„ì£¼ |
| 15:20~15:30 | ì¢…ê°€ ë‹¨ì¼ê°€ | ìµì¼ ê°­ ìƒìŠ¹ ê¸°ëŒ€ ë§¤ìˆ˜ | DS ì „ëµ í™œì„±í™” |

## ë¶€ë¡ C: ìˆ˜ê¸‰ êµì°¨ ê²€ì¦ ë§¤íŠ¸ë¦­ìŠ¤

| ê¸°ìˆ ì  ì¡°ê±´ | ì™¸êµ­ì¸/ê¸°ê´€ ìˆ˜ê¸‰ | íŒë‹¨ | ë¹„ì¤‘ ì¡°ì • |
|------------|----------------|------|----------|
| âœ… ì¶©ì¡± | âœ… ìˆœë§¤ìˆ˜ ë™í–‰ | **ì ê·¹ ì§„ì…** | í™•ì‹ ë„ +1 â†’ ë“±ê¸‰ ìµœëŒ€ ë¹„ì¤‘ |
| âœ… ì¶©ì¡± | âš ï¸ ì¤‘ë¦½/í˜¼ì¡° | **ê¸°ë³¸ ì§„ì…** | í™•ì‹ ë„ ìœ ì§€ â†’ ê¸°ë³¸ ë¹„ì¤‘ |
| âœ… ì¶©ì¡± | âŒ ìˆœë§¤ë„ ì—­í–‰ | **ì†Œê·¹ ì§„ì… ë˜ëŠ” ê´€ë§** | í™•ì‹ ë„ -1 â†’ ë¹„ì¤‘ 50% ì¶•ì†Œ |
| âŒ ë¯¸ì¶©ì¡± | âœ… ìˆœë§¤ìˆ˜ | **ë§¤ë§¤ ê¸ˆì§€** | ìˆ˜ê¸‰ë§Œìœ¼ë¡œ ì§„ì…í•˜ì§€ ì•ŠìŒ |

---

> âš ï¸ **ë©´ì±… ì¡°í•­:** ë³¸ ì„¤ê³„ì„œëŠ” êµìœ¡/ì°¸ê³  ëª©ì ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, íˆ¬ì ì¡°ì–¸ì´ ì•„ë‹™ë‹ˆë‹¤. ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì˜ ëª¨ë“  íˆ¬ì íŒë‹¨ê³¼ ì†ì‹¤ì€ ìš´ìš©ì ë³¸ì¸ì—ê²Œ ìˆìœ¼ë©°, ë°˜ë“œì‹œ ì¶©ë¶„í•œ ë°±í…ŒìŠ¤íŠ¸ì™€ ëª¨ì˜íˆ¬ì(Paper Trading)ë¥¼ ê±°ì¹œ í›„ ì‹¤ì „ì— ì„í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì‹œìŠ¤í…œ ì˜¤ë¥˜, ë„¤íŠ¸ì›Œí¬ ì¥ì• , ì¦ê¶Œì‚¬ API ë³€ê²½ ë“±ìœ¼ë¡œ ì¸í•œ ì˜ˆê¸°ì¹˜ ì•Šì€ ì†ì‹¤ ê°€ëŠ¥ì„±ì„ í•­ìƒ ì¸ì§€í•˜ì‹­ì‹œì˜¤.
