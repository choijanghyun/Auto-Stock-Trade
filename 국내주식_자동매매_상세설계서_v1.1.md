# ğŸ“Š êµ­ë‚´ ì£¼ì‹ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ìƒì„¸ì„¤ê³„ì„œ (Detailed Design Document)

**í”„ë¡œì íŠ¸ëª…:** KIS Auto Trading System (KATS)
**ë²„ì „:** v1.1 (ì˜¤ë¥˜ ì§€ì ì‚¬í•­ 8ê±´ ë°˜ì˜)
**ì‘ì„±ì¼:** 2026-02-13
**ê¸°ìˆ  ìŠ¤íƒ:** Python 3.11+ / KIS Developers REST API & WebSocket / Redis / SQLite & PostgreSQL
**ì„¤ê³„ ê¸°ë°˜:** ì„¸ê³„ ë² ìŠ¤íŠ¸ì…€ëŸ¬ TOP 20 íŠ¸ë ˆì´ë”© ë„ì„œ ë¶„ì„ ê¸°ë°˜ ì „ëµ ì—”ì§„

---

## ëª©ì°¨

1. [ì‹œìŠ¤í…œ ê°œìš”](#1-ì‹œìŠ¤í…œ-ê°œìš”)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#2-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ](#3-ë°ì´í„°ë² ì´ìŠ¤-ìŠ¤í‚¤ë§ˆ)
4. [í•µì‹¬ ëª¨ë“ˆ ë° í´ë˜ìŠ¤ êµ¬ì¡°](#4-í•µì‹¬-ëª¨ë“ˆ-ë°-í´ë˜ìŠ¤-êµ¬ì¡°)
5. [KIS API íŠ¹í™” ì„¤ê³„](#5-kis-api-íŠ¹í™”-ì„¤ê³„)
6. [ì „ëµ ì—”ì§„ ìƒì„¸ ì„¤ê³„](#6-ì „ëµ-ì—”ì§„-ìƒì„¸-ì„¤ê³„)
7. [ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—”ì§„](#7-ë¦¬ìŠ¤í¬-ê´€ë¦¬-ì—”ì§„)
8. [ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ](#8-ëª¨ë‹ˆí„°ë§-ë°-ì•Œë¦¼-ì‹œìŠ¤í…œ)
9. [AI ìì—°ì–´ ì²˜ë¦¬ (MCP í†µí•©)](#9-ai-ìì—°ì–´-ì²˜ë¦¬-mcp-í†µí•©)
10. [ì˜ˆì™¸ ì²˜ë¦¬ ë° ì¥ì•  ëŒ€ì‘](#10-ì˜ˆì™¸-ì²˜ë¦¬-ë°-ì¥ì• -ëŒ€ì‘)
11. [ë°°í¬ ë° ìš´ì˜](#11-ë°°í¬-ë°-ìš´ì˜)

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 

í•œêµ­íˆ¬ìì¦ê¶Œ(KIS Developers) REST API ë° WebSocketì„ í™œìš©í•˜ì—¬, ì„¸ê³„ ë² ìŠ¤íŠ¸ì…€ëŸ¬ TOP 20 íŠ¸ë ˆì´ë”© ë„ì„œì—ì„œ ê²€ì¦ëœ ì „ëµ ì•Œê³ ë¦¬ì¦˜ì„ ìë™ ì‹¤í–‰í•˜ëŠ” êµ­ë‚´ ì£¼ì‹ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì„ ì„¤ê³„í•œë‹¤. ë³¸ ì‹œìŠ¤í…œì€ ë³€ë™ì„± ëŒíŒŒ ì „ëµ, ê·¸ë¦¬ë“œ ë§¤ë§¤, ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ë“± í•µì‹¬ ì „ëµ ì™¸ì—ë„ SEPA ëª¨ë©˜í…€ ëŒíŒŒ, CAN SLIM, Triple Screen, VWAP ë°”ìš´ìŠ¤ ë“± ê³ ê¸‰ ì „ëµì„ í¬í•¨í•˜ë©°, ì •êµí•œ ë¦¬ìŠ¤í¬ ê´€ë¦¬ì™€ ë§¤ë§¤ ë³µê¸° ì‹œìŠ¤í…œì„ í†µí•© ì œê³µí•œë‹¤.

### 1.2 í•µì‹¬ ì„¤ê³„ ì›ì¹™

| ì›ì¹™ | ì„¤ëª… | ê·¼ê±° |
|------|------|------|
| **ì¢…ëª© ì„ ì • ìš°ì„ ** | ì‹œê°€ì´ì•¡, ê±°ë˜ëŒ€ê¸ˆ, ê¸°ìˆ ì Â·ê¸°ë³¸ì  ì¡°ê±´ì„ ëª¨ë‘ ì¶©ì¡±í•˜ëŠ” ì¢…ëª©ë§Œ ë§¤ë§¤ | Minervini, O'Neil: "ì¢…ëª© ì„ ì •ì´ ìˆ˜ìµì˜ 80%ë¥¼ ê²°ì •" |
| **í¬ì§€ì…˜ ì‚¬ì´ì§• ì¤‘ì‹¬** | Rë°°ìˆ˜ ê¸°ë°˜ ë¦¬ìŠ¤í¬ í†µì œ, SQNìœ¼ë¡œ ì‹œìŠ¤í…œ í’ˆì§ˆ ì¸¡ì • | Van Tharp: "í¬ì§€ì…˜ ì‚¬ì´ì§•ì´ ì„±ê³¼ ë³€ë™ì„±ì˜ 91%ë¥¼ ê²°ì •" |
| **ê¸°ê³„ì  ì†ì ˆ** | ì§„ì… ì „ ì†ì ˆê°€ ê²°ì •, ì˜ˆì™¸ ì—†ëŠ” ìë™ ì‹¤í–‰ | Douglas, Minervini: "-1R ì´ˆê³¼ ì†ì‹¤ì€ ê·œì¹™ ìœ„ë°˜ ì‹ í˜¸" |
| **í˜„ê¸ˆì´ ìµœê³ ì˜ í¬ì§€ì…˜** | ìƒìŠ¹ì¥ 30%+, í•˜ë½ì¥ 70%+ í˜„ê¸ˆ ìœ ì§€ | Elder, Livermore |
| **ì¸¡ì •ê³¼ ê°œì„ ** | ë§¤ë§¤ ì¼ì§€ ìë™ ê¸°ë¡, ì£¼ê°„/ì›”ê°„ ì„±ê³¼ ë¦¬ë·° ìë™ ìƒì„± | Steenbarger: "ì¸¡ì •í•˜ì§€ ì•Šìœ¼ë©´ ê°œì„ í•  ìˆ˜ ì—†ë‹¤" |

### 1.3 ë§¤ë§¤ ëª¨ë“œ

| ëª¨ë“œ | ì„¤ëª… | API í˜¸ì¶œ |
|------|------|---------|
| **ì‹¤ì „ ë§¤ë§¤ (Live)** | ì‹¤ì œ ì£¼ë¬¸ ì²´ê²°, ì‹¤ê³„ì¢Œ ìì‚° ë³€ë™ | KIS REST API ì‹¤ì „ ë„ë©”ì¸ |
| **ê°€ìƒ ë§¤ë§¤ (Paper)** | ì‹¤ì‹œê°„ í˜¸ê°€ ê¸°ë°˜ ê°€ìƒ ì²´ê²°, DB ê°€ìƒ ê³„ì¢Œ ì—…ë°ì´íŠ¸ | ì‹œì„¸ APIë§Œ í˜¸ì¶œ, ì£¼ë¬¸ API ë¯¸í˜¸ì¶œ |

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ ì•„í‚¤í…ì²˜ ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        KATS (KIS Auto Trading System) v1.1              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Auth    â”‚  Market  â”‚ Strategy â”‚  Risk    â”‚  Order   â”‚  AI/NLP         â”‚
â”‚  Manager â”‚  Data    â”‚  Engine  â”‚  Manager â”‚  Manager â”‚  (MCP)          â”‚
â”‚          â”‚  Hub     â”‚          â”‚ +Global  â”‚ +State   â”‚ +Human-in-loop  â”‚
â”‚          â”‚ (Cache)  â”‚          â”‚  Lock    â”‚  Machine â”‚                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          â”‚ VI       â”‚          â”‚ Margin   â”‚  Order   â”‚                 â”‚
â”‚          â”‚ Monitor  â”‚          â”‚ Guard    â”‚  Tracker â”‚                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Core Infrastructure Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ KIS REST â”‚ â”‚ KIS WS   â”‚ â”‚ Redis    â”‚ â”‚ Database â”‚ â”‚ Notifier    â”‚ â”‚
â”‚  â”‚ (ì£¼ë¬¸/   â”‚ â”‚ (ì‹œì„¸    â”‚ â”‚ (ì‹¤ì‹œê°„  â”‚ â”‚ (SQLite/ â”‚ â”‚ (Slack/     â”‚ â”‚
â”‚  â”‚  ì”ê³ ë§Œ) â”‚ â”‚  ì „ìš©)   â”‚ â”‚  ìºì‹œ)   â”‚ â”‚  PgSQL)  â”‚ â”‚  Telegram)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ë°ì´í„° íë¦„ë„

```
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚     Market Data Hub (Cache)      â”‚
                              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
[KIS WebSocket] â”€â”€ì‹¤ì‹œê°„â”€â”€â–¶   â”‚  â”‚ Redis     â”‚ â”‚ VI Monitor  â”‚  â”‚
  ì²´ê²°ê°€/í˜¸ê°€/VIì •ë³´          â”‚  â”‚ í‹± ë²„í¼   â”‚ â”‚ ë°œë™ê°€ ê°ì‹œ â”‚  â”‚
                              â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
[KIS REST API] â”€â”€ë³´ì¡°ì¡°íšŒâ”€â”€â–¶  â”‚  â”‚ In-Memory Price Cache     â”‚  â”‚â”€â”€â–¶ [Strategy Engine]
  (ì£¼ë¬¸/ì”ê³ /ì¼ë´‰ë§Œ)          â”‚  â”‚ (ì¢…ëª©ë³„ í˜„ì¬ê°€/í˜¸ê°€/ì§€í‘œ) â”‚  â”‚         â”‚
                              â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    ì „ëµ ì‹ í˜¸
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
                                                                          â–¼
                                                                 [Risk Manager]
                                                                 â”‚ â‘  ê±°ë˜ë‹¹ ë¦¬ìŠ¤í¬
                                                                 â”‚ â‘¡ Global Stock Lock â† [NEW]
                                                                 â”‚ â‘¢ Margin Guard â† [NEW]
                                                                 â”‚ â‘£ VI ìƒíƒœ í™•ì¸ â† [NEW]
                                                                 â”‚  ê²€ì¦ í†µê³¼
                                                                 â–¼
                                                        [Order Manager]
                                                        â”‚ Order State Machine â† [NEW]
                                                        â”‚ Order Tracker â† [NEW]
                                                        â”œâ”€â”€ì£¼ë¬¸â”€â”€â–¶ [KIS REST API]
                                                        â”‚
                                                        â–¼
                                               [Redis ë²„í¼] â”€â”€ë°°ì¹˜â”€â”€â–¶ [Trade Journal DB]
                                                        â”‚
                                                        â–¼
                                               [Notification Service]
                                               (Human-in-the-loop ìŠ¹ì¸) â† [NEW]
```

> **[v1.1 ë³€ê²½] ì‹œì„¸ ë°ì´í„° íë¦„ ì›ì¹™:**
> - **WebSocket ìš°ì„ :** ëª¨ë“  ì‹¤ì‹œê°„ ì‹œì„¸(ì²´ê²°ê°€, í˜¸ê°€, VI ì •ë³´)ëŠ” WebSocketìœ¼ë¡œ ìˆ˜ì‹ í•˜ì—¬ In-Memory Cacheì— ì €ì¥
> - **REST ë³´ì¡°:** REST APIëŠ” ì£¼ë¬¸ ì‹¤í–‰, ì”ê³  ì¡°íšŒ, ì¼ë´‰/ë¶„ë´‰ íˆìŠ¤í† ë¦¬ ë“± ë¹„ì •ê¸° ì‘ì—…ì—ë§Œ ì‚¬ìš©
> - **ì „ëµ ì—”ì§„ì€ RESTë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ:** ë°˜ë“œì‹œ Market Data Hubì˜ ìºì‹œì—ì„œ ì½ê¸°ë§Œ ìˆ˜í–‰
> - **Redis ë²„í¼:** ì‹¤ì‹œê°„ í‹± ë°ì´í„°ëŠ” Redisì— ë²„í¼ë§ í›„ ì¥ ë§ˆê° í›„ DBì— Bulk Insert

### 2.3 ëª¨ë“ˆ ê³„ì¸µ êµ¬ì¡°

```
kats/
â”œâ”€â”€ main.py                         # ì—”íŠ¸ë¦¬í¬ì¸íŠ¸, ìŠ¤ì¼€ì¤„ëŸ¬
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.py                 # í™˜ê²½ ì„¤ì • (API í‚¤, DB ê²½ë¡œ, ì „ëµ íŒŒë¼ë¯¸í„°)
â”‚   â””â”€â”€ constants.py                # ìƒìˆ˜ ì •ì˜ (ë“±ê¸‰ ê¸°ì¤€, ì‹œê°„ëŒ€, ì´ë²¤íŠ¸ ìº˜ë¦°ë”)
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ token_manager.py            # í† í° ìë™ ë°œê¸‰/ê°±ì‹ /ìºì‹±
â”‚   â””â”€â”€ hashkey_manager.py          # í•´ì‹œí‚¤ ìƒì„± ë° ë³´ì•ˆ ì²˜ë¦¬
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ kis_rest_client.py          # REST API ë˜í¼ (ì£¼ë¬¸/ì”ê³  ì „ìš©, Throttling í¬í•¨)
â”‚   â”œâ”€â”€ kis_websocket_client.py     # WebSocket í´ë¼ì´ì–¸íŠ¸ (ì¬ì—°ê²° ì „ëµ)
â”‚   â””â”€â”€ rate_limiter.py             # API í˜¸ì¶œ ì œí•œ ê´€ë¦¬
â”œâ”€â”€ market/
â”‚   â”œâ”€â”€ data_hub.py                 # [v1.1] WebSocket ìºì‹œ ê¸°ë°˜ ì‹¤ì‹œê°„ ë°ì´í„° í—ˆë¸Œ
â”‚   â”œâ”€â”€ realtime_cache.py           # [v1.1 NEW] In-Memory ê°€ê²©/í˜¸ê°€ ìºì‹œ (ì „ëµ ì½ê¸° ì „ìš©)
â”‚   â”œâ”€â”€ vi_monitor.py               # [v1.1 NEW] ë³€ë™ì„± ì™„í™”ì¥ì¹˜(VI) ë°œë™ ê°ì§€ ë° ëŒ€ì‘
â”‚   â”œâ”€â”€ stock_screener.py           # ì¢…ëª© ìŠ¤ìºë‹ (Minervini Trend Template)
â”‚   â”œâ”€â”€ indicator_calculator.py     # ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° (MA, RSI, VWAP, BB ë“±)
â”‚   â””â”€â”€ sector_analyzer.py          # ì„¹í„° ê°•ì•½ ë¶„ì„
â”œâ”€â”€ strategy/
â”‚   â”œâ”€â”€ base_strategy.py            # ì „ëµ ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ volatility_breakout.py      # ë³€ë™ì„± ëŒíŒŒ ì „ëµ (ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤)
â”‚   â”œâ”€â”€ grid_trading.py             # ê·¸ë¦¬ë“œ ë§¤ë§¤ ì „ëµ
â”‚   â”œâ”€â”€ dividend_switching.py       # ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ì „ëµ
â”‚   â”œâ”€â”€ sepa_momentum.py            # SEPA ëª¨ë©˜í…€ ëŒíŒŒ (Minervini)
â”‚   â”œâ”€â”€ gap_and_go.py               # Gap & Go ëˆŒë¦¼ëª© ë§¤ìˆ˜ (Cameron/Aziz)
â”‚   â”œâ”€â”€ canslim_breakout.py         # CAN SLIM ëŒíŒŒ ë§¤ë§¤ (O'Neil)
â”‚   â”œâ”€â”€ triple_screen.py            # Triple Screen ì¶”ì„¸ ì¶”ì¢… (Elder)
â”‚   â”œâ”€â”€ vwap_bounce.py              # VWAP ë°”ìš´ìŠ¤ (Carter/Aziz)
â”‚   â”œâ”€â”€ dead_cat_bounce.py          # ë°ë“œìº£ ë°”ìš´ìŠ¤ - í•˜ë½ì¥ (Staley/Turner)
â”‚   â”œâ”€â”€ inverse_etf.py              # ì¸ë²„ìŠ¤ ETF ë§¤ë§¤ - í•˜ë½ì¥ (Staley/Pring)
â”‚   â”œâ”€â”€ range_trading.py            # ë°•ìŠ¤ê¶Œ ë ˆì¸ì§€ ë§¤ë§¤ - í•˜ë½ì¥ (Nison/Murphy)
â”‚   â”œâ”€â”€ oversold_reversal.py        # ê³¼ë§¤ë„ ì—­ë°œìƒ - í•˜ë½ì¥ (Steenbarger)
â”‚   â””â”€â”€ strategy_selector.py        # ì¥ì„¸ë³„ ì „ëµ ìë™ ì„ íƒê¸°
â”œâ”€â”€ risk/
â”‚   â”œâ”€â”€ risk_manager.py             # í†µí•© ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—”ì§„
â”‚   â”œâ”€â”€ position_sizer.py           # Van Tharp Rë°°ìˆ˜ ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•
â”‚   â”œâ”€â”€ trailing_stop.py            # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ (ê³ ì •%/MA/ATR/ìº”ë“¤)
â”‚   â”œâ”€â”€ daily_kill_switch.py        # ì¼ì¼ ì†ì‹¤ ì°¨ë‹¨ (Kill-Switch)
â”‚   â”œâ”€â”€ drawdown_protocol.py        # ë“œë¡œìš°ë‹¤ìš´ ë‹¨ê³„ë³„ ëŒ€ì‘ í”„ë¡œí† ì½œ
â”‚   â”œâ”€â”€ grade_allocator.py          # ì¢…ëª© ë“±ê¸‰ë³„ ë¹„ì¤‘ ë°°ë¶„ (A/B/C)
â”‚   â”œâ”€â”€ global_position_lock.py     # [v1.1 NEW] ì „ì—­ ì¢…ëª© ë¹„ì¤‘ ì ê¸ˆ (ì „ëµ ì¤‘ë³µ ë°©ì§€)
â”‚   â””â”€â”€ margin_guard.py             # [v1.1 NEW] ë¯¸ìˆ˜/ì‹ ìš© ì°¨ë‹¨ (í˜„ê¸ˆ 100% ê°•ì œ)
â”œâ”€â”€ order/
â”‚   â”œâ”€â”€ order_manager.py            # ì£¼ë¬¸ ìƒì„±/ì‹¤í–‰/ì·¨ì†Œ ê´€ë¦¬
â”‚   â”œâ”€â”€ order_state_machine.py      # [v1.1 NEW] ì£¼ë¬¸ ìƒíƒœ ì „ì´ ê´€ë¦¬
â”‚   â”œâ”€â”€ order_tracker.py            # [v1.1 NEW] ë¯¸ì²´ê²° ì£¼ë¬¸ ì¶”ì /ìë™ ì •ì •/ì·¨ì†Œ
â”‚   â”œâ”€â”€ paper_trading.py            # [v1.1] í˜¸ê°€ ì”ëŸ‰ ê¸°ë°˜ í˜„ì‹¤ì  ê°€ìƒ ë§¤ë§¤ ì—”ì§„
â”‚   â””â”€â”€ pyramid_manager.py          # í”¼ë¼ë¯¸ë”©(ë¶„í•  ì§„ì…) ê´€ë¦¬
â”œâ”€â”€ journal/
â”‚   â”œâ”€â”€ trade_journal.py            # ë§¤ë§¤ ì¼ì§€ ìë™ ê¸°ë¡
â”‚   â”œâ”€â”€ performance_analyzer.py     # Rë°°ìˆ˜, SQN, ìŠ¹ë¥  ë“± ì„±ê³¼ ë¶„ì„
â”‚   â””â”€â”€ review_generator.py         # ì¼ê°„/ì£¼ê°„/ì›”ê°„ ë¦¬ë·° ìë™ ìƒì„±
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ mcp_handler.py              # [v1.1] MCP ìì—°ì–´ ëª…ë ¹ (Human-in-the-loop í•„ìˆ˜)
â”‚   â””â”€â”€ nlp_parser.py               # ìì—°ì–´ â†’ ë§¤ë§¤ ëª…ë ¹ ë³€í™˜
â”œâ”€â”€ notification/
â”‚   â”œâ”€â”€ notifier.py                 # ì•Œë¦¼ í†µí•© ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ approval_gateway.py         # [v1.1 NEW] ëª…ë ¹ ìŠ¹ì¸ ê²Œì´íŠ¸ì›¨ì´ (Slack/Telegram)
â”‚   â””â”€â”€ channels/                   # Slack, Kakao, Telegram ë“±
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ models.py                   # ORM ëª¨ë¸ ì •ì˜
â”‚   â”œâ”€â”€ repository.py               # ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´
â”‚   â”œâ”€â”€ redis_buffer.py             # [v1.1 NEW] Redis ì‹¤ì‹œê°„ ë²„í¼ â†’ DB ë°°ì¹˜ ì“°ê¸°
â”‚   â””â”€â”€ migrations/                 # DB ë§ˆì´ê·¸ë ˆì´ì…˜
â””â”€â”€ utils/
    â”œâ”€â”€ event_calendar.py           # íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ìº˜ë¦°ë” (FOMC, ë§Œê¸°ì¼ ë“±)
    â”œâ”€â”€ market_regime.py            # ì¥ì„¸ íŒë‹¨ (ìƒìŠ¹/í•˜ë½/ë³´í•©)
    â””â”€â”€ logger.py                   # êµ¬ì¡°í™” ë¡œê¹…
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### 3.1 ERD ê°œìš”

```
[stocks] 1â”€â”€N [trades]
[stocks] 1â”€â”€N [watchlist]
[trades] 1â”€â”€1 [trade_journal]
[trades] Nâ”€â”€1 [strategies]
[daily_stats] â”€â”€â”€â”€ ì¼ë³„ ì§‘ê³„
[monthly_stats] â”€â”€ ì›”ë³„ ì§‘ê³„
[system_config] â”€â”€ ì„¤ì • ì •ë³´
[drawdown_log] â”€â”€ ë“œë¡œìš°ë‹¤ìš´ ì´ë ¥
[event_calendar] â”€ íŠ¹ìˆ˜ ì´ë²¤íŠ¸
```

### 3.2 í…Œì´ë¸” ì •ì˜

#### 3.2.1 stocks (ì¢…ëª© ë§ˆìŠ¤í„°)

```sql
CREATE TABLE stocks (
    stock_code      VARCHAR(10) PRIMARY KEY,          -- ì¢…ëª©ì½”ë“œ (ì˜ˆ: 005930)
    stock_name      VARCHAR(100) NOT NULL,             -- ì¢…ëª©ëª…
    market          VARCHAR(10) NOT NULL,              -- KOSPI / KOSDAQ
    sector          VARCHAR(50),                       -- ì—…ì¢…
    market_cap      BIGINT,                            -- ì‹œê°€ì´ì•¡ (ì›)
    grade           CHAR(1) CHECK (grade IN ('A','B','C','D')),  -- ë“±ê¸‰
    -- Minervini Trend Template ì§€í‘œ
    ma_50           DECIMAL(12,2),                     -- 50ì¼ ì´ë™í‰ê· 
    ma_150          DECIMAL(12,2),                     -- 150ì¼ ì´ë™í‰ê· 
    ma_200          DECIMAL(12,2),                     -- 200ì¼ ì´ë™í‰ê· 
    week52_high     DECIMAL(12,2),                     -- 52ì£¼ ìµœê³ ê°€
    week52_low      DECIMAL(12,2),                     -- 52ì£¼ ìµœì €ê°€
    rs_rank         DECIMAL(5,2),                      -- ìƒëŒ€ê°•ë„ (ì½”ìŠ¤í”¼ ëŒ€ë¹„, ë°±ë¶„ìœ„)
    avg_volume_20d  BIGINT,                            -- 20ì¼ í‰ê·  ê±°ë˜ëŸ‰
    avg_turnover_20d BIGINT,                           -- 20ì¼ í‰ê·  ê±°ë˜ëŒ€ê¸ˆ
    -- CAN SLIM ê¸°ë³¸ì  ì§€í‘œ
    eps_growth_qoq  DECIMAL(8,2),                      -- EPS ì„±ì¥ë¥  (ì „ë…„ ë™ê¸° ëŒ€ë¹„)
    revenue_growth  DECIMAL(8,2),                      -- ë§¤ì¶œ ì„±ì¥ë¥ 
    op_margin_trend VARCHAR(10),                       -- ì˜ì—…ì´ìµë¥  ì¶”ì„¸ (UP/DOWN/FLAT)
    inst_foreign_flow VARCHAR(10),                     -- ê¸°ê´€/ì™¸êµ­ì¸ ìˆ˜ê¸‰ (BUY/SELL/NEUTRAL)
    -- ë©”íƒ€
    trend_template_score INT DEFAULT 0,                -- Trend Template ì¶©ì¡± í•­ëª© ìˆ˜ (0~8)
    canslim_score   INT DEFAULT 0,                     -- CAN SLIM ì¶©ì¡± í•­ëª© ìˆ˜ (0~7)
    confidence_star INT DEFAULT 0 CHECK (confidence_star BETWEEN 0 AND 5), -- í™•ì‹ ë„ (ë³„ì )
    is_active       BOOLEAN DEFAULT TRUE,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.2 trades (ë§¤ë§¤ ë‚´ì—­)

```sql
CREATE TABLE trades (
    trade_id        SERIAL PRIMARY KEY,
    stock_code      VARCHAR(10) REFERENCES stocks(stock_code),
    trade_mode      VARCHAR(10) NOT NULL CHECK (trade_mode IN ('LIVE','PAPER')),
    -- ì£¼ë¬¸ ì •ë³´
    order_type      VARCHAR(10) NOT NULL,              -- BUY / SELL
    strategy_id     INT REFERENCES strategies(strategy_id),
    entry_price     DECIMAL(12,2),                     -- ì§„ì…ê°€
    exit_price      DECIMAL(12,2),                     -- ì²­ì‚°ê°€
    quantity        INT NOT NULL,                      -- ìˆ˜ëŸ‰
    amount          DECIMAL(15,2),                     -- íˆ¬ì… ê¸ˆì•¡
    -- ì†ìµ ì •ë³´
    pnl_amount      DECIMAL(15,2),                     -- ì†ìµ ê¸ˆì•¡
    pnl_percent     DECIMAL(8,4),                      -- ì†ìµë¥  (%)
    r_multiple      DECIMAL(8,4),                      -- Rë°°ìˆ˜ (Van Tharp)
    -- ë¦¬ìŠ¤í¬ ì •ë³´
    stop_loss_price DECIMAL(12,2),                     -- ì†ì ˆê°€
    risk_amount     DECIMAL(15,2),                     -- 1R ë¦¬ìŠ¤í¬ ê¸ˆì•¡
    position_pct    DECIMAL(5,2),                      -- ì´ ìë³¸ ëŒ€ë¹„ í¬ì§€ì…˜ ë¹„ì¤‘ (%)
    -- í”¼ë¼ë¯¸ë”© ì •ë³´
    pyramid_stage   INT DEFAULT 1,                     -- í”¼ë¼ë¯¸ë”© ë‹¨ê³„ (1ì°¨/2ì°¨/3ì°¨)
    parent_trade_id INT REFERENCES trades(trade_id),   -- ì› í¬ì§€ì…˜ trade_id
    -- ì‹¤í–‰ í’ˆì§ˆ
    slippage        DECIMAL(8,4),                      -- ìŠ¬ë¦¬í”¼ì§€ (%)
    fill_time_ms    INT,                               -- ì²´ê²° ì†Œìš” ì‹œê°„ (ms)
    -- ì‹œì¥ ì§€í‘œ ìŠ¤ëƒ…ìƒ· (ë§¤ë§¤ ë³µê¸°ìš©)
    snapshot_json   JSONB,                             -- ì§„ì… ì‹œì  ì°¨íŠ¸ ì§€í‘œ ìŠ¤ëƒ…ìƒ·
    -- íƒ€ì„ìŠ¤íƒ¬í”„
    entry_time      TIMESTAMP,
    exit_time       TIMESTAMP,
    holding_period  INTERVAL,                          -- ë³´ìœ  ê¸°ê°„
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.3 trade_journal (ë§¤ë§¤ ì¼ì§€ â€” Steenbarger ì…€í”„ ì½”ì¹­)

```sql
CREATE TABLE trade_journal (
    journal_id      SERIAL PRIMARY KEY,
    trade_id        INT UNIQUE REFERENCES trades(trade_id),
    -- ê±°ë˜ ê¸°ë¡
    stock_grade     CHAR(1),                           -- ì¢…ëª© ë“±ê¸‰ (A/B/C)
    entry_strategy  VARCHAR(50),                       -- ì§„ì… ì „ëµëª…
    checklist_score VARCHAR(20),                       -- ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶©ì¡±ë„ (ì˜ˆ: "12/13")
    -- ì‹¬ë¦¬ ê¸°ë¡ (Steenbarger)
    emotion_entry   VARCHAR(20),                       -- ì§„ì… ì‹œ ê°ì • (ì°¨ë¶„/ë¶ˆì•ˆ/í¥ë¶„/ë³µìˆ˜ì‹¬)
    emotion_during  TEXT,                              -- ë§¤ë§¤ ì¤‘ ê°ì • ë³€í™” ê¸°ë¡
    rule_compliance BOOLEAN DEFAULT TRUE,              -- ê·œì¹™ ì¤€ìˆ˜ ì—¬ë¶€
    rule_violation  TEXT,                              -- ìœ„ë°˜ ë‚´ìš© (ìˆì„ ê²½ìš°)
    lesson_learned  TEXT,                              -- ë°°ìš´ ì  (ê°•ì  ê°•í™”)
    improvement     TEXT,                              -- ê°œì„ í•  ì  (ì•½ì  ìˆ˜ì •)
    -- ìë™ ìƒì„± í•„ë“œ
    market_regime   VARCHAR(20),                       -- ë§¤ë§¤ ì‹œì  ì¥ì„¸ (ìƒìŠ¹/í•˜ë½/ë³´í•©)
    sector_flow     VARCHAR(20),                       -- ì„¹í„° ìˆ˜ê¸‰ ë°©í–¥
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.4 strategies (ì „ëµ ë§ˆìŠ¤í„°)

```sql
CREATE TABLE strategies (
    strategy_id     SERIAL PRIMARY KEY,
    strategy_code   VARCHAR(10) NOT NULL UNIQUE,       -- S1~S5, B1~B4, VB, GR, DS
    strategy_name   VARCHAR(100) NOT NULL,             -- ì „ëµëª…
    category        VARCHAR(20) NOT NULL,              -- BULL / BEAR / NEUTRAL
    description     TEXT,
    -- ì „ëµ íŒŒë¼ë¯¸í„° (JSON)
    default_params  JSONB,                             -- ê¸°ë³¸ ë§¤ê°œë³€ìˆ˜
    -- ì„±ê³¼ í†µê³„ (ìë™ ëˆ„ì )
    total_trades    INT DEFAULT 0,
    win_count       INT DEFAULT 0,
    loss_count      INT DEFAULT 0,
    avg_r_multiple  DECIMAL(8,4) DEFAULT 0,
    sqn_score       DECIMAL(8,4) DEFAULT 0,            -- System Quality Number
    is_active       BOOLEAN DEFAULT TRUE,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.5 daily_stats (ì¼ë³„ í†µê³„)

```sql
CREATE TABLE daily_stats (
    stat_date       DATE PRIMARY KEY,
    -- ë§¤ë§¤ í†µê³„
    total_trades    INT DEFAULT 0,                     -- ë‹¹ì¼ ë§¤ë§¤ íšŸìˆ˜
    buy_count       INT DEFAULT 0,
    sell_count      INT DEFAULT 0,
    win_count       INT DEFAULT 0,
    loss_count      INT DEFAULT 0,
    -- ê¸ˆì•¡ í†µê³„
    total_buy_amount  DECIMAL(15,2) DEFAULT 0,         -- ë§¤ìˆ˜ ì´ì•¡
    total_sell_amount DECIMAL(15,2) DEFAULT 0,         -- ë§¤ë„ ì´ì•¡
    daily_pnl       DECIMAL(15,2) DEFAULT 0,           -- ë‹¹ì¼ ì†ìµ
    daily_pnl_pct   DECIMAL(8,4) DEFAULT 0,            -- ë‹¹ì¼ ìˆ˜ìµë¥  (%)
    -- ëˆ„ì  í†µê³„
    cumulative_pnl  DECIMAL(15,2) DEFAULT 0,           -- ëˆ„ì  ì†ìµ
    total_capital   DECIMAL(15,2),                     -- ì´ ìë³¸
    cash_balance    DECIMAL(15,2),                     -- í˜„ê¸ˆ ì”ê³ 
    cash_ratio      DECIMAL(5,2),                      -- í˜„ê¸ˆ ë¹„ì¤‘ (%)
    -- Rë°°ìˆ˜ í†µê³„
    avg_r_multiple  DECIMAL(8,4),                      -- ë‹¹ì¼ í‰ê·  Rë°°ìˆ˜
    max_r_multiple  DECIMAL(8,4),                      -- ìµœëŒ€ Rë°°ìˆ˜
    min_r_multiple  DECIMAL(8,4),                      -- ìµœì†Œ Rë°°ìˆ˜
    -- ë¦¬ìŠ¤í¬ ì§€í‘œ
    drawdown_pct    DECIMAL(8,4),                      -- ë‹¹ì¼ ë“œë¡œìš°ë‹¤ìš´ (%)
    max_drawdown    DECIMAL(8,4),                      -- ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´ (%)
    -- ì¥ì„¸ ì •ë³´
    market_regime   VARCHAR(20),                       -- ì¥ì„¸ íŒë‹¨
    kospi_close     DECIMAL(10,2),                     -- ì½”ìŠ¤í”¼ ì¢…ê°€
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.6 monthly_stats (ì›”ë³„ í†µê³„)

```sql
CREATE TABLE monthly_stats (
    stat_month      VARCHAR(7) PRIMARY KEY,            -- YYYY-MM
    total_trades    INT DEFAULT 0,
    win_rate        DECIMAL(5,2),                      -- ìŠ¹ë¥  (%)
    monthly_pnl     DECIMAL(15,2),                     -- ì›”ê°„ ì†ìµ
    monthly_pnl_pct DECIMAL(8,4),                      -- ì›”ê°„ ìˆ˜ìµë¥  (%)
    avg_r_multiple  DECIMAL(8,4),
    sqn_score       DECIMAL(8,4),                      -- SQN ì ìˆ˜
    max_drawdown    DECIMAL(8,4),                      -- ì›”ê°„ ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´
    rule_compliance_rate DECIMAL(5,2),                 -- ê·œì¹™ ì¤€ìˆ˜ìœ¨ (%)
    -- ì „ëµë³„ ìˆ˜ìµ ê¸°ì—¬ë„
    strategy_pnl_json JSONB,                           -- {ì „ëµì½”ë“œ: ìˆ˜ìµê¸ˆ}
    -- ë“±ê¸‰ë³„ ìˆ˜ìµ ê¸°ì—¬ë„
    grade_pnl_json  JSONB,                             -- {A: ê¸ˆì•¡, B: ê¸ˆì•¡, C: ê¸ˆì•¡}
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.7 drawdown_log (ë“œë¡œìš°ë‹¤ìš´ ì´ë ¥)

```sql
CREATE TABLE drawdown_log (
    log_id          SERIAL PRIMARY KEY,
    level           VARCHAR(10) NOT NULL,              -- GREEN / YELLOW / ORANGE / RED / BLACK
    drawdown_pct    DECIMAL(8,4) NOT NULL,             -- ë“œë¡œìš°ë‹¤ìš´ ë¹„ìœ¨
    action_taken    TEXT,                               -- ì·¨í•œ ì¡°ì¹˜
    resumed_at      TIMESTAMP,                         -- ë§¤ë§¤ ì¬ê°œ ì‹œì 
    recovery_trades INT,                               -- ë³µê·€ê¹Œì§€ ë§¤ë§¤ íšŸìˆ˜
    triggered_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2.8 system_config (ì‹œìŠ¤í…œ ì„¤ì •)

```sql
CREATE TABLE system_config (
    config_key      VARCHAR(100) PRIMARY KEY,
    config_value    TEXT NOT NULL,
    config_type     VARCHAR(20) DEFAULT 'STRING',      -- STRING / INT / FLOAT / JSON / BOOL
    description     TEXT,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì´ˆê¸° ì„¤ì •ê°’
INSERT INTO system_config VALUES
('trade_mode', 'PAPER', 'STRING', 'ë§¤ë§¤ ëª¨ë“œ: LIVE / PAPER'),
('total_capital', '100000000', 'INT', 'ì´ ìë³¸ê¸ˆ (ì›)'),
('risk_per_trade_pct', '2.0', 'FLOAT', 'ê±°ë˜ë‹¹ ë¦¬ìŠ¤í¬ ë¹„ìœ¨ (Elder 2% Rule)'),
('monthly_loss_limit_pct', '6.0', 'FLOAT', 'ì›”ê°„ ìµœëŒ€ ì†ì‹¤ í•œë„ (Elder 6% Rule)'),
('daily_loss_limit_pct', '3.0', 'FLOAT', 'ì¼ì¼ ìµœëŒ€ ì†ì‹¤ í•œë„ (Cameron)'),
('max_positions', '5', 'INT', 'ìµœëŒ€ ë™ì‹œ ë³´ìœ  ì¢…ëª© ìˆ˜'),
('grade_a_max_pct', '30', 'FLOAT', 'Aë“±ê¸‰ ë‹¨ì¼ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘'),
('grade_b_max_pct', '20', 'FLOAT', 'Bë“±ê¸‰ ë‹¨ì¼ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘'),
('grade_c_max_pct', '10', 'FLOAT', 'Cë“±ê¸‰ ë‹¨ì¼ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘'),
('sector_max_pct', '40', 'FLOAT', 'ë™ì¼ ì„¹í„° ìµœëŒ€ ë¹„ì¤‘'),
('trailing_stop_default_pct', '5.0', 'FLOAT', 'ê¸°ë³¸ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë¹„ìœ¨');
```

#### 3.2.9 event_calendar (íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ìº˜ë¦°ë”)

```sql
CREATE TABLE event_calendar (
    event_id        SERIAL PRIMARY KEY,
    event_date      DATE NOT NULL,
    event_type      VARCHAR(30) NOT NULL,              -- OPTION_EXPIRY / FOMC / EARNINGS / BOK / MSCI / SHORT_SELL
    event_name      VARCHAR(200),
    market_impact   TEXT,                               -- ì‹œì¥ ì˜í–¥ ì„¤ëª…
    trading_action  TEXT,                               -- ë‹¨íƒ€ ëŒ€ì‘ ì „ëµ
    cash_adjust_pct DECIMAL(5,2) DEFAULT 0,            -- í˜„ê¸ˆ ë¹„ì¤‘ ì¶”ê°€ í™•ë³´ (%)
    is_active       BOOLEAN DEFAULT TRUE
);
```

#### 3.2.10 paper_account (ê°€ìƒ ë§¤ë§¤ ê³„ì¢Œ)

```sql
CREATE TABLE paper_account (
    account_id      SERIAL PRIMARY KEY,
    stock_code      VARCHAR(10),
    quantity        INT DEFAULT 0,
    avg_price       DECIMAL(12,2),
    current_price   DECIMAL(12,2),
    unrealized_pnl  DECIMAL(15,2),
    total_cash      DECIMAL(15,2),
    total_equity    DECIMAL(15,2),
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 4. í•µì‹¬ ëª¨ë“ˆ ë° í´ë˜ìŠ¤ êµ¬ì¡°

### 4.1 ì¸ì¦ ê´€ë¦¬ (Auth Manager)

#### TokenManager í´ë˜ìŠ¤

```python
class TokenManager:
    """
    KIS API ì ‘ê·¼ í† í° ìë™ ë°œê¸‰/ê°±ì‹  ê´€ë¦¬
    - í† í° ìœ íš¨ê¸°ê°„: 24ì‹œê°„
    - ë§Œë£Œ 1ì‹œê°„ ì „ ìë™ ê°±ì‹ 
    - í† í° íŒŒì¼ ìºì‹±ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ì¬ë°œê¸‰ ë°©ì§€
    """
    
    def __init__(self, app_key: str, app_secret: str, base_url: str):
        self.app_key = app_key
        self.app_secret = app_secret
        self.base_url = base_url
        self.token: Optional[str] = None
        self.token_expired_at: Optional[datetime] = None
        self.token_file = "token_cache.json"
    
    async def get_token(self) -> str:
        """ìœ íš¨í•œ í† í° ë°˜í™˜. ë§Œë£Œ ì‹œ ìë™ ê°±ì‹ ."""
        if self._is_token_valid():
            return self.token
        
        # ìºì‹œ íŒŒì¼ì—ì„œ í† í° ë¡œë“œ ì‹œë„
        cached = self._load_cached_token()
        if cached and self._is_token_valid():
            return self.token
        
        # ì‹ ê·œ ë°œê¸‰
        return await self._issue_new_token()
    
    async def _issue_new_token(self) -> str:
        """POST /oauth2/tokenP â€” ì ‘ê·¼ í† í° ë°œê¸‰"""
        payload = {
            "grant_type": "client_credentials",
            "appkey": self.app_key,
            "appsecret": self.app_secret
        }
        response = await self._post("/oauth2/tokenP", payload)
        self.token = response["access_token"]
        self.token_expired_at = datetime.fromisoformat(
            response["access_token_token_expired"]
        )
        self._save_token_cache()
        logger.info(f"í† í° ë°œê¸‰ ì™„ë£Œ. ë§Œë£Œ: {self.token_expired_at}")
        return self.token
    
    def _is_token_valid(self) -> bool:
        """ë§Œë£Œ 1ì‹œê°„ ì „ê¹Œì§€ ìœ íš¨ë¡œ íŒë‹¨"""
        if not self.token or not self.token_expired_at:
            return False
        return datetime.now() < (self.token_expired_at - timedelta(hours=1))
    
    def schedule_refresh(self):
        """ë§Œë£Œ 1ì‹œê°„ ì „ ìë™ ê°±ì‹  ìŠ¤ì¼€ì¤„ë§"""
        if self.token_expired_at:
            refresh_time = self.token_expired_at - timedelta(hours=1)
            scheduler.add_job(self._issue_new_token, 'date', run_date=refresh_time)
```

#### HashkeyManager í´ë˜ìŠ¤

```python
class HashkeyManager:
    """
    ìš”ì²­ ë°ì´í„° ìœ„ë³€ì¡° ë°©ì§€ë¥¼ ìœ„í•œ í•´ì‹œí‚¤ ìƒì„±
    - POST ìš”ì²­ì˜ bodyë¥¼ í•´ì‹±í•˜ì—¬ tr_idë³„ í•´ì‹œí‚¤ ë°œê¸‰
    """
    
    async def get_hashkey(self, body: dict) -> str:
        """POST /uapi/hashkey â€” í•´ì‹œí‚¤ ë°œê¸‰"""
        response = await self.rest_client.post(
            "/uapi/hashkey",
            json=body,
            headers={"appkey": self.app_key, "appsecret": self.app_secret}
        )
        return response["HASH"]
```

### 4.2 API í†µì‹ ë¶€

#### KISRestClient í´ë˜ìŠ¤

```python
class KISRestClient:
    """
    KIS REST API í†µì‹  ë˜í¼
    - Throttling ë°©ì§€: ì´ˆë‹¹ ìµœëŒ€ 20íšŒ í˜¸ì¶œ ì œí•œ
    - ìë™ ì¬ì‹œë„: ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ Exponential Backoff
    - í•´ì‹œí‚¤ ìë™ ì ìš©
    """
    
    BASE_URL_LIVE = "https://openapi.koreainvestment.com:9443"
    BASE_URL_PAPER = "https://openapivts.koreainvestment.com:29443"
    
    def __init__(self, token_manager: TokenManager, 
                 hashkey_manager: HashkeyManager,
                 rate_limiter: RateLimiter,
                 mode: str = "PAPER"):
        self.token_manager = token_manager
        self.hashkey_manager = hashkey_manager
        self.rate_limiter = rate_limiter
        self.base_url = self.BASE_URL_LIVE if mode == "LIVE" else self.BASE_URL_PAPER
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def request(self, method: str, path: str, 
                      tr_id: str, body: dict = None,
                      params: dict = None) -> dict:
        """API ìš”ì²­ ì‹¤í–‰ (Throttling + ì¬ì‹œë„ í¬í•¨)"""
        
        # 1. Rate Limit ëŒ€ê¸°
        await self.rate_limiter.acquire()
        
        # 2. í—¤ë” êµ¬ì„±
        token = await self.token_manager.get_token()
        headers = {
            "authorization": f"Bearer {token}",
            "appkey": self.token_manager.app_key,
            "appsecret": self.token_manager.app_secret,
            "tr_id": tr_id,
            "content-type": "application/json; charset=utf-8",
            "custtype": "P"  # ê°œì¸
        }
        
        # 3. POST ìš”ì²­ ì‹œ í•´ì‹œí‚¤ ì¶”ê°€
        if method == "POST" and body:
            headers["hashkey"] = await self.hashkey_manager.get_hashkey(body)
        
        # 4. ì¬ì‹œë„ ë¡œì§ (Exponential Backoff)
        for attempt in range(3):
            try:
                async with self.session.request(
                    method, f"{self.base_url}{path}",
                    headers=headers, json=body, params=params
                ) as resp:
                    data = await resp.json()
                    
                    if data.get("rt_cd") != "0":
                        raise KISAPIError(data.get("msg_cd"), data.get("msg1"))
                    
                    return data
                    
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                if attempt == 2:
                    raise
                wait = 2 ** attempt
                logger.warning(f"API ìš”ì²­ ì‹¤íŒ¨ ({attempt+1}/3), {wait}ì´ˆ í›„ ì¬ì‹œë„: {e}")
                await asyncio.sleep(wait)
    
    # === ì£¼ìš” API ë©”ì„œë“œ ===
    
    async def get_current_price(self, stock_code: str) -> dict:
        """ì£¼ì‹ í˜„ì¬ê°€ ì¡°íšŒ [v1/trading/inquire-price]"""
        return await self.request("GET", 
            "/uapi/domestic-stock/v1/quotations/inquire-price",
            tr_id="FHKST01010100",
            params={"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": stock_code})
    
    async def get_asking_price(self, stock_code: str) -> dict:
        """ì£¼ì‹ í˜¸ê°€ ì¡°íšŒ"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/quotations/inquire-asking-price-exp-ccn",
            tr_id="FHKST01010200",
            params={"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": stock_code})
    
    async def get_daily_price(self, stock_code: str, 
                               period: str = "D", count: int = 100) -> dict:
        """ì£¼ì‹ ê¸°ê°„ë³„ ì‹œì„¸ (ì¼/ì£¼/ì›”ë´‰)"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/quotations/inquire-daily-price",
            tr_id="FHKST01010400",
            params={
                "FID_COND_MRKT_DIV_CODE": "J",
                "FID_INPUT_ISCD": stock_code,
                "FID_PERIOD_DIV_CODE": period,
                "FID_ORG_ADJ_PRC": "0"
            })
    
    async def place_order(self, stock_code: str, order_type: str,
                           quantity: int, price: int = 0) -> dict:
        """ì£¼ì‹ ë§¤ìˆ˜/ë§¤ë„ ì£¼ë¬¸"""
        tr_id = "TTTC0802U" if order_type == "BUY" else "TTTC0801U"
        # ê°€ìƒ ë§¤ë§¤ ëª¨ë“œ: VTTC0802U / VTTC0801U
        if self.base_url == self.BASE_URL_PAPER:
            tr_id = "VTTC0802U" if order_type == "BUY" else "VTTC0801U"
        
        body = {
            "CANO": self.account_no,
            "ACNT_PRDT_CD": self.account_product_code,
            "PDNO": stock_code,
            "ORD_DVSN": "00" if price > 0 else "01",  # 00: ì§€ì •ê°€, 01: ì‹œì¥ê°€
            "ORD_QTY": str(quantity),
            "ORD_UNPR": str(price)
        }
        return await self.request("POST",
            "/uapi/domestic-stock/v1/trading/order-cash",
            tr_id=tr_id, body=body)
    
    async def get_balance(self) -> dict:
        """ì£¼ì‹ ì”ê³  ì¡°íšŒ"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/trading/inquire-balance",
            tr_id="TTTC8434R",
            params={
                "CANO": self.account_no,
                "ACNT_PRDT_CD": self.account_product_code,
                "AFHR_FLPR_YN": "N",
                "OFL_YN": "",
                "INQR_DVSN": "02",
                "UNPR_DVSN": "01",
                "FUND_STTL_ICLD_YN": "N",
                "FNCG_AMT_AUTO_RDPT_YN": "N",
                "PRCS_DVSN": "01",
                "CTX_AREA_FK100": "",
                "CTX_AREA_NK100": ""
            })
    
    async def get_volume_rank(self) -> dict:
        """ê±°ë˜ëŸ‰ ìˆœìœ„ ì¡°íšŒ"""
        return await self.request("GET",
            "/uapi/domestic-stock/v1/quotations/volume-rank",
            tr_id="FHPST01710000",
            params={
                "FID_COND_MRKT_DIV_CODE": "J",
                "FID_COND_SCR_DIV_CODE": "20171",
                "FID_INPUT_ISCD": "0000",
                "FID_DIV_CLS_CODE": "0",
                "FID_BLNG_CLS_CODE": "0",
                "FID_TRGT_CLS_CODE": "111111111",
                "FID_TRGT_EXLS_CLS_CODE": "000000",
                "FID_INPUT_PRICE_1": "",
                "FID_INPUT_PRICE_2": "",
                "FID_VOL_CNT": "",
                "FID_INPUT_DATE_1": ""
            })
```

#### KISWebSocketClient í´ë˜ìŠ¤

```python
class KISWebSocketClient:
    """
    KIS WebSocket ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹ 
    - ì²´ê²° í†µë³´, í˜¸ê°€ ë³€í™” ì‹¤ì‹œê°„ ìˆ˜ì‹ 
    - ìë™ ì¬ì—°ê²° (Exponential Backoff + ìµœëŒ€ 30íšŒ)
    - Heartbeat ê¸°ë°˜ ì—°ê²° ìƒíƒœ ê°ì‹œ
    """
    
    WS_URL = "ws://ops.koreainvestment.com:21000"
    WS_URL_LIVE = "ws://ops.koreainvestment.com:21000"
    
    def __init__(self, approval_key: str):
        self.approval_key = approval_key
        self.ws: Optional[websockets.WebSocketClientProtocol] = None
        self.subscriptions: Dict[str, Set[str]] = {}  # {tr_id: {stock_codes}}
        self.reconnect_count = 0
        self.max_reconnects = 30
        self.callbacks: Dict[str, Callable] = {}
        self._running = False
    
    async def connect(self):
        """WebSocket ì—°ê²° ìˆ˜ë¦½"""
        self._running = True
        while self._running and self.reconnect_count < self.max_reconnects:
            try:
                async with websockets.connect(
                    self.WS_URL,
                    ping_interval=30,
                    ping_timeout=10,
                    close_timeout=5
                ) as ws:
                    self.ws = ws
                    self.reconnect_count = 0
                    logger.info("WebSocket ì—°ê²° ì„±ê³µ")
                    
                    # ê¸°ì¡´ êµ¬ë… ë³µì›
                    await self._restore_subscriptions()
                    
                    # ë©”ì‹œì§€ ìˆ˜ì‹  ë£¨í”„
                    async for message in ws:
                        await self._handle_message(message)
                        
            except (websockets.ConnectionClosed, ConnectionError) as e:
                self.reconnect_count += 1
                wait = min(2 ** self.reconnect_count, 60)  # ìµœëŒ€ 60ì´ˆ
                logger.warning(
                    f"WebSocket ì—°ê²° ëŠê¹€ ({self.reconnect_count}/{self.max_reconnects}), "
                    f"{wait}ì´ˆ í›„ ì¬ì—°ê²°: {e}"
                )
                await asyncio.sleep(wait)
        
        if self.reconnect_count >= self.max_reconnects:
            logger.critical("WebSocket ìµœëŒ€ ì¬ì—°ê²° íšŸìˆ˜ ì´ˆê³¼. ì‹œìŠ¤í…œ ì ê²€ í•„ìš”.")
            await self._notify_critical_error("WebSocket ì—°ê²° ë¶ˆê°€")
    
    async def subscribe_execution(self, stock_code: str):
        """ì²´ê²° í†µë³´ êµ¬ë… (tr_id: H0STCNT0)"""
        await self._subscribe("H0STCNT0", stock_code)
    
    async def subscribe_orderbook(self, stock_code: str):
        """í˜¸ê°€ ë³€í™” êµ¬ë… (tr_id: H0STASP0)"""
        await self._subscribe("H0STASP0", stock_code)
    
    async def _subscribe(self, tr_id: str, stock_code: str):
        """êµ¬ë… ë©”ì‹œì§€ ì „ì†¡"""
        msg = {
            "header": {
                "approval_key": self.approval_key,
                "custtype": "P",
                "tr_type": "1",  # 1: ë“±ë¡
                "content-type": "utf-8"
            },
            "body": {
                "input": {
                    "tr_id": tr_id,
                    "tr_key": stock_code
                }
            }
        }
        await self.ws.send(json.dumps(msg))
        self.subscriptions.setdefault(tr_id, set()).add(stock_code)
    
    async def _handle_message(self, raw: str):
        """ìˆ˜ì‹  ë©”ì‹œì§€ íŒŒì‹± ë° ì½œë°± ì‹¤í–‰"""
        if raw[0] in ('0', '1'):  # ì‹¤ì‹œê°„ ë°ì´í„°
            parts = raw.split('|')
            tr_id = parts[1]
            data = parts[3]
            
            if tr_id in self.callbacks:
                parsed = self._parse_realtime_data(tr_id, data)
                await self.callbacks[tr_id](parsed)
        else:
            # JSON ì‘ë‹µ (êµ¬ë… ê²°ê³¼ ë“±)
            data = json.loads(raw)
            if data.get("header", {}).get("tr_id") == "PINGPONG":
                await self.ws.send(raw)  # Heartbeat ì‘ë‹µ
    
    async def _restore_subscriptions(self):
        """ì¬ì—°ê²° í›„ ê¸°ì¡´ êµ¬ë… ë³µì›"""
        for tr_id, codes in self.subscriptions.items():
            for code in codes:
                await self._subscribe(tr_id, code)
        logger.info(f"êµ¬ë… ë³µì› ì™„ë£Œ: {sum(len(v) for v in self.subscriptions.values())}ê±´")
```

#### RateLimiter í´ë˜ìŠ¤

```python
class RateLimiter:
    """
    KIS API í˜¸ì¶œ ì œí•œ ê´€ë¦¬
    - REST API: ì´ˆë‹¹ 20íšŒ ì œí•œ
    - í˜¸ì¶œ ê°„ê²© ìë™ ì¡°ì ˆ
    - ë²„ìŠ¤íŠ¸ ë°©ì§€ë¥¼ ìœ„í•œ Token Bucket ì•Œê³ ë¦¬ì¦˜
    """
    
    def __init__(self, calls_per_second: int = 20):
        self.calls_per_second = calls_per_second
        self.min_interval = 1.0 / calls_per_second
        self.semaphore = asyncio.Semaphore(calls_per_second)
        self.last_call_time = 0.0
        self._lock = asyncio.Lock()
    
    async def acquire(self):
        """í˜¸ì¶œ ê¶Œí•œ íšë“ (í•„ìš” ì‹œ ëŒ€ê¸°)"""
        async with self._lock:
            now = time.monotonic()
            elapsed = now - self.last_call_time
            if elapsed < self.min_interval:
                await asyncio.sleep(self.min_interval - elapsed)
            self.last_call_time = time.monotonic()
```

### 4.3 ì‹œì¥ ë°ì´í„°ë¶€ (Market Data Hub)

#### StockScreener í´ë˜ìŠ¤

```python
class StockScreener:
    """
    ì¢…ëª© ìŠ¤ìºë‹ ì—”ì§„ â€” Minervini Trend Template + CAN SLIM í†µí•©
    
    í•„ìˆ˜ ìê²© ì¡°ê±´:
    - ì‹œê°€ì´ì•¡ 5,000ì–µì› ì´ìƒ
    - ì¼í‰ê·  ê±°ë˜ëŒ€ê¸ˆ 100ì–µì› ì´ìƒ (20ì¼)
    - ì¼í‰ê·  ê±°ë˜ëŸ‰ 100ë§Œì£¼ ì´ìƒ (ë˜ëŠ” íšŒì „ìœ¨ 0.5%+)
    - í˜¸ê°€ ìŠ¤í”„ë ˆë“œ 0.3% ì´ë‚´
    - ìƒì¥ 6ê°œì›” ì´ìƒ
    - ê´€ë¦¬ì¢…ëª©/íˆ¬ìê²½ê³  í•´ë‹¹ ì—†ìŒ
    
    ë“±ê¸‰ ë¶„ë¥˜:
    - Aë“±ê¸‰: ì‹œê°€ì´ì•¡ ìƒìœ„ 30ìœ„ (ì´ˆëŒ€í˜• ìš°ëŸ‰ì£¼)
    - Bë“±ê¸‰: ì‹œê°€ì´ì•¡ 30~100ìœ„ (ëª¨ë©˜í…€ ì¤‘í˜•ì£¼)
    - Cë“±ê¸‰: ì‹œê°€ì´ì•¡ 100~200ìœ„ (í…Œë§ˆ ì†Œí˜•ì£¼)
    - Dë“±ê¸‰: ë§¤ë§¤ ê¸ˆì§€
    """
    
    # Minervini Trend Template 8ê°€ì§€ ê¸°ìˆ ì  ì¡°ê±´
    TREND_TEMPLATE_CHECKS = [
        ("í˜„ì¬ê°€ > 50ì¼ì„ ", lambda s: s.price > s.ma_50),
        ("í˜„ì¬ê°€ > 150ì¼ì„ ", lambda s: s.price > s.ma_150),
        ("í˜„ì¬ê°€ > 200ì¼ì„ ", lambda s: s.price > s.ma_200),
        ("50ì¼ì„  > 150ì¼ì„  > 200ì¼ì„ ", lambda s: s.ma_50 > s.ma_150 > s.ma_200),
        ("200ì¼ì„  ìƒìŠ¹ ì¤‘ (1ê°œì›”)", lambda s: s.ma_200_slope > 0),
        ("í˜„ì¬ê°€ >= 52ì£¼ì €ì  +30%", lambda s: s.price >= s.week52_low * 1.3),
        ("í˜„ì¬ê°€ <= 52ì£¼ê³ ì  -25%", lambda s: s.price >= s.week52_high * 0.75),
        ("RS ì½”ìŠ¤í”¼ ëŒ€ë¹„ ìƒìœ„ 30%", lambda s: s.rs_rank >= 70),
    ]
    
    async def scan_daily(self) -> List[StockCandidate]:
        """ë‹¹ì¼ ë§¤ë§¤ í›„ë³´ ìŠ¤ìºë‹ (08:30~09:00 ì‹¤í–‰)"""
        # 1ë‹¨ê³„: ì „ì¼ ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ 50ì¢…ëª© ì¶”ì¶œ
        volume_rank = await self.rest_client.get_volume_rank()
        candidates = self._filter_top_50(volume_rank)
        
        # 2ë‹¨ê³„: ê¸°ë³¸ ìê²© ì¡°ê±´ í•„í„°ë§
        candidates = [c for c in candidates if self._check_basic_qualification(c)]
        
        # 3ë‹¨ê³„: Trend Template 8í•­ëª© ì²´í¬
        for c in candidates:
            c.trend_score = sum(1 for _, check in self.TREND_TEMPLATE_CHECKS if check(c))
        candidates = [c for c in candidates if c.trend_score >= 5]
        
        # 4ë‹¨ê³„: CAN SLIM ê¸°ë³¸ì  ì¡°ê±´ í™•ì¸
        for c in candidates:
            c.canslim_score = self._check_canslim(c)
        
        # 5ë‹¨ê³„: ë“±ê¸‰ ë¶„ë¥˜ ë° í™•ì‹ ë„ ì‚°ì •
        for c in candidates:
            c.grade = self._classify_grade(c)
            c.confidence = self._calculate_confidence(c)
        
        # 6ë‹¨ê³„: ìµœì¢… í›„ë³´ 3~5ì¢…ëª© ë°˜í™˜
        return sorted(candidates, key=lambda x: x.confidence, reverse=True)[:5]
    
    def _calculate_confidence(self, stock: StockCandidate) -> int:
        """
        í™•ì‹ ë„ ì ìˆ˜ ì‚°ì • (Minervini ë°©ì‹)
        â­â­â­â­â­: ê¸°ìˆ  8ì¡°ê±´ + ê¸°ë³¸ 5ì¡°ê±´ + VCP + ê¸°ê´€ì™¸êµ­ì¸ ë™ì‹œ ìˆœë§¤ìˆ˜
        â­â­â­â­: ê¸°ìˆ  6+ + ê¸°ë³¸ 3+ + ìˆ˜ê¸‰ ì–‘í˜¸
        â­â­â­: ê¸°ìˆ  5+ + ê¸°ë³¸ 2+ + ìˆ˜ê¸‰ ì¤‘ë¦½
        â­â­ ì´í•˜: ë§¤ë§¤ ê¸ˆì§€
        """
        if stock.trend_score >= 8 and stock.canslim_score >= 5 and stock.inst_foreign_flow == "BUY":
            return 5
        elif stock.trend_score >= 6 and stock.canslim_score >= 3:
            return 4
        elif stock.trend_score >= 5 and stock.canslim_score >= 2:
            return 3
        else:
            return 2  # ë§¤ë§¤ ê¸ˆì§€
```

#### IndicatorCalculator í´ë˜ìŠ¤

```python
class IndicatorCalculator:
    """
    ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° ì—”ì§„
    - ì´ë™í‰ê· ì„  (SMA, EMA): 5, 10, 20, 50, 150, 200ì¼
    - RSI (14ì¼)
    - VWAP (ë‹¹ì¼)
    - ë³¼ë¦°ì € ë°´ë“œ (20ì¼, 2Ïƒ)
    - MACD (12, 26, 9)
    - ATR (14ì¼)
    - ê±°ë˜ëŸ‰ ì´ë™í‰ê· 
    """
    
    @staticmethod
    def sma(prices: List[float], period: int) -> float:
        return sum(prices[-period:]) / period
    
    @staticmethod
    def ema(prices: List[float], period: int) -> float:
        multiplier = 2 / (period + 1)
        ema = prices[0]
        for price in prices[1:]:
            ema = (price - ema) * multiplier + ema
        return ema
    
    @staticmethod
    def rsi(prices: List[float], period: int = 14) -> float:
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        gains = [d if d > 0 else 0 for d in deltas[-period:]]
        losses = [-d if d < 0 else 0 for d in deltas[-period:]]
        avg_gain = sum(gains) / period
        avg_loss = sum(losses) / period
        if avg_loss == 0:
            return 100
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))
    
    @staticmethod
    def vwap(prices: List[float], volumes: List[int], highs: List[float], lows: List[float]) -> float:
        typical_prices = [(h + l + c) / 3 for h, l, c in zip(highs, lows, prices)]
        cumul_tp_vol = sum(tp * v for tp, v in zip(typical_prices, volumes))
        cumul_vol = sum(volumes)
        return cumul_tp_vol / cumul_vol if cumul_vol > 0 else 0
    
    @staticmethod
    def bollinger_bands(prices: List[float], period: int = 20, num_std: float = 2.0):
        sma = sum(prices[-period:]) / period
        std = (sum((p - sma) ** 2 for p in prices[-period:]) / period) ** 0.5
        return {
            "upper": sma + num_std * std,
            "middle": sma,
            "lower": sma - num_std * std
        }
    
    @staticmethod
    def atr(highs: List[float], lows: List[float], closes: List[float], period: int = 14) -> float:
        true_ranges = []
        for i in range(1, len(highs)):
            tr = max(highs[i] - lows[i], 
                     abs(highs[i] - closes[i-1]), 
                     abs(lows[i] - closes[i-1]))
            true_ranges.append(tr)
        return sum(true_ranges[-period:]) / period
    
    @staticmethod
    def macd(prices: List[float], fast=12, slow=26, signal=9):
        ema_fast = IndicatorCalculator.ema(prices, fast)
        ema_slow = IndicatorCalculator.ema(prices, slow)
        macd_line = ema_fast - ema_slow
        return {"macd": macd_line, "signal": None, "histogram": None}
```

---

## 5. KIS API íŠ¹í™” ì„¤ê³„

### 5.1 API í˜¸ì¶œ ì œí•œ(Throttling) ë°©ì§€ ë¡œì§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  API í˜¸ì¶œ   â”‚â”€â”€â”€â”€â–¶â”‚ Rate Limiter â”‚â”€â”€â”€â”€â–¶â”‚  KIS Server  â”‚
â”‚  ìš”ì²­ í    â”‚     â”‚ (Token       â”‚     â”‚              â”‚
â”‚             â”‚     â”‚  Bucket)     â”‚     â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                    â”‚ ì´ˆë‹¹ 20íšŒ â”‚
                    â”‚ ì œí•œ ê´€ë¦¬ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| ì œí•œ í•­ëª© | KIS ê¸°ì¤€ | ì‹œìŠ¤í…œ ì„¤ì • | ë°©ì§€ ì „ëµ |
|----------|---------|-----------|----------|
| REST API ì´ˆë‹¹ í˜¸ì¶œ | 20íšŒ/ì´ˆ | 18íšŒ/ì´ˆ (ì—¬ìœ ë¶„ í™•ë³´) | Token Bucket ì•Œê³ ë¦¬ì¦˜ |
| WebSocket êµ¬ë… ì¢…ëª© | 40ì¢…ëª©/ì—°ê²° | 35ì¢…ëª© (ì—¬ìœ ë¶„) | ë‹¤ì¤‘ ì—°ê²° í’€ ê´€ë¦¬ |
| í† í° ë°œê¸‰ | ë¶„ë‹¹ 1íšŒ | ë§Œë£Œ 1ì‹œê°„ ì „ 1íšŒ | ìºì‹œ íŒŒì¼ í™œìš© |

### 5.2 WebSocket ì¬ì—°ê²° ì „ëµ

```python
RECONNECT_STRATEGY = {
    "max_retries": 30,
    "initial_delay": 1,        # ì´ˆê¸° ëŒ€ê¸° (ì´ˆ)
    "max_delay": 60,           # ìµœëŒ€ ëŒ€ê¸° (ì´ˆ)
    "backoff_factor": 2,       # Exponential Backoff ë°°ìˆ˜
    "jitter": True,            # ëœë¤ ì§€í„° ì¶”ê°€ (Thundering Herd ë°©ì§€)
    "subscription_restore": True,  # ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë… ìë™ ë³µì›
    "heartbeat_interval": 30,  # Ping ê°„ê²© (ì´ˆ)
    "heartbeat_timeout": 10,   # Pong ëŒ€ê¸° (ì´ˆ)
}
```

### 5.3 REST / WebSocket ì—­í•  ë¶„ë¦¬ ì„¤ê³„ [v1.1 ë³€ê²½]

> **[v1.1 í•µì‹¬ ë³€ê²½] ì‹œì„¸ ë°ì´í„°ëŠ” WebSocket â†’ ë¡œì»¬ ìºì‹œì—ì„œ ì½ê¸°. RESTëŠ” ì£¼ë¬¸/ì”ê³  ì „ìš©.**
> ê¸°ì¡´ ì„¤ê³„ì—ì„œ ì „ëµ ëª¨ë“ˆì´ RESTë¡œ ì‹œì„¸ë¥¼ ì§ì ‘ ì¡°íšŒí•˜ëŠ” ê²½ë¡œë¥¼ ì œê±°í–ˆìŠµë‹ˆë‹¤.
> ì—¬ëŸ¬ ì „ëµì´ ë™ì‹œì— ì‹œì„¸ë¥¼ ìš”ì²­í•  ë•Œ Throttling í ë°€ë¦¼ìœ¼ë¡œ ì¸í•œ ì§€ì—°(Latency)ì„ ì›ì²œ ì°¨ë‹¨í•©ë‹ˆë‹¤.

| ë°ì´í„° ìœ í˜• | í†µì‹  ë°©ì‹ | API | ì „ëµ ì ‘ê·¼ ë°©ë²• | ì£¼ê¸° |
|-----------|----------|-----|-------------|------|
| ì‹¤ì‹œê°„ ì²´ê²°ê°€ | **WebSocket** | H0STCNT0 | `cache.get_price(code)` | ì‹¤ì‹œê°„ (Push) |
| ì‹¤ì‹œê°„ í˜¸ê°€ (ì”ëŸ‰ í¬í•¨) | **WebSocket** | H0STASP0 | `cache.get_orderbook(code)` | ì‹¤ì‹œê°„ (Push) |
| **VI ë°œë™ ì •ë³´** | **WebSocket** | H0STVI0 | `vi_monitor.get_status(code)` | ì‹¤ì‹œê°„ (Push) |
| ì£¼ë¬¸ ì²´ê²° í†µë³´ | **WebSocket** | H0STCNC0 | `order_tracker.on_fill()` | ì‹¤ì‹œê°„ (Push) |
| ì¼ë´‰/ë¶„ë´‰ íˆìŠ¤í† ë¦¬ | REST (ë³´ì¡°) | FHKST01010400 | ì¥ ì‹œì‘ ì „ 1íšŒ ë¡œë“œ â†’ ìºì‹œ | ìŠ¤ì¼€ì¤„ (08:30) |
| ê±°ë˜ëŸ‰ ìˆœìœ„ | REST (ë³´ì¡°) | FHPST01710000 | ìŠ¤ìºë‹ ì‹œ 1íšŒ â†’ ìºì‹œ | ìŠ¤ì¼€ì¤„ (08:30) |
| ì£¼ë¬¸ ì‹¤í–‰ | REST | TTTC0802U/0801U | `order_manager.place()` | ìš”ì²­ ì‹œ |
| ì”ê³  ì¡°íšŒ | REST | TTTC8434R | `margin_guard.check()` | ì£¼ë¬¸ ì „/5ë¶„ ì£¼ê¸° |

### 5.4 RealtimeCache â€” In-Memory ê°€ê²© ìºì‹œ [v1.1 NEW]

```python
class RealtimeCache:
    """
    [v1.1 NEW] WebSocket ìˆ˜ì‹  ë°ì´í„° ê¸°ë°˜ In-Memory ìºì‹œ
    
    ì›ì¹™:
    - WebSocket ì½œë°±ì´ ë°ì´í„°ë¥¼ WRITE
    - ì „ëµ ì—”ì§„/ë¦¬ìŠ¤í¬ ê´€ë¦¬ìê°€ ë°ì´í„°ë¥¼ READ ONLY
    - REST API ì§ì ‘ í˜¸ì¶œ ê¸ˆì§€ (ì „ëµì—ì„œ)
    - ìŠ¤ë ˆë“œ ì•ˆì „: asyncio.Lock ê¸°ë°˜
    """
    
    def __init__(self):
        self._prices: Dict[str, PriceData] = {}      # {ì¢…ëª©ì½”ë“œ: ìµœì‹  ì²´ê²° ë°ì´í„°}
        self._orderbooks: Dict[str, OrderbookData] = {} # {ì¢…ëª©ì½”ë“œ: í˜¸ê°€ 10ë‹¨ê³„}
        self._vi_status: Dict[str, VIStatus] = {}     # {ì¢…ëª©ì½”ë“œ: VI ìƒíƒœ}
        self._lock = asyncio.Lock()
        self._last_update: Dict[str, float] = {}      # ìµœì¢… ê°±ì‹  ì‹œê°
    
    # === WebSocket ì½œë°± (WRITE) ===
    
    async def on_price_update(self, stock_code: str, data: dict):
        """ì²´ê²° ë°ì´í„° ìˆ˜ì‹  ì‹œ ìºì‹œ ê°±ì‹  (WebSocket H0STCNT0 ì½œë°±)"""
        async with self._lock:
            self._prices[stock_code] = PriceData(
                price=float(data["stck_prpr"]),
                volume=int(data["cntg_vol"]),
                change_pct=float(data["prdy_ctrt"]),
                timestamp=time.monotonic()
            )
            self._last_update[stock_code] = time.monotonic()
    
    async def on_orderbook_update(self, stock_code: str, data: dict):
        """í˜¸ê°€ ë°ì´í„° ìˆ˜ì‹  ì‹œ ìºì‹œ ê°±ì‹  (WebSocket H0STASP0 ì½œë°±)"""
        async with self._lock:
            self._orderbooks[stock_code] = OrderbookData(
                ask_prices=[float(data[f"askp{i}"]) for i in range(1, 11)],
                ask_volumes=[int(data[f"askp_rsqn{i}"]) for i in range(1, 11)],
                bid_prices=[float(data[f"bidp{i}"]) for i in range(1, 11)],
                bid_volumes=[int(data[f"bidp_rsqn{i}"]) for i in range(1, 11)],
                total_ask_volume=int(data.get("total_askp_rsqn", 0)),
                total_bid_volume=int(data.get("total_bidp_rsqn", 0)),
                timestamp=time.monotonic()
            )
    
    # === ì „ëµ ì—”ì§„ (READ ONLY) ===
    
    def get_price(self, stock_code: str) -> Optional[PriceData]:
        """í˜„ì¬ê°€ ì¡°íšŒ (ë™ê¸°, Lock ë¶ˆìš” â€” ì½ê¸° ì „ìš©)"""
        data = self._prices.get(stock_code)
        if data and (time.monotonic() - data.timestamp) > 5.0:
            logger.warning(f"{stock_code} ìºì‹œ ë°ì´í„° 5ì´ˆ ì´ìƒ ë¯¸ê°±ì‹  â€” ë°ì´í„° ì‹ ì„ ë„ ì£¼ì˜")
        return data
    
    def get_orderbook(self, stock_code: str) -> Optional[OrderbookData]:
        """í˜¸ê°€ ì¡°íšŒ (ì”ëŸ‰ í¬í•¨)"""
        return self._orderbooks.get(stock_code)
    
    def get_vi_status(self, stock_code: str) -> Optional[VIStatus]:
        """VI ë°œë™ ìƒíƒœ ì¡°íšŒ"""
        return self._vi_status.get(stock_code)
    
    def is_data_fresh(self, stock_code: str, max_age_sec: float = 3.0) -> bool:
        """ë°ì´í„° ì‹ ì„ ë„ í™•ì¸"""
        last = self._last_update.get(stock_code, 0)
        return (time.monotonic() - last) <= max_age_sec
```

### 5.5 VI ëª¨ë‹ˆí„° â€” ë³€ë™ì„± ì™„í™”ì¥ì¹˜ ëŒ€ì‘ [v1.1 NEW]

> **í•œêµ­ ì‹œì¥ ê³ ìœ  ì œë„:** ì •ì VI(ì „ì¼ ì¢…ê°€ Â±10%) / ë™ì VI(ì§ì „ ê°€ê²© ëŒ€ë¹„ ê¸‰ë³€ë™) ë°œë™ ì‹œ 2ë¶„ê°„ ë§¤ë§¤ ì •ì§€.
> ëŒíŒŒ ì „ëµ(S1, S3) ì‹¤í–‰ ì‹œ VI ë°œë™ ê°€ê²©ì„ ë¬´ì‹œí•˜ë©´ í—ˆìˆ˜ ì£¼ë¬¸ ë˜ëŠ” ê°ë‹¹ ë¶ˆê°€ ìŠ¬ë¦¬í”¼ì§€ê°€ ë°œìƒí•©ë‹ˆë‹¤.

```python
class VIMonitor:
    """
    [v1.1 NEW] ë³€ë™ì„± ì™„í™”ì¥ì¹˜(VI) ì‹¤ì‹œê°„ ê°ì§€ ë° ì „ëµ ì—°ë™
    
    ê¸°ëŠ¥:
    1. VI ë°œë™ ê°€ê²© ì‹¤ì‹œê°„ ì¶”ì  (ì •ì VI / ë™ì VI)
    2. VI ë°œë™ ì¤‘ â†’ í•´ë‹¹ ì¢…ëª© ì£¼ë¬¸ ìë™ ë³´ë¥˜
    3. VI í•´ì œ í›„ ìˆ˜ê¸‰ ì•ˆì • í™•ì¸ â†’ ì§„ì… íŒë‹¨ ì¬ê°œ
    4. ëŒíŒŒ ì „ëµì— VI ê·¼ì ‘ ê²½ê³  ì „ë‹¬
    """
    
    class VIState(Enum):
        NORMAL = "ì •ìƒ"
        WARNING = "VI_ê·¼ì ‘"         # í˜„ì¬ê°€ê°€ VI ë°œë™ê°€ ëŒ€ë¹„ 1% ì´ë‚´
        TRIGGERED = "VI_ë°œë™ì¤‘"     # 2ë¶„ ë§¤ë§¤ì •ì§€
        COOLING = "VI_í•´ì œì§í›„"     # í•´ì œ í›„ 30ì´ˆ ê´€ì°° êµ¬ê°„
    
    def __init__(self, cache: RealtimeCache):
        self.cache = cache
        self._vi_prices: Dict[str, dict] = {}       # {ì¢…ëª©ì½”ë“œ: {static_up, static_down, dynamic}}
        self._vi_states: Dict[str, VIState] = {}     # {ì¢…ëª©ì½”ë“œ: í˜„ì¬ ìƒíƒœ}
        self._vi_triggered_at: Dict[str, float] = {} # {ì¢…ëª©ì½”ë“œ: ë°œë™ ì‹œê°}
    
    async def on_vi_data(self, stock_code: str, data: dict):
        """WebSocket VI ì •ë³´ ìˆ˜ì‹  ì½œë°±"""
        vi_type = data.get("vi_cls_code")  # ì •ì /ë™ì  êµ¬ë¶„
        
        if data.get("vi_stnd_prc"):  # VI ë°œë™ ê¸°ì¤€ê°€
            self._vi_prices[stock_code] = {
                "static_upper": float(data.get("vi_stnd_prc", 0)) * 1.10,
                "static_lower": float(data.get("vi_stnd_prc", 0)) * 0.90,
                "reference_price": float(data.get("vi_stnd_prc", 0)),
            }
        
        if vi_type == "1":  # VI ë°œë™
            self._vi_states[stock_code] = self.VIState.TRIGGERED
            self._vi_triggered_at[stock_code] = time.monotonic()
            logger.warning(f"âš ï¸ VI ë°œë™: {stock_code} â€” 2ë¶„ê°„ ë§¤ë§¤ ì •ì§€")
            
        elif vi_type == "2":  # VI í•´ì œ
            self._vi_states[stock_code] = self.VIState.COOLING
            logger.info(f"âœ… VI í•´ì œ: {stock_code} â€” 30ì´ˆ ê´€ì°° í›„ ë§¤ë§¤ ì¬ê°œ")
            # 30ì´ˆ í›„ NORMAL ì „í™˜
            asyncio.create_task(self._transition_to_normal(stock_code, delay=30))
    
    def check_vi_proximity(self, stock_code: str, target_price: float) -> dict:
        """
        ëŒíŒŒ ì „ëµìš©: ëª©í‘œ ì§„ì…ê°€ê°€ VI ë°œë™ê°€ì— ê·¼ì ‘í•œì§€ í™•ì¸
        - 1% ì´ë‚´ â†’ WARNING (ì§„ì… ìì œ ê¶Œì¥)
        - VI ë°œë™ ì¤‘ â†’ ì£¼ë¬¸ ì°¨ë‹¨
        """
        state = self._vi_states.get(stock_code, self.VIState.NORMAL)
        
        if state == self.VIState.TRIGGERED:
            return {"allow_order": False, "reason": "VI ë°œë™ ì¤‘ â€” ë§¤ë§¤ ì •ì§€ ìƒíƒœ"}
        
        if state == self.VIState.COOLING:
            return {"allow_order": False, "reason": "VI í•´ì œ ì§í›„ â€” 30ì´ˆ ê´€ì°° ì¤‘"}
        
        vi_price = self._vi_prices.get(stock_code)
        if vi_price:
            upper = vi_price["static_upper"]
            proximity = abs(target_price - upper) / upper * 100
            if proximity < 1.0:
                return {
                    "allow_order": True,
                    "warning": f"VI ë°œë™ê°€({upper:,.0f}ì›)ì— {proximity:.2f}% ê·¼ì ‘ â€” ì§„ì… ì£¼ì˜",
                    "vi_state": "WARNING"
                }
        
        return {"allow_order": True, "vi_state": "NORMAL"}
    
    async def _transition_to_normal(self, stock_code: str, delay: int):
        await asyncio.sleep(delay)
        self._vi_states[stock_code] = self.VIState.NORMAL
```

---

## 6. ì „ëµ ì—”ì§„ ìƒì„¸ ì„¤ê³„

### 6.1 ì „ëµ ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤

```python
from abc import ABC, abstractmethod
from enum import Enum
from dataclasses import dataclass

class MarketRegime(Enum):
    STRONG_BULL = "ê°•í•œ ìƒìŠ¹ì¥"
    BULL = "ì¼ë°˜ ìƒìŠ¹ì¥"
    SIDEWAYS = "ë³´í•©/íš¡ë³´ì¥"
    BEAR = "ì•½ì„¸ì¥"
    STRONG_BEAR = "ê°•í•œ í•˜ë½ì¥"

class StrategyCategory(Enum):
    BULL = "ìƒìŠ¹ì¥"       # S1~S5
    BEAR = "í•˜ë½ì¥"       # B1~B4
    NEUTRAL = "ì¤‘ë¦½"      # ê·¸ë¦¬ë“œ, ë°°ë‹¹ì£¼

@dataclass
class TradeSignal:
    stock_code: str
    action: str              # BUY / SELL
    strategy_code: str       # S1, S2, ..., B1, B2, ...
    entry_price: float
    stop_loss: float
    target_prices: List[float]  # [1ì°¨ ìµì ˆ, 2ì°¨ ìµì ˆ, 3ì°¨ ìµì ˆ]
    position_pct: float      # í¬ì§€ì…˜ ë¹„ì¤‘ (%)
    confidence: int          # í™•ì‹ ë„ (1~5)
    reason: str              # ì§„ì… ê·¼ê±° ì„¤ëª…
    indicators_snapshot: dict # ì§„ì… ì‹œì  ì§€í‘œ ìŠ¤ëƒ…ìƒ·

class BaseStrategy(ABC):
    """ëª¨ë“  ì „ëµì˜ ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤"""
    
    def __init__(self, strategy_code: str, category: StrategyCategory):
        self.strategy_code = strategy_code
        self.category = category
        self.is_active = True
    
    @abstractmethod
    async def scan(self, candidates: List[StockCandidate]) -> List[StockCandidate]:
        """ì „ëµ ì¡°ê±´ì— ë§ëŠ” ì¢…ëª© í•„í„°ë§"""
        pass
    
    @abstractmethod
    async def generate_signal(self, stock: StockCandidate, 
                               market_data: MarketData) -> Optional[TradeSignal]:
        """ë§¤ë§¤ ì‹ í˜¸ ìƒì„±"""
        pass
    
    @abstractmethod
    def get_exit_rules(self) -> dict:
        """ì²­ì‚° ê·œì¹™ ë°˜í™˜ (ì†ì ˆ/ìµì ˆ/íŠ¸ë ˆì¼ë§)"""
        pass
    
    def is_applicable(self, regime: MarketRegime) -> bool:
        """í˜„ì¬ ì¥ì„¸ì—ì„œ ì ìš© ê°€ëŠ¥ ì—¬ë¶€"""
        if self.category == StrategyCategory.BULL:
            return regime in (MarketRegime.STRONG_BULL, MarketRegime.BULL)
        elif self.category == StrategyCategory.BEAR:
            return regime in (MarketRegime.BEAR, MarketRegime.STRONG_BEAR)
        return True  # NEUTRALì€ í•­ìƒ ì ìš©
```

### 6.2 ìƒìŠ¹ì¥ ì „ëµ êµ¬í˜„

#### S1. SEPA ëª¨ë©˜í…€ ëŒíŒŒ (Minervini)

```python
class SEPAMomentumStrategy(BaseStrategy):
    """
    Mark Minervini SEPA ëª¨ë©˜í…€ ëŒíŒŒ ì „ëµ
    - VCP(Volatility Contraction Pattern) íŒ¨í„´ í˜•ì„± í™•ì¸
    - í”¼ë²— í¬ì¸íŠ¸ ëŒíŒŒ ì‹œ ì§„ì…
    - EPS +20%, ë§¤ì¶œ +15% ì´ìƒ í™•ì¸ í•„ìˆ˜
    - ì½”ìŠ¤í”¼ ì ìš©: Bë“±ê¸‰ ì¤‘ì‹¬, íˆ¬ì… ë¹„ì¤‘ 15~20%
    """
    
    def __init__(self):
        super().__init__("S1", StrategyCategory.BULL)
        self.params = {
            "vcp_contractions": 3,       # VCP ìˆ˜ì¶• íšŸìˆ˜
            "volume_breakout_ratio": 1.5, # ëŒíŒŒ ì‹œ ê±°ë˜ëŸ‰ ë°°ìˆ˜
            "eps_min_growth": 20,         # ìµœì†Œ EPS ì„±ì¥ë¥  (%)
            "revenue_min_growth": 15,     # ìµœì†Œ ë§¤ì¶œ ì„±ì¥ë¥  (%)
            "stop_loss_pct": 7,           # ì†ì ˆ (í”¼ë²— í•˜ë‹¨ %)
            "target_1_pct": 10,           # 1ì°¨ ìµì ˆ (%)
            "target_2_pct": 20,           # 2ì°¨ ìµì ˆ (%)
            "grade_target": ["B"],        # ëŒ€ìƒ ë“±ê¸‰
            "position_pct": 17.5,         # ê¸°ë³¸ í¬ì§€ì…˜ ë¹„ì¤‘ (%)
        }
    
    async def generate_signal(self, stock, market_data) -> Optional[TradeSignal]:
        indicators = market_data.indicators
        
        # 1. VCP íŒ¨í„´ í™•ì¸ (ë³€ë™í­ ìˆ˜ì¶• 3íšŒ ì´ìƒ)
        if not self._detect_vcp(market_data.daily_prices):
            return None
        
        # 2. í”¼ë²— í¬ì¸íŠ¸ ëŒíŒŒ í™•ì¸
        pivot = self._calculate_pivot(market_data.daily_prices)
        if market_data.current_price < pivot:
            return None
        
        # 3. ëŒíŒŒ ì‹œ ê±°ë˜ëŸ‰ í™•ì¸ (í‰ì†Œ 1.5ë°° ì´ìƒ)
        if market_data.current_volume < stock.avg_volume_20d * self.params["volume_breakout_ratio"]:
            return None
        
        # 4. ê¸°ë³¸ì  ì¡°ê±´ í™•ì¸
        if stock.eps_growth_qoq < self.params["eps_min_growth"]:
            return None
        if stock.revenue_growth < self.params["revenue_min_growth"]:
            return None
        
        stop_loss = pivot * (1 - self.params["stop_loss_pct"] / 100)
        
        return TradeSignal(
            stock_code=stock.stock_code,
            action="BUY",
            strategy_code="S1",
            entry_price=market_data.current_price,
            stop_loss=stop_loss,
            target_prices=[
                market_data.current_price * 1.10,  # +10%
                market_data.current_price * 1.20,  # +20%
                0  # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘
            ],
            position_pct=self._adjust_position(stock.confidence, stock.grade),
            confidence=stock.confidence,
            reason=f"SEPA ëª¨ë©˜í…€ ëŒíŒŒ: VCP íŒ¨í„´ ì™„ì„±, í”¼ë²— {pivot:,.0f}ì› ëŒíŒŒ, "
                   f"ê±°ë˜ëŸ‰ {market_data.current_volume/stock.avg_volume_20d:.1f}ë°°",
            indicators_snapshot=self._capture_snapshot(indicators)
        )
```

#### S5. VWAP ë°”ìš´ìŠ¤ (Carter/Aziz)

```python
class VWAPBounceStrategy(BaseStrategy):
    """
    VWAP ë°”ìš´ìŠ¤ + ëª¨ë©˜í…€ ë§¤ë§¤ (Carter/Aziz)
    - VWAP ìœ„ì—ì„œ ì›€ì§ì´ëŠ” ê°•í•œ ì¢…ëª©ì´ VWAP ë¶€ê·¼ ëˆŒë¦¼ ì‹œ ë§¤ìˆ˜
    - ê¸°ê´€ ë§¤ìˆ˜ì„¸ì˜ VWAP ì§€ì§€ í™•ì¸ì´ í•µì‹¬
    - ì½”ìŠ¤í”¼ ì ìš©: Aë“±ê¸‰ ëŒ€í˜•ì£¼ ì¤‘ì‹¬, íˆ¬ì… ë¹„ì¤‘ 20~30%
    """
    
    def __init__(self):
        super().__init__("S5", StrategyCategory.BULL)
        self.params = {
            "vwap_proximity_pct": 0.5,   # VWAP ëŒ€ë¹„ í—ˆìš© ê±°ë¦¬ (%)
            "bounce_candles": 2,          # ë°˜ë“± í™•ì¸ ìº”ë“¤ ìˆ˜
            "stop_loss_rule": "VWAP_BREAK", # VWAP ì´íƒˆ ì‹œ ì¦‰ì‹œ ì²­ì‚°
            "grade_target": ["A"],
            "position_pct": 25,
        }
    
    async def generate_signal(self, stock, market_data) -> Optional[TradeSignal]:
        vwap = market_data.indicators["vwap"]
        price = market_data.current_price
        
        # 1. í˜„ì¬ê°€ê°€ VWAP ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
        if price < vwap:
            return None
        
        # 2. VWAP ê·¼ì²˜ ëˆŒë¦¼ëª© í™•ì¸ (VWAP ëŒ€ë¹„ 0.5% ì´ë‚´)
        distance = (price - vwap) / vwap * 100
        if distance > self.params["vwap_proximity_pct"]:
            return None
        
        # 3. ë°˜ë“± ìº”ë“¤ 2ê°œ í™•ì¸
        if not self._confirm_bounce(market_data.minute_candles, vwap):
            return None
        
        return TradeSignal(
            stock_code=stock.stock_code,
            action="BUY",
            strategy_code="S5",
            entry_price=price,
            stop_loss=vwap * 0.995,  # VWAP ì‚´ì§ ì•„ë˜
            target_prices=[price * 1.05, price * 1.10, 0],
            position_pct=self._adjust_position(stock.confidence, stock.grade),
            confidence=stock.confidence,
            reason=f"VWAP ë°”ìš´ìŠ¤: VWAP {vwap:,.0f}ì› ì§€ì§€ í™•ì¸, "
                   f"ê±°ë¦¬ {distance:.2f}%, ë°˜ë“± ìº”ë“¤ í™•ì¸",
            indicators_snapshot=self._capture_snapshot(market_data.indicators)
        )
```

### 6.3 í•˜ë½ì¥ ì „ëµ êµ¬í˜„

#### B1. ë°ë“œìº£ ë°”ìš´ìŠ¤ (Staley/Turner)

```python
class DeadCatBounceStrategy(BaseStrategy):
    """
    ë°ë“œìº£ ë°”ìš´ìŠ¤ ë§¤ë§¤ (Staley/Turner)
    - ì „ì¼ ëŒ€ë¹„ 5~10% ê¸‰ë½ ì¢…ëª©ì˜ ê¸°ìˆ ì  ë°˜ë“± í¬ì°©
    - RSI 30 ì´í•˜ ê³¼ë§¤ë„ + ê±°ë˜ëŸ‰ ë°˜ë“± í™•ì¸
    - ëª©í‘œ ìˆ˜ìµë¥  3~5%, ì†ì ˆ -2% ì´ë‚´
    - ì½”ìŠ¤í”¼ ì ìš©: Aë“±ê¸‰ ëŒ€í˜•ì£¼ í•œì •, íˆ¬ì… ë¹„ì¤‘ 10~15%
    """
    
    def __init__(self):
        super().__init__("B1", StrategyCategory.BEAR)
        self.params = {
            "min_drop_pct": 5,           # ìµœì†Œ í•˜ë½ë¥  (%)
            "max_drop_pct": 10,          # ìµœëŒ€ í•˜ë½ë¥  (%)
            "rsi_threshold": 30,         # RSI ê³¼ë§¤ë„ ê¸°ì¤€
            "target_pct": 4,             # ëª©í‘œ ìˆ˜ìµë¥  (%)
            "stop_loss_pct": 2,          # ì†ì ˆ (%)
            "max_holding_hours": 4,      # ìµœëŒ€ ë³´ìœ  ì‹œê°„
            "grade_target": ["A"],
            "position_pct": 12.5,
        }
```

### 6.4 ë³€ë™ì„± ëŒíŒŒ ì „ëµ (ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤)

```python
class VolatilityBreakoutStrategy(BaseStrategy):
    """
    ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤ ë³€ë™ì„± ëŒíŒŒ ì „ëµ
    - ì „ì¼ ë³€ë™í­(ê³ ê°€-ì €ê°€) Ã— K(ê³„ìˆ˜) ë§Œí¼ ë‹¹ì¼ ì‹œê°€ì—ì„œ ëŒíŒŒ ì‹œ ë§¤ìˆ˜
    - ì¥ ë§ˆê° ì‹œ ì²­ì‚° (ë‹¹ì¼ ë§¤ë§¤ ì›ì¹™)
    - Kê°’: 0.3~0.6 (ë°±í…ŒìŠ¤íŠ¸ ìµœì í™”)
    """
    
    def __init__(self):
        super().__init__("VB", StrategyCategory.NEUTRAL)
        self.params = {
            "k_factor": 0.5,             # ë³€ë™í­ ê³„ìˆ˜
            "min_range_pct": 1.0,        # ìµœì†Œ ì „ì¼ ë³€ë™í­ (%)
        }
    
    async def generate_signal(self, stock, market_data) -> Optional[TradeSignal]:
        prev_high = market_data.prev_day["high"]
        prev_low = market_data.prev_day["low"]
        prev_range = prev_high - prev_low
        today_open = market_data.today_open
        
        # ëŒíŒŒ ëª©í‘œê°€ ê³„ì‚°
        breakout_price = today_open + prev_range * self.params["k_factor"]
        
        if market_data.current_price >= breakout_price:
            return TradeSignal(
                stock_code=stock.stock_code,
                action="BUY",
                strategy_code="VB",
                entry_price=market_data.current_price,
                stop_loss=today_open * 0.98,
                target_prices=[0],  # ì¥ ë§ˆê° ì‹œ ì²­ì‚°
                position_pct=self._adjust_position(stock.confidence, stock.grade),
                confidence=stock.confidence,
                reason=f"ë³€ë™ì„± ëŒíŒŒ: ì‹œê°€ {today_open:,.0f} + ì „ì¼ë³€ë™í­ "
                       f"{prev_range:,.0f} Ã— K({self.params['k_factor']}) = "
                       f"ëª©í‘œê°€ {breakout_price:,.0f}ì› ëŒíŒŒ",
                indicators_snapshot=self._capture_snapshot(market_data.indicators)
            )
        return None
```

### 6.5 ê·¸ë¦¬ë“œ ë§¤ë§¤ ì „ëµ

```python
class GridTradingStrategy(BaseStrategy):
    """
    ê·¸ë¦¬ë“œ ë§¤ë§¤ ì „ëµ â€” ë°•ìŠ¤ê¶Œ ì¥ì„¸ ìµœì í™”
    - ì •í•´ì§„ ê°€ê²©ëŒ€ë§ˆë‹¤ ì´˜ì´˜í•˜ê²Œ ë§¤ìˆ˜/ë§¤ë„ ë°˜ë³µ
    - ìƒ/í•˜í•œ ê°€ê²© ë²”ìœ„ ë‚´ ê· ë“± ë¶„í• 
    - ê·¸ë¦¬ë“œ ì´íƒˆ ì‹œ ì „ëµ ì¤‘ë‹¨
    """
    
    def __init__(self):
        super().__init__("GR", StrategyCategory.NEUTRAL)
        self.params = {
            "grid_count": 10,            # ê·¸ë¦¬ë“œ ìˆ˜
            "grid_range_pct": 10,        # ê·¸ë¦¬ë“œ ë²”ìœ„ (ìƒí•˜ %)
            "order_size_pct": 5,         # ê·¸ë¦¬ë“œë‹¹ ì£¼ë¬¸ ë¹„ì¤‘ (%)
            "max_position_pct": 30,      # ìµœëŒ€ í¬ì§€ì…˜ ë¹„ì¤‘ (%)
        }
    
    def calculate_grid(self, center_price: float) -> List[dict]:
        """ê·¸ë¦¬ë“œ ê°€ê²© ë ˆë²¨ ê³„ì‚°"""
        half_range = center_price * self.params["grid_range_pct"] / 100 / 2
        grid_step = half_range * 2 / self.params["grid_count"]
        
        grids = []
        for i in range(self.params["grid_count"] + 1):
            price = center_price - half_range + (grid_step * i)
            action = "BUY" if price < center_price else "SELL"
            grids.append({
                "level": i,
                "price": round(price),
                "action": action,
                "filled": False
            })
        return grids
```

### 6.6 ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ì „ëµ

```python
class DividendSwitchingStrategy(BaseStrategy):
    """
    ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ ì „ëµ
    - ì›” ì´ˆ/ì›” ë§ ë°°ë‹¹ ì¼ì • ê¸°ë°˜ ì¢…ëª© ìë™ êµì²´
    - ë°°ë‹¹ë½ì¼ ì „ ì§„ì… â†’ ë°°ë‹¹ ìˆ˜ë ¹ í›„ êµì²´
    - ê³ ë°°ë‹¹ ìš°ëŸ‰ì£¼(Aë“±ê¸‰) ì¤‘ì‹¬ ìš´ìš©
    """
    
    def __init__(self):
        super().__init__("DS", StrategyCategory.NEUTRAL)
        self.dividend_calendar = {}  # {stock_code: [ë°°ë‹¹ì¼ ëª©ë¡]}
    
    async def check_switching_signal(self, date: datetime.date) -> List[TradeSignal]:
        """ë°°ë‹¹ ì¼ì • ê¸°ë°˜ êµì²´ ë§¤ë§¤ ì‹ í˜¸ ìƒì„±"""
        signals = []
        
        # ë°°ë‹¹ë½ 2ì¼ ì „: ê³ ë°°ë‹¹ì£¼ ë§¤ìˆ˜
        upcoming = self._get_upcoming_dividends(date, days_ahead=2)
        for stock in upcoming:
            if stock.dividend_yield >= 3.0:  # ë°°ë‹¹ìˆ˜ìµë¥  3% ì´ìƒ
                signals.append(self._create_buy_signal(stock))
        
        # ë°°ë‹¹ë½ ë‹¤ìŒ ë‚ : ê³¼ë§¤ë„ ë°˜ë“± ê¸°íšŒ íƒìƒ‰
        post_ex = self._get_post_ex_dividend(date)
        for stock in post_ex:
            if self._is_oversold_bounce(stock):
                signals.append(self._create_bounce_signal(stock))
        
        return signals
```

### 6.7 ì „ëµ ìë™ ì„ íƒê¸°

```python
class StrategySelector:
    """
    ì¥ì„¸ë³„ ì „ëµ ìë™ ì„ íƒê¸°
    - ì‹œì¥ ë ˆì§(ì¥ì„¸) íŒë‹¨ â†’ ì ìš© ê°€ëŠ¥ ì „ëµ í•„í„°ë§
    - ì¥ì„¸ íŒë‹¨ ê¸°ì¤€: ì½”ìŠ¤í”¼ ì´ë™í‰ê· ì„ , ìƒìŠ¹/í•˜ë½ ì¢…ëª© ë¹„ìœ¨, VIX
    """
    
    STRATEGY_MAP = {
        MarketRegime.STRONG_BULL: ["S1","S2","S3","S4","S5","VB","GR"],
        MarketRegime.BULL:        ["S1","S3","S4","S5","VB","GR"],
        MarketRegime.SIDEWAYS:    ["S5","VB","GR","B3"],
        MarketRegime.BEAR:        ["B1","B2","B3","B4","GR"],
        MarketRegime.STRONG_BEAR: ["B1","B2","B4"],
    }
    
    def detect_regime(self, kospi_data: dict) -> MarketRegime:
        """
        ì¥ì„¸ íŒë‹¨ (Elder Triple Screen 1ì°¨ í•„í„° + O'Neil Mìš”ì†Œ)
        """
        price = kospi_data["close"]
        ma50 = kospi_data["ma_50"]
        ma200 = kospi_data["ma_200"]
        advance_decline = kospi_data["advance_decline_ratio"]
        
        if price > ma50 > ma200 and advance_decline > 1.5:
            return MarketRegime.STRONG_BULL
        elif price > ma50 and price > ma200:
            return MarketRegime.BULL
        elif price < ma50 and price < ma200 and advance_decline < 0.5:
            return MarketRegime.STRONG_BEAR
        elif price < ma200:
            return MarketRegime.BEAR
        else:
            return MarketRegime.SIDEWAYS
    
    def select_strategies(self, regime: MarketRegime) -> List[BaseStrategy]:
        """í˜„ì¬ ì¥ì„¸ì— ì í•©í•œ ì „ëµ ëª©ë¡ ë°˜í™˜"""
        codes = self.STRATEGY_MAP[regime]
        return [s for s in self.all_strategies if s.strategy_code in codes]
```

---

## 7. ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—”ì§„

### 7.1 í†µí•© ë¦¬ìŠ¤í¬ ê´€ë¦¬ í”„ë ˆì„ì›Œí¬ [v1.1 ê°•í™”]

```
[ë§¤ë§¤ ì‹ í˜¸] â”€â”€â–¶ [Position Sizer] â”€â”€â–¶ [Grade Allocator] â”€â”€â–¶ [9ë‹¨ê³„ Risk Check] â”€â”€â–¶ [ì£¼ë¬¸ ì‹¤í–‰]
                    â”‚                      â”‚                     â”‚
               Rë°°ìˆ˜ ê¸°ë°˜            ë“±ê¸‰ë³„ ë¹„ì¤‘ í•œë„    [v1.1] VIí™•ì¸ + Global Lock
               í¬ì§€ì…˜ í¬ê¸° ì‚°ì¶œ       í™•ì‹ ë„ ë°˜ì˜         + Margin Guard ì¶”ê°€
```

#### 9ë‹¨ê³„ ë¦¬ìŠ¤í¬ ê²€ì¦ íŒŒì´í”„ë¼ì¸ [v1.1: ê¸°ì¡´ 6ë‹¨ê³„ â†’ 9ë‹¨ê³„]

| ë‹¨ê³„ | í•­ëª© | ê·œì¹™ | ì‹¤íŒ¨ ì‹œ ì¡°ì¹˜ | ê·¼ê±° | v1.1 |
|------|------|------|------------|------|------|
| 1 | ê±°ë˜ë‹¹ ë¦¬ìŠ¤í¬ | ì´ ìë³¸ì˜ 1~2% | í¬ì§€ì…˜ ì¶•ì†Œ | Elder 2% + Van Tharp | ê¸°ì¡´ |
| 2 | ì›”ê°„ ëˆ„ì  ì†ì‹¤ | ì´ ìë³¸ì˜ 6% | í•´ë‹¹ ì›” ë§¤ë§¤ ì¤‘ë‹¨ | Elder 6% Rule | ê¸°ì¡´ |
| 3 | ì¼ì¼ ìµœëŒ€ ì†ì‹¤ | ìë³¸ì˜ 3~5% | ë‹¹ì¼ ë§¤ë§¤ ì¤‘ë‹¨ | Cameron | ê¸°ì¡´ |
| 4 | ë“±ê¸‰ë³„ ë¹„ì¤‘ í•œë„ | A:30%, B:20%, C:10% | ë¹„ì¤‘ ì´ˆê³¼ë¶„ ê±°ë¶€ | Minervini/Elder | ê¸°ì¡´ |
| 5 | ì„¹í„° í¸ì¤‘ | ë™ì¼ ì„¹í„° 40% ì´ë‚´ | ì§„ì… ê±°ë¶€ | í¬íŠ¸í´ë¦¬ì˜¤ ì´ë¡  | ê¸°ì¡´ |
| 6 | íŠ¹ìˆ˜ ì´ë²¤íŠ¸ | ë§Œê¸°ì¼/FOMC ë“± | í˜„ê¸ˆ ë¹„ì¤‘ ì¶”ê°€ í™•ë³´ | Carter/Elder | ê¸°ì¡´ |
| **7** | **ì „ì—­ ì¢…ëª© ë¹„ì¤‘ ì ê¸ˆ** | ì „ ì „ëµ í•©ì‚° ë‹¨ì¼ì¢…ëª© N% ì´ë‚´ | ì¶”ê°€ ë§¤ìˆ˜ ê±°ë¶€ | **ì „ëµ ì¤‘ë³µ ë°©ì§€** | **NEW** |
| **8** | **VI ìƒíƒœ í™•ì¸** | VI ë°œë™/ê·¼ì ‘ ì¢…ëª© ì£¼ë¬¸ ì°¨ë‹¨ | ì£¼ë¬¸ ë³´ë¥˜ ë˜ëŠ” ì·¨ì†Œ | **í•œêµ­ ì‹œì¥ VI ëŒ€ì‘** | **NEW** |
| **9** | **í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ ì‹¤ì‹œê°„ ëŒ€ì¡°** | ì£¼ë¬¸ê¸ˆì•¡ â‰¤ í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ | ì£¼ë¬¸ ê±°ë¶€ (ë¯¸ìˆ˜ ì°¨ë‹¨) | **ë¯¸ìˆ˜/ì‹ ìš© ì›ì²œ ì°¨ë‹¨** | **NEW** |

### 7.2 í¬ì§€ì…˜ ì‚¬ì´ì € (Van Tharp Rë°°ìˆ˜)

```python
class PositionSizer:
    """
    Van Tharp Rë°°ìˆ˜ ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•
    
    ê³µì‹: 1ê±´ë‹¹ íˆ¬ì…ê¸ˆì•¡ = ì´ìë³¸ Ã— ë¦¬ìŠ¤í¬ë¹„ìœ¨(%) Ã· ì†ì ˆí­(%)
    
    ì¥ì„¸ë³„ ë¦¬ìŠ¤í¬ ë¹„ìœ¨:
    - ìƒìŠ¹ì¥: 1.5~2%
    - ë³´í•©ì¥: 1~1.5%
    - í•˜ë½ì¥: 0.5~1%
    """
    
    RISK_BY_REGIME = {
        MarketRegime.STRONG_BULL: 0.02,
        MarketRegime.BULL:        0.018,
        MarketRegime.SIDEWAYS:    0.012,
        MarketRegime.BEAR:        0.008,
        MarketRegime.STRONG_BEAR: 0.005,
    }
    
    def calculate(self, total_capital: float, regime: MarketRegime,
                  entry_price: float, stop_loss: float,
                  grade: str, confidence: int) -> dict:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
        
        # 1. Rë°°ìˆ˜ ê¸°ë°˜ ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸°
        risk_pct = self.RISK_BY_REGIME[regime]
        max_risk_amount = total_capital * risk_pct       # 1R = ìµœëŒ€ ì†ì‹¤ í—ˆìš©ì•¡
        stop_loss_pct = abs(entry_price - stop_loss) / entry_price
        
        if stop_loss_pct == 0:
            return {"error": "ì†ì ˆí­ì´ 0ì…ë‹ˆë‹¤"}
        
        raw_position = max_risk_amount / stop_loss_pct   # íˆ¬ì… ê¸ˆì•¡
        raw_position_pct = raw_position / total_capital * 100
        
        # 2. ë“±ê¸‰ë³„ ìµœëŒ€ ë¹„ì¤‘ ì ìš©
        grade_limits = {"A": 30, "B": 20, "C": 10}
        max_grade_pct = grade_limits.get(grade, 10)
        
        # 3. í™•ì‹ ë„ ë°°ìˆ˜ ì ìš©
        confidence_multiplier = {5: 1.0, 4: 0.75, 3: 0.5}
        multiplier = confidence_multiplier.get(confidence, 0)
        
        if multiplier == 0:
            return {"error": "í™•ì‹ ë„ ë¶€ì¡± (â­2 ì´í•˜) â€” ë§¤ë§¤ ê¸ˆì§€"}
        
        adjusted_pct = min(raw_position_pct, max_grade_pct) * multiplier
        position_amount = total_capital * adjusted_pct / 100
        quantity = int(position_amount / entry_price)
        
        return {
            "position_amount": position_amount,
            "position_pct": adjusted_pct,
            "quantity": quantity,
            "risk_amount_1r": max_risk_amount,         # 1R ê¸ˆì•¡
            "stop_loss_pct": stop_loss_pct * 100,
            "r_multiple_target": [1, 2, 3],            # ëª©í‘œ Rë°°ìˆ˜
            "regime_risk_pct": risk_pct * 100,
            "grade_limit_pct": max_grade_pct,
            "confidence_multiplier": multiplier,
        }
```

### 7.3 íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘

```python
class TrailingStop:
    """
    ë‹¤ì¤‘ ë°©ì‹ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê´€ë¦¬
    
    | ë°©ì‹ | ì„¤ì • ê¸°ì¤€ | ì í•© ìƒí™© |
    |------|----------|----------|
    | ê³ ì • í¼ì„¼íŠ¸ | ê³ ì  ëŒ€ë¹„ -5~8% | ì¼ë°˜ ì¶”ì„¸ ì¶”ì¢… |
    | ì´ë™í‰ê· ì„  | 10ì¼/21ì¼ì„  ì¢…ê°€ ì´íƒˆ | ì¤‘ê¸° ìŠ¤ìœ™ |
    | ATR ê¸°ë°˜ | ê³ ì  ëŒ€ë¹„ 2Ã—ATR(14) | ë³€ë™ì„± ì ì‘í˜• |
    | ìº”ë“¤ íŒ¨í„´ | ì¥ëŒ€ìŒë´‰, ì„ë³„í˜• ì¶œí˜„ | ë‹¨ê¸° ë°˜ì „ ì‹ í˜¸ |
    | ê±°ë˜ëŸ‰ ì´ìƒ | ëŒ€ëŸ‰ê±°ë˜+ì¥ëŒ€ìŒë´‰ | ì„¸ë ¥ ë§¤ë„ ì‹ í˜¸ |
    """
    
    class Method(Enum):
        FIXED_PCT = "fixed_pct"
        MOVING_AVG = "moving_avg"
        ATR_BASED = "atr_based"
        CANDLE_PATTERN = "candle_pattern"
        VOLUME_ANOMALY = "volume_anomaly"
    
    def __init__(self, method: Method, params: dict):
        self.method = method
        self.params = params
        self.highest_price = 0.0  # ë³´ìœ  ì¤‘ ìµœê³ ê°€ ì¶”ì 
    
    def update_and_check(self, current_price: float, 
                          market_data: dict) -> Tuple[bool, str]:
        """ê°€ê²© ì—…ë°ì´íŠ¸ ë° ìŠ¤íƒ‘ ë°œë™ í™•ì¸"""
        self.highest_price = max(self.highest_price, current_price)
        
        if self.method == self.Method.FIXED_PCT:
            stop_price = self.highest_price * (1 - self.params["pct"] / 100)
            if current_price <= stop_price:
                return True, f"íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë°œë™: ê³ ì  {self.highest_price:,.0f} â†’ í˜„ì¬ {current_price:,.0f} (âˆ’{self.params['pct']}%)"
        
        elif self.method == self.Method.ATR_BASED:
            atr = market_data["atr_14"]
            stop_price = self.highest_price - (atr * self.params["multiplier"])
            if current_price <= stop_price:
                return True, f"ATR íŠ¸ë ˆì¼ë§ ë°œë™: ê³ ì  {self.highest_price:,.0f} âˆ’ {self.params['multiplier']}Ã—ATR({atr:,.0f})"
        
        elif self.method == self.Method.MOVING_AVG:
            ma = market_data[f"ma_{self.params['period']}"]
            if current_price < ma:
                return True, f"{self.params['period']}ì¼ì„  ì´íƒˆ ({ma:,.0f}ì›)"
        
        return False, ""
```

### 7.4 ì¼ì¼ ì†ì‹¤ ì°¨ë‹¨ (Kill-Switch)

```python
class DailyKillSwitch:
    """
    ì¼ì¼ ì†ì‹¤ ì°¨ë‹¨ ì‹œìŠ¤í…œ (Cameron ë°©ì‹)
    - ë‹¹ì¼ ìì‚° ëŒ€ë¹„ ì„¤ì • % ì´ìƒ ì†ì‹¤ ì‹œ ë§¤ë§¤ ì¤‘ë‹¨
    - ëª¨ë“  ë¯¸ì²´ê²° ì£¼ë¬¸ ìë™ ì·¨ì†Œ
    - ì‹ ê·œ ì£¼ë¬¸ ì°¨ë‹¨
    """
    
    def __init__(self, daily_loss_limit_pct: float = 3.0):
        self.daily_loss_limit_pct = daily_loss_limit_pct
        self.is_killed = False
        self.start_of_day_capital = 0.0
    
    async def check(self, current_capital: float) -> bool:
        """Kill-Switch ë°œë™ ì—¬ë¶€ í™•ì¸"""
        if self.is_killed:
            return True
        
        daily_pnl_pct = ((current_capital - self.start_of_day_capital) 
                          / self.start_of_day_capital * 100)
        
        if daily_pnl_pct <= -self.daily_loss_limit_pct:
            self.is_killed = True
            logger.critical(
                f"ğŸš¨ KILL-SWITCH ë°œë™: ë‹¹ì¼ ì†ì‹¤ {daily_pnl_pct:.2f}% "
                f"(í•œë„: -{self.daily_loss_limit_pct}%)"
            )
            await self._emergency_shutdown()
            return True
        
        return False
    
    async def _emergency_shutdown(self):
        """ê¸´ê¸‰ ë§¤ë§¤ ì¤‘ë‹¨"""
        # 1. ëª¨ë“  ë¯¸ì²´ê²° ì£¼ë¬¸ ì·¨ì†Œ
        await self.order_manager.cancel_all_pending()
        # 2. ì‹ ê·œ ì£¼ë¬¸ ì°¨ë‹¨
        self.order_manager.block_new_orders = True
        # 3. ì•Œë¦¼ ì „ì†¡
        await self.notifier.send_critical(
            "ğŸš¨ ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼ â€” ë‹¹ì¼ ë§¤ë§¤ ì¤‘ë‹¨\n"
            "Cameron: 'ì˜¤ëŠ˜ ìƒì€ ëˆì€ ë‚´ì¼ ë²Œë©´ ëœë‹¤. ì˜¤ëŠ˜ ë” ìƒìœ¼ë©´ ë‚´ì¼ë„ ìœ„í—˜í•˜ë‹¤'"
        )
```

### 7.5 ë“œë¡œìš°ë‹¤ìš´ ëŒ€ì‘ í”„ë¡œí† ì½œ

```python
class DrawdownProtocol:
    """
    ë‹¨ê³„ë³„ ë“œë¡œìš°ë‹¤ìš´ ëŒ€ì‘ ë§¤ë‰´ì–¼
    
    | ìˆ˜ì¤€ | ìƒíƒœ | ëŒ€ì‘ |
    |------|------|------|
    | -2% (ì¼ì¼) | ğŸŸ¢ ì •ìƒ | ì¶”ê°€ ì§„ì… ì‹œ 50% ì¶•ì†Œ |
    | -3~5% (ì¼ì¼) | ğŸŸ¡ ê²½ê³„ | ë‹¹ì¼ ë§¤ë§¤ ì¤‘ë‹¨ |
    | -6% (ì›”ê°„) | ğŸŸ  ìœ„í—˜ | í•´ë‹¹ ì›” ë§¤ë§¤ ì¤‘ë‹¨ (Elder 6%) |
    | -10% (ëˆ„ì ) | ğŸ”´ ì‹¬ê° | 1ì£¼ ì¤‘ë‹¨ + ì‹œìŠ¤í…œ ì ê²€ + ëª¨ì˜íˆ¬ì ì „í™˜ |
    | -15%+ | âš« ë¹„ìƒ | ë¬´ê¸°í•œ ì¤‘ë‹¨ + ì „ëµ ì¬ê²€ì¦ |
    """
    
    class Level(Enum):
        GREEN = ("GREEN", -2, "ì •ìƒ")
        YELLOW = ("YELLOW", -5, "ê²½ê³„")
        ORANGE = ("ORANGE", -6, "ìœ„í—˜")
        RED = ("RED", -10, "ì‹¬ê°")
        BLACK = ("BLACK", -15, "ë¹„ìƒ")
    
    async def evaluate_and_respond(self, daily_pnl_pct: float, 
                                     monthly_pnl_pct: float,
                                     cumulative_pnl_pct: float) -> dict:
        """ë“œë¡œìš°ë‹¤ìš´ ìˆ˜ì¤€ í‰ê°€ ë° ëŒ€ì‘ ì¡°ì¹˜"""
        
        # ë¹„ìƒ (ëˆ„ì  -15% ì´ìƒ)
        if cumulative_pnl_pct <= -15:
            return await self._respond_black(cumulative_pnl_pct)
        
        # ì‹¬ê° (ëˆ„ì  -10%)
        if cumulative_pnl_pct <= -10:
            return await self._respond_red(cumulative_pnl_pct)
        
        # ìœ„í—˜ (ì›”ê°„ -6%)
        if monthly_pnl_pct <= -6:
            return await self._respond_orange(monthly_pnl_pct)
        
        # ê²½ê³„ (ì¼ì¼ -3~5%)
        if daily_pnl_pct <= -3:
            return await self._respond_yellow(daily_pnl_pct)
        
        # ì •ìƒ
        return {"level": "GREEN", "action": "continue", "position_reduction": 0}
    
    async def _respond_red(self, pnl_pct: float) -> dict:
        """ğŸ”´ ì‹¬ê°: 1ì£¼ì¼ ë§¤ë§¤ ì¤‘ë‹¨"""
        logger.critical(f"ğŸ”´ ë“œë¡œìš°ë‹¤ìš´ ì‹¬ê°: {pnl_pct:.2f}%")
        
        # ëª¨ë“  í¬ì§€ì…˜ ì²­ì‚°
        await self.order_manager.close_all_positions()
        # ë§¤ë§¤ ëª¨ë“œë¥¼ PAPERë¡œ ì „í™˜
        await self.config.set("trade_mode", "PAPER")
        # ë³µê·€ ì¡°ê±´: ëª¨ì˜íˆ¬ì 5ì—°ìŠ¹
        
        await self.notifier.send_critical(
            f"ğŸ”´ ëˆ„ì  ì†ì‹¤ {pnl_pct:.2f}% â€” ìµœì†Œ 1ì£¼ì¼ ë§¤ë§¤ ì¤‘ë‹¨\n"
            f"Van Tharp: 'ì‹œìŠ¤í…œì´ ì•„ë‹ˆë¼ ë‹¹ì‹ ì´ ë¬¸ì œì¼ ìˆ˜ ìˆë‹¤'\n"
            f"ë³µê·€ ì¡°ê±´: ëª¨ì˜íˆ¬ì 5ì—°ìŠ¹ ë‹¬ì„±"
        )
        
        # ë“œë¡œìš°ë‹¤ìš´ ì´ë ¥ ê¸°ë¡
        await self.db.insert_drawdown_log("RED", pnl_pct, "1ì£¼ì¼ ë§¤ë§¤ ì¤‘ë‹¨, ëª¨ì˜íˆ¬ì ì „í™˜")
        
        return {
            "level": "RED",
            "action": "halt_1_week",
            "switch_to_paper": True,
            "recovery_condition": "paper_5_consecutive_wins"
        }
```

### 7.6 ë“±ê¸‰ë³„ ë¹„ì¤‘ ë°°ë¶„ê¸°

```python
class GradeAllocator:
    """
    ì¢…ëª© ë“±ê¸‰ë³„ íˆ¬ì ë¹„ì¤‘ ê´€ë¦¬ (A/B/C)
    
    | ë“±ê¸‰ | ë‹¨ì¼ ì¢…ëª© ìµœëŒ€ | ë™ì‹œ ë³´ìœ  | ë“±ê¸‰ ì´ ë¹„ì¤‘ |
    |------|--------------|----------|------------|
    | Aë“±ê¸‰ | 30% | 1~2ì¢…ëª© | 50% |
    | Bë“±ê¸‰ | 20% | 2~3ì¢…ëª© | 40% |
    | Cë“±ê¸‰ | 10% | 1~2ì¢…ëª© | 15% |
    """
    
    # ì¥ì„¸ë³„ ë¹„ì¤‘ ì¡°ì • í…Œì´ë¸”
    REGIME_ALLOCATION = {
        MarketRegime.STRONG_BULL: {"A": 35, "B": 30, "C": 10, "cash": 30},
        MarketRegime.BULL:        {"A": 30, "B": 25, "C": 5,  "cash": 40},
        MarketRegime.SIDEWAYS:    {"A": 25, "B": 20, "C": 5,  "cash": 50},
        MarketRegime.BEAR:        {"A": 20, "B": 15, "C": 0,  "cash": 65},
        MarketRegime.STRONG_BEAR: {"A": 15, "B": 10, "C": 0,  "cash": 80},
    }
    
    def validate_allocation(self, signal: TradeSignal, 
                             current_positions: List[dict],
                             regime: MarketRegime) -> Tuple[bool, str]:
        """ë¹„ì¤‘ ë°°ë¶„ ìœ íš¨ì„± ê²€ì¦"""
        alloc = self.REGIME_ALLOCATION[regime]
        grade = signal.grade
        
        # 1. ë“±ê¸‰ ì´ ë¹„ì¤‘ í•œë„ í™•ì¸
        current_grade_pct = sum(
            p["position_pct"] for p in current_positions if p["grade"] == grade
        )
        if current_grade_pct + signal.position_pct > alloc[grade]:
            return False, f"{grade}ë“±ê¸‰ ì´ ë¹„ì¤‘ ì´ˆê³¼: {current_grade_pct + signal.position_pct:.1f}% > {alloc[grade]}%"
        
        # 2. ë™ì¼ ì„¹í„° 40% í•œë„ í™•ì¸
        same_sector_pct = sum(
            p["position_pct"] for p in current_positions 
            if p["sector"] == signal.sector
        )
        if same_sector_pct + signal.position_pct > 40:
            return False, f"ë™ì¼ ì„¹í„°({signal.sector}) í¸ì¤‘: {same_sector_pct + signal.position_pct:.1f}% > 40%"
        
        # 3. í˜„ê¸ˆ ë¹„ì¤‘ ìµœì†Œ ìš”ê±´ í™•ì¸
        total_invested = sum(p["position_pct"] for p in current_positions)
        if total_invested + signal.position_pct > (100 - alloc["cash"]):
            return False, f"í˜„ê¸ˆ ë¹„ì¤‘ ë¶€ì¡±: ìµœì†Œ {alloc['cash']}% ìœ ì§€ í•„ìš”"
        
        return True, "OK"
```

### 7.7 ì „ì—­ ì¢…ëª© ë¹„ì¤‘ ì ê¸ˆ (Global Position Lock) [v1.1 NEW]

> **ë¬¸ì œ:** ì—¬ëŸ¬ ì „ëµ(S1~S5)ì´ ë™ì¼ ì¢…ëª©ì— ë™ì‹œ ë§¤ìˆ˜ ì‹ í˜¸ë¥¼ ìƒì„±í•  ê²½ìš°,
> ë“±ê¸‰ë³„ í•œë„ë¥¼ ê°œë³„ì ìœ¼ë¡œëŠ” í†µê³¼í•˜ì§€ë§Œ í•©ì‚° ì‹œ ê³¼ë‹¤ í¸ì¤‘ì´ ë°œìƒí•©ë‹ˆë‹¤.
> **í•´ê²°:** ì „ëµê³¼ ë¬´ê´€í•˜ê²Œ ë‹¨ì¼ ì¢…ëª©ì˜ ì „ì²´ í¬ì§€ì…˜ í•©ì‚°ì„ ê´€ë¦¬í•˜ëŠ” ì „ì—­ ì ê¸ˆ.

```python
class GlobalPositionLock:
    """
    [v1.1 NEW] ì „ì—­ ì¢…ëª©ë³„ ë¹„ì¤‘ í•œë„ ê´€ë¦¬
    
    ì–´ë–¤ ì „ëµ ì¡°í•©ì´ë“  ë‹¨ì¼ ì¢…ëª©ì´ ì´ ìì‚°ì˜ ì„¤ì •ëœ í•œë„ë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
    7ë‹¨ê³„ ë¦¬ìŠ¤í¬ ê²€ì¦ì˜ í•µì‹¬ ëª¨ë“ˆ.
    
    ê·œì¹™:
    - ë‹¨ì¼ ì¢…ëª© ìµœëŒ€ ë¹„ì¤‘: Aë“±ê¸‰ 30%, Bë“±ê¸‰ 20%, Cë“±ê¸‰ 10% (ë“±ê¸‰ë³„ í•˜ë“œ ìº¡)
    - ëª¨ë“  ì „ëµì˜ ë™ì¼ ì¢…ëª© í¬ì§€ì…˜ í•©ì‚°ìœ¼ë¡œ íŒë‹¨
    - í”¼ë¼ë¯¸ë”© í¬í•¨ í•©ì‚°
    """
    
    def __init__(self):
        self._positions: Dict[str, List[dict]] = {}  # {ì¢…ëª©ì½”ë“œ: [í¬ì§€ì…˜ ëª©ë¡]}
        self._lock = asyncio.Lock()
    
    async def check_and_reserve(self, stock_code: str, grade: str,
                                  additional_pct: float, 
                                  strategy_code: str) -> Tuple[bool, str]:
        """
        ì¢…ëª© ë¹„ì¤‘ í™•ì¸ + ì˜ˆì•½ (ì›ìì  ì—°ì‚°)
        
        ì—¬ëŸ¬ ì „ëµì´ ë™ì‹œì— ê°™ì€ ì¢…ëª©ì— ì‹ í˜¸ë¥¼ ë³´ë‚´ë„
        Lockìœ¼ë¡œ ì§ë ¬í™”í•˜ì—¬ ì´ˆê³¼ ì§„ì…ì„ ë°©ì§€í•©ë‹ˆë‹¤.
        """
        async with self._lock:
            # í˜„ì¬ í•´ë‹¹ ì¢…ëª©ì˜ ì „ ì „ëµ í•©ì‚° ë¹„ì¤‘
            current_total_pct = sum(
                p["position_pct"] for p in self._positions.get(stock_code, [])
            )
            
            grade_hard_cap = {"A": 30.0, "B": 20.0, "C": 10.0}
            max_pct = grade_hard_cap.get(grade, 10.0)
            
            if current_total_pct + additional_pct > max_pct:
                return False, (
                    f"ì „ì—­ ì¢…ëª© ë¹„ì¤‘ ì´ˆê³¼: {stock_code} í˜„ì¬ {current_total_pct:.1f}% "
                    f"+ ìš”ì²­ {additional_pct:.1f}% = {current_total_pct + additional_pct:.1f}% "
                    f"> í•œë„ {max_pct}% "
                    f"(ìš”ì²­ ì „ëµ: {strategy_code}, ê¸°ì¡´ ì „ëµ: "
                    f"{[p['strategy'] for p in self._positions.get(stock_code, [])]})"
                )
            
            # ì˜ˆì•½ ë“±ë¡
            self._positions.setdefault(stock_code, []).append({
                "strategy": strategy_code,
                "position_pct": additional_pct,
                "reserved_at": datetime.now()
            })
            
            logger.info(
                f"ğŸ”’ ì¢…ëª© ë¹„ì¤‘ ì˜ˆì•½: {stock_code} [{strategy_code}] "
                f"+{additional_pct:.1f}% â†’ í•©ì‚° {current_total_pct + additional_pct:.1f}%"
            )
            return True, "OK"
    
    async def release(self, stock_code: str, strategy_code: str):
        """í¬ì§€ì…˜ ì²­ì‚° ì‹œ ì˜ˆì•½ í•´ì œ"""
        async with self._lock:
            positions = self._positions.get(stock_code, [])
            self._positions[stock_code] = [
                p for p in positions if p["strategy"] != strategy_code
            ]
    
    def get_stock_exposure(self, stock_code: str) -> dict:
        """ì¢…ëª©ë³„ ì „ëµë³„ ë¹„ì¤‘ í˜„í™© ì¡°íšŒ"""
        positions = self._positions.get(stock_code, [])
        return {
            "stock_code": stock_code,
            "total_pct": sum(p["position_pct"] for p in positions),
            "strategies": [
                {"strategy": p["strategy"], "pct": p["position_pct"]} 
                for p in positions
            ]
        }
```

### 7.8 ë¯¸ìˆ˜/ì‹ ìš© ê±°ë˜ ì°¨ë‹¨ (Margin Guard) [v1.1 NEW]

> **ë¬¸ì œ:** KIS API ì£¼ë¬¸ ì‹œ ê³„ì¢Œ ì„¤ì •ì— ë”°ë¼ ì˜ë„ì¹˜ ì•Šê²Œ ë¯¸ìˆ˜(Leverage)ê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë©°,
> ì´ëŠ” Elder 2% Ruleì„ ì •ë©´ìœ¼ë¡œ ìœ„ë°˜í•©ë‹ˆë‹¤.
> **í•´ê²°:** ì£¼ë¬¸ ì „ í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆì„ ì‹¤ì‹œê°„ ëŒ€ì¡°í•˜ëŠ” í•˜ë“œìŠ¤íƒ‘.

```python
class MarginGuard:
    """
    [v1.1 NEW] í˜„ê¸ˆ 100% ì£¼ë¬¸ ê°•ì œ â€” ë¯¸ìˆ˜/ì‹ ìš© ê±°ë˜ ì›ì²œ ì°¨ë‹¨
    
    9ë‹¨ê³„ ë¦¬ìŠ¤í¬ ê²€ì¦ì˜ ë§ˆì§€ë§‰ ê´€ë¬¸.
    ì£¼ë¬¸ ì§ì „ì— ì‹¤í–‰ë˜ì–´, í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡± ì‹œ ì£¼ë¬¸ì„ ê±°ë¶€í•©ë‹ˆë‹¤.
    
    ê·œì¹™:
    1. ëª¨ë“  ë§¤ìˆ˜ ì£¼ë¬¸ì€ í˜„ê¸ˆ 100% ê²°ì œë§Œ í—ˆìš©
    2. ì£¼ë¬¸ ì „ get_balanceë¡œ ê°€ìš© í˜„ê¸ˆ ì‹¤ì‹œê°„ ì¡°íšŒ
    3. ì£¼ë¬¸ê¸ˆì•¡ + ìˆ˜ìˆ˜ë£Œ > ê°€ìš© í˜„ê¸ˆì´ë©´ ì£¼ë¬¸ ê±°ë¶€
    4. ë¯¸ì²´ê²° ì£¼ë¬¸ì˜ ì˜ˆìƒ ì†Œìš” ê¸ˆì•¡ë„ ì°¨ê°í•˜ì—¬ ê³„ì‚°
    """
    
    COMMISSION_RATE = 0.00015  # ìˆ˜ìˆ˜ë£Œìœ¨ (0.015%)
    TAX_RATE = 0.0018          # ì¦ê¶Œê±°ë˜ì„¸ (0.18%, ë§¤ë„ ì‹œ)
    
    def __init__(self, rest_client: KISRestClient):
        self.rest_client = rest_client
        self._cached_balance: Optional[dict] = None
        self._cache_time: float = 0
        self._pending_reserved: float = 0  # ë¯¸ì²´ê²° ì£¼ë¬¸ ì˜ˆì•½ ê¸ˆì•¡
    
    async def validate_order(self, stock_code: str, quantity: int, 
                              price: float, order_type: str) -> Tuple[bool, str]:
        """
        ì£¼ë¬¸ ì§ì „ í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ ê²€ì¦ (Hard-stop)
        
        ì´ í•¨ìˆ˜ê°€ Falseë¥¼ ë°˜í™˜í•˜ë©´ ì ˆëŒ€ë¡œ ì£¼ë¬¸ì´ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
        """
        if order_type == "SELL":
            return True, "ë§¤ë„ ì£¼ë¬¸ì€ ì˜ˆìˆ˜ê¸ˆ ê²€ì¦ ë¶ˆí•„ìš”"
        
        # 1. í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ ì‹¤ì‹œê°„ ì¡°íšŒ (5ì´ˆ ìºì‹œ)
        available_cash = await self._get_available_cash()
        
        # 2. ì£¼ë¬¸ ê¸ˆì•¡ + ìˆ˜ìˆ˜ë£Œ ê³„ì‚°
        order_amount = price * quantity
        commission = order_amount * self.COMMISSION_RATE
        total_required = order_amount + commission
        
        # 3. ë¯¸ì²´ê²° ì£¼ë¬¸ ì˜ˆì•½ ê¸ˆì•¡ ì°¨ê°
        effective_cash = available_cash - self._pending_reserved
        
        # 4. ê²€ì¦
        if total_required > effective_cash:
            return False, (
                f"âŒ ë¯¸ìˆ˜ ì°¨ë‹¨: ì£¼ë¬¸ê¸ˆì•¡ {total_required:,.0f}ì› > "
                f"ê°€ìš©í˜„ê¸ˆ {effective_cash:,.0f}ì› "
                f"(ì˜ˆìˆ˜ê¸ˆ {available_cash:,.0f} - ë¯¸ì²´ê²°ì˜ˆì•½ {self._pending_reserved:,.0f})\n"
                f"â„¹ï¸ ë¯¸ìˆ˜/ì‹ ìš© ê±°ë˜ëŠ” ì‹œìŠ¤í…œ ì •ì±…ìƒ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
            )
        
        # 5. í†µê³¼ ì‹œ ì˜ˆì•½ ê¸ˆì•¡ ë“±ë¡
        self._pending_reserved += total_required
        logger.info(
            f"âœ… Margin Guard í†µê³¼: {stock_code} {quantity}ì£¼ Ã— {price:,.0f}ì› = "
            f"{total_required:,.0f}ì› (ì”ì—¬ ê°€ìš©: {effective_cash - total_required:,.0f}ì›)"
        )
        return True, "OK"
    
    async def _get_available_cash(self) -> float:
        """í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ ì¡°íšŒ (5ì´ˆ ìºì‹œ)"""
        if self._cached_balance and (time.monotonic() - self._cache_time) < 5.0:
            return self._cached_balance
        
        balance = await self.rest_client.get_balance()
        # ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ (D+2 ì˜ˆìˆ˜ê¸ˆ ê¸°ì¤€)
        available = float(balance.get("output2", [{}])[0].get("dnca_tot_amt", 0))
        
        self._cached_balance = available
        self._cache_time = time.monotonic()
        return available
    
    def release_reservation(self, amount: float):
        """ì£¼ë¬¸ ì²´ê²°/ì·¨ì†Œ ì‹œ ì˜ˆì•½ ê¸ˆì•¡ í•´ì œ"""
        self._pending_reserved = max(0, self._pending_reserved - amount)
    
    @staticmethod
    def enforce_cash_order_params(order_body: dict) -> dict:
        """ì£¼ë¬¸ íŒŒë¼ë¯¸í„°ì— í˜„ê¸ˆ 100% ê°•ì œ ì„¤ì •"""
        order_body["ORD_DVSN"] = "00"          # ì§€ì •ê°€ (ì‹œì¥ê°€ ëŒ€ë¹„ ë¯¸ìˆ˜ ë°©ì§€)
        order_body["CTAC_TLNO"] = ""
        # ì¶”ê°€: ì‹ ìš© ê´€ë ¨ í•„ë“œê°€ ìˆë‹¤ë©´ 0ìœ¼ë¡œ ê°•ì œ
        order_body.setdefault("CDIT_LOAN_DVSN_CD", "00")  # í˜„ê¸ˆ
        return order_body
```

---

## 8. ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ

### 8.1 ë§¤ë§¤ ë³µê¸°ìš© ë¡œê·¸ (ìë™ ë§¤ë§¤ì¼ì§€)

```python
class TradeJournal:
    """
    ìë™ ë§¤ë§¤ì¼ì§€ ì‹œìŠ¤í…œ (Steenbarger + Van Tharp í†µí•©)
    
    ë§¤ ê±°ë˜ ì™„ë£Œ ì‹œ ìë™ ê¸°ë¡:
    - ê±°ë˜ ê¸°ë¡: ì¢…ëª©, ê°€ê²©, ìˆ˜ëŸ‰, Rë°°ìˆ˜, ë³´ìœ ê¸°ê°„, ì§„ì…ì „ëµ
    - ì‹œì¥ ì§€í‘œ ìŠ¤ëƒ…ìƒ·: MA, RSI, VWAP, BB, ê±°ë˜ëŸ‰, ìˆ˜ê¸‰ ë“±
    - ì‹¬ë¦¬ ê¸°ë¡ì€ ì‚¬ìš©ì ì…ë ¥ìœ¼ë¡œ ë³´ì™„ (ì„ íƒì‚¬í•­)
    """
    
    async def record_trade(self, trade: Trade, market_snapshot: dict):
        """ë§¤ë§¤ ì™„ë£Œ ì‹œ ìë™ ê¸°ë¡"""
        
        # Rë°°ìˆ˜ ê³„ì‚°
        risk_1r = abs(trade.entry_price - trade.stop_loss) * trade.quantity
        actual_pnl = (trade.exit_price - trade.entry_price) * trade.quantity
        r_multiple = actual_pnl / risk_1r if risk_1r > 0 else 0
        
        journal_entry = {
            "trade_id": trade.trade_id,
            "stock_code": trade.stock_code,
            "stock_grade": trade.grade,
            "entry_strategy": trade.strategy_code,
            "entry_price": trade.entry_price,
            "exit_price": trade.exit_price,
            "quantity": trade.quantity,
            "pnl_amount": actual_pnl,
            "r_multiple": r_multiple,
            "holding_period": trade.holding_period,
            "checklist_score": trade.checklist_score,
            # ì‹œì¥ ì§€í‘œ ìŠ¤ëƒ…ìƒ· (ë§¤ë§¤ ì‹œì )
            "snapshot_json": {
                "ma_5": market_snapshot["ma_5"],
                "ma_20": market_snapshot["ma_20"],
                "ma_50": market_snapshot["ma_50"],
                "rsi_14": market_snapshot["rsi_14"],
                "vwap": market_snapshot["vwap"],
                "bollinger": market_snapshot["bollinger"],
                "volume": market_snapshot["volume"],
                "volume_ratio": market_snapshot["volume_ratio"],  # í‰ê·  ëŒ€ë¹„ ë°°ìˆ˜
                "foreign_flow": market_snapshot["foreign_flow"],
                "inst_flow": market_snapshot["inst_flow"],
                "kospi_close": market_snapshot["kospi_close"],
                "market_regime": market_snapshot["regime"],
            },
            "market_regime": market_snapshot["regime"],
        }
        
        await self.db.insert_journal(journal_entry)
        
        # Rë°°ìˆ˜ ì´ìƒ ê°ì§€ ê²½ê³ 
        if r_multiple < -1:
            logger.warning(
                f"âš ï¸ ê³¼ëŒ€ ì†ì‹¤ ê²½ê³ : {trade.stock_code} Rë°°ìˆ˜ = {r_multiple:.2f} "
                f"(-1R ì´ˆê³¼ â€” ì†ì ˆ ê·œì¹™ ìœ„ë°˜ ê°€ëŠ¥ì„±)"
            )
```

### 8.2 ì„±ê³¼ ë¶„ì„ê¸°

```python
class PerformanceAnalyzer:
    """
    Rë°°ìˆ˜, SQN, ìŠ¹ë¥  ë“± ì„±ê³¼ ë¶„ì„
    
    SQN = (Rë°°ìˆ˜ í‰ê·  Ã· Rë°°ìˆ˜ í‘œì¤€í¸ì°¨) Ã— âˆšë§¤ë§¤íšŸìˆ˜
    
    | SQN | í’ˆì§ˆ | ëŒ€ì‘ |
    |-----|------|------|
    | <1.6 | ë‚˜ì¨ | ì „ëµ ì¬ê²€í†  |
    | 1.6~2.0 | í‰ê·  ì´í•˜ | ê°œì„  í•„ìš” |
    | 2.0~3.0 | ì–‘í˜¸ | ì •ìƒ ìš´ìš© |
    | 3.0~5.0 | ìš°ìˆ˜ | ê³µê²©ì  í™•ëŒ€ ê°€ëŠ¥ |
    | 5.0~7.0 | íƒì›” | ë§¤ìš° ë“œë¬¸ ìˆ˜ì¤€ |
    | >7.0 | ì„±ë°° | ê³¼ìµœì í™” ì ê²€ |
    """
    
    def calculate_sqn(self, r_multiples: List[float]) -> dict:
        """SQN (System Quality Number) ê³„ì‚°"""
        n = len(r_multiples)
        if n < 30:
            return {"sqn": None, "note": f"ìµœì†Œ 30íšŒ í•„ìš” (í˜„ì¬ {n}íšŒ)"}
        
        avg_r = sum(r_multiples) / n
        std_r = (sum((r - avg_r) ** 2 for r in r_multiples) / n) ** 0.5
        
        if std_r == 0:
            return {"sqn": None, "note": "í‘œì¤€í¸ì°¨ 0"}
        
        sqn = (avg_r / std_r) * (n ** 0.5)
        
        quality = self._interpret_sqn(sqn)
        
        return {
            "sqn": round(sqn, 4),
            "avg_r": round(avg_r, 4),
            "std_r": round(std_r, 4),
            "trade_count": n,
            "quality": quality,
            "win_rate": sum(1 for r in r_multiples if r > 0) / n * 100,
        }
    
    async def generate_weekly_review(self, week_start: date) -> dict:
        """ì£¼ê°„ ì„±ê³¼ ë¦¬ë·° ìë™ ìƒì„±"""
        trades = await self.db.get_trades_in_range(week_start, week_start + timedelta(days=7))
        r_multiples = [t.r_multiple for t in trades]
        
        return {
            "period": f"{week_start} ~ {week_start + timedelta(days=6)}",
            "total_trades": len(trades),
            "win_count": sum(1 for r in r_multiples if r > 0),
            "loss_count": sum(1 for r in r_multiples if r <= 0),
            "win_rate": sum(1 for r in r_multiples if r > 0) / max(len(trades), 1) * 100,
            "avg_r_multiple": sum(r_multiples) / max(len(r_multiples), 1),
            "max_r": max(r_multiples, default=0),
            "min_r": min(r_multiples, default=0),
            "rule_violations": sum(1 for t in trades if not t.rule_compliance),
            "best_trade": self._get_best_trade(trades),
            "worst_trade": self._get_worst_trade(trades),
            "strategy_breakdown": self._strategy_performance(trades),
        }
```

### 8.3 ì•Œë¦¼ ì„œë¹„ìŠ¤

```python
class NotificationService:
    """
    ë§¤ë§¤ ì•Œë¦¼ í†µí•© ì„œë¹„ìŠ¤
    - ë§¤ë§¤ ì²´ê²° ì•Œë¦¼ (ë§¤ìˆ˜/ë§¤ë„/ì†ì ˆ/ìµì ˆ)
    - ë¦¬ìŠ¤í¬ ê²½ê³  (Kill-Switch, ë“œë¡œìš°ë‹¤ìš´)
    - ì¼ê°„/ì£¼ê°„ ì„±ê³¼ ë¦¬í¬íŠ¸
    - íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ì•Œë¦¼ (FOMC, ë§Œê¸°ì¼ ë“±)
    """
    
    class Priority(Enum):
        INFO = "info"           # ì¼ë°˜ ë§¤ë§¤ ì²´ê²°
        WARNING = "warning"     # ì—°ì† ì†ì‹¤, ë¹„ì¤‘ ì´ˆê³¼ ë“±
        CRITICAL = "critical"   # Kill-Switch, ë“œë¡œìš°ë‹¤ìš´ ì‹¬ê°
    
    async def send_trade_notification(self, trade: Trade, r_multiple: float):
        """ë§¤ë§¤ ì²´ê²° ì•Œë¦¼"""
        emoji = "ğŸ“ˆ" if trade.pnl_amount >= 0 else "ğŸ“‰"
        
        message = (
            f"{emoji} [{trade.strategy_code}] {trade.stock_name} "
            f"{'ë§¤ìˆ˜' if trade.order_type == 'BUY' else 'ë§¤ë„'}\n"
            f"ê°€ê²©: {trade.exit_price:,.0f}ì› | ìˆ˜ëŸ‰: {trade.quantity}ì£¼\n"
            f"ì†ìµ: {trade.pnl_amount:+,.0f}ì› ({trade.pnl_percent:+.2f}%)\n"
            f"Rë°°ìˆ˜: {r_multiple:+.2f}R"
        )
        
        await self._send(message, self.Priority.INFO)
    
    async def send_event_alert(self, event: dict):
        """íŠ¹ìˆ˜ ì´ë²¤íŠ¸ ì‚¬ì „ ì•Œë¦¼"""
        message = (
            f"ğŸ“… [{event['event_type']}] {event['event_name']}\n"
            f"ì¼ì‹œ: {event['event_date']}\n"
            f"ì˜í–¥: {event['market_impact']}\n"
            f"ëŒ€ì‘: {event['trading_action']}\n"
            f"í˜„ê¸ˆ ì¶”ê°€ í™•ë³´: +{event['cash_adjust_pct']}%"
        )
        await self._send(message, self.Priority.WARNING)
```

---

## 9. AI ìì—°ì–´ ì²˜ë¦¬ (MCP í†µí•©)

### 9.1 MCP í•¸ë“¤ëŸ¬ [v1.1 ê°•í™”: Human-in-the-loop í•„ìˆ˜]

> **[v1.1 í•µì‹¬ ë³€ê²½] ëª¨ë“  AI ê¸°ë°˜ ë§¤ë§¤ ëª…ë ¹ì€ ì¦‰ì‹œ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**
> ìì—°ì–´ íŒŒì‹± ì˜¤ì‘ë™ìœ¼ë¡œ ì¸í•œ ì˜¤ë§¤ë§¤ ìœ„í—˜ì„ ì°¨ë‹¨í•˜ê¸° ìœ„í•´,
> ë©”ì‹ ì €(Slack/Telegram)ë¥¼ í†µí•´ ì‚¬ìš©ìê°€ 'ìŠ¹ì¸(Approve)' ë²„íŠ¼ì„ ëˆŒëŸ¬ì•¼ë§Œ
> ì‹¤ì œ APIê°€ í˜¸ì¶œë˜ëŠ” **Human-in-the-loop** êµ¬ì¡°ë¥¼ ì±„íƒí•©ë‹ˆë‹¤.

```python
class MCPHandler:
    """
    [v1.1 ê°•í™”] MCP ìì—°ì–´ ë§¤ë§¤ ëª…ë ¹ ì²˜ë¦¬ â€” Human-in-the-loop í•„ìˆ˜
    
    ë³€ê²½ì‚¬í•­ (v1.0 â†’ v1.1):
    - ëª¨ë“  ë§¤ë§¤ ëª…ë ¹ì€ approval_gatewayë¥¼ í†µí•œ ì‚¬ìš©ì ìŠ¹ì¸ í›„ ì‹¤í–‰
    - ì¡°íšŒì„± ëª…ë ¹(ìƒíƒœ, ì„±ê³¼)ë§Œ ì¦‰ì‹œ ì‹¤í–‰ ê°€ëŠ¥
    - ìŠ¹ì¸ ëŒ€ê¸° ì‹œê°„ ì´ˆê³¼ (5ë¶„) â†’ ìë™ íŒŒê¸°
    - íŒŒì‹± ê²°ê³¼ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ ë³€í™˜í•˜ì—¬ ìŠ¹ì¸ ìš”ì²­
    """
    
    SUPPORTED_INTENTS = {
        "conditional_buy":  "ì¡°ê±´ë¶€ ë§¤ìˆ˜",
        "conditional_sell": "ì¡°ê±´ë¶€ ë§¤ë„",
        "modify_stop_loss": "ì†ì ˆê°€ ë³€ê²½",
        "status_inquiry":   "ìƒíƒœ ì¡°íšŒ",
        "performance_report": "ì„±ê³¼ ë³´ê³ ",
        "strategy_setup":   "ì „ëµ ì„¤ì •",
        "cancel_order":     "ì£¼ë¬¸ ì·¨ì†Œ",
    }
    
    # [v1.1] ì¦‰ì‹œ ì‹¤í–‰ í—ˆìš© vs ìŠ¹ì¸ í•„ìš” ë¶„ë¥˜
    IMMEDIATE_INTENTS = {"status_inquiry", "performance_report"}  # ì¡°íšŒë§Œ ì¦‰ì‹œ
    APPROVAL_REQUIRED_INTENTS = {
        "conditional_buy", "conditional_sell", 
        "modify_stop_loss", "strategy_setup", "cancel_order"
    }  # ë§¤ë§¤ ê´€ë ¨ = ë¬´ì¡°ê±´ ìŠ¹ì¸ í•„ìš”
    
    APPROVAL_TIMEOUT_SEC = 300  # ìŠ¹ì¸ ëŒ€ê¸° 5ë¶„ ì´ˆê³¼ ì‹œ ìë™ íŒŒê¸°
    
    def __init__(self, approval_gateway: ApprovalGateway, ...):
        self.approval_gateway = approval_gateway
    
    async def process_command(self, natural_language: str) -> dict:
        """[v1.1] ìì—°ì–´ â†’ íŒŒì‹± â†’ ìŠ¹ì¸ ìš”ì²­ â†’ ì‹¤í–‰"""
        
        # 1. ì˜ë„ íŒŒì‹±
        intent = await self.nlp_parser.parse_intent(natural_language)
        
        # 2. ì—”í‹°í‹° ì¶”ì¶œ
        entities = await self.nlp_parser.extract_entities(natural_language)
        
        # 3. ëª…ë ¹ ê²€ì¦
        validation = self._validate_command(intent, entities)
        if not validation["is_valid"]:
            return {"status": "error", "message": validation["error"]}
        
        # 4. [v1.1] ì¡°íšŒì„± ëª…ë ¹ â†’ ì¦‰ì‹œ ì‹¤í–‰
        if intent in self.IMMEDIATE_INTENTS:
            return await self._execute_command(intent, entities)
        
        # 5. [v1.1] ë§¤ë§¤ ê´€ë ¨ ëª…ë ¹ â†’ Human-in-the-loop (ëª¨ë“œ ë¬´ê´€)
        approval_request = {
            "command_id": str(uuid.uuid4()),
            "intent": intent,
            "intent_kr": self.SUPPORTED_INTENTS[intent],
            "entities": entities,
            "parsed_summary": self._format_command_for_human(intent, entities),
            "raw_input": natural_language,
            "requested_at": datetime.now().isoformat(),
            "expires_at": (
                datetime.now() + timedelta(seconds=self.APPROVAL_TIMEOUT_SEC)
            ).isoformat(),
        }
        
        # 6. [v1.1] ë©”ì‹ ì €ë¡œ ìŠ¹ì¸ ìš”ì²­ ì „ì†¡
        sent = await self.approval_gateway.request_approval(approval_request)
        
        return {
            "status": "awaiting_approval",
            "message": (
                f"ğŸ“‹ ì•„ë˜ ëª…ë ¹ì— ëŒ€í•œ ìŠ¹ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.\n"
                f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                f"ì›ë³¸: \"{natural_language}\"\n"
                f"í•´ì„: {approval_request['parsed_summary']}\n"
                f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                f"â± {self.APPROVAL_TIMEOUT_SEC // 60}ë¶„ ë‚´ Slack/Telegramì—ì„œ "
                f"[ìŠ¹ì¸] ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”."
            ),
            "command_id": approval_request["command_id"],
            "channel": sent["channel"],
        }
    
    async def on_approval_received(self, command_id: str, approved: bool):
        """[v1.1] ì‚¬ìš©ì ìŠ¹ì¸/ê±°ë¶€ ì½œë°± (ë©”ì‹ ì €ì—ì„œ í˜¸ì¶œ)"""
        command = self._pending_commands.get(command_id)
        if not command:
            return {"status": "expired", "message": "ìŠ¹ì¸ ì‹œê°„ ì´ˆê³¼ â€” ëª…ë ¹ì´ íŒŒê¸°ë˜ì—ˆìŠµë‹ˆë‹¤"}
        
        if not approved:
            del self._pending_commands[command_id]
            return {"status": "rejected", "message": "ì‚¬ìš©ìê°€ ëª…ë ¹ì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤"}
        
        # ìŠ¹ì¸ë¨ â†’ ì‹¤í–‰
        result = await self._execute_command(command["intent"], command["entities"])
        del self._pending_commands[command_id]
        
        logger.info(f"âœ… ìŠ¹ì¸ëœ ëª…ë ¹ ì‹¤í–‰: {command_id} â€” {command['intent']}")
        return result
    
    def _format_command_for_human(self, intent: str, entities: dict) -> str:
        """íŒŒì‹± ê²°ê³¼ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í•œêµ­ì–´ë¡œ ë³€í™˜"""
        if intent == "conditional_buy":
            return (
                f"ğŸ“ˆ ì¡°ê±´ë¶€ ë§¤ìˆ˜: {entities.get('stock_name', '?')}({entities.get('stock_code', '?')}) "
                f"{entities.get('threshold', '?')}% ìƒìŠ¹ ì‹œ {entities.get('quantity', '?')}ì£¼ ë§¤ìˆ˜"
            )
        elif intent == "conditional_sell":
            return (
                f"ğŸ“‰ ì¡°ê±´ë¶€ ë§¤ë„: {entities.get('stock_name', '?')}({entities.get('stock_code', '?')}) "
                f"{entities.get('threshold', '?')}% í•˜ë½ ì‹œ {entities.get('quantity', '?')}ì£¼ ë§¤ë„"
            )
        elif intent == "modify_stop_loss":
            return f"ğŸ›¡ ì†ì ˆê°€ ë³€ê²½: {entities.get('target', 'ì „ì²´')} â†’ {entities.get('stop_pct', '?')}%"
        else:
            return f"{self.SUPPORTED_INTENTS.get(intent, intent)}: {entities}"
    
    async def _execute_command(self, intent: str, entities: dict) -> dict:
        """[ìŠ¹ì¸ í›„] íŒŒì‹±ëœ ëª…ë ¹ ì‹¤í–‰"""
        
        if intent == "conditional_buy":
            stock_code = entities["stock_code"]
            quantity = entities["quantity"]
            
            await self.condition_monitor.register({
                "stock_code": stock_code,
                "condition_type": "price_change_pct",
                "threshold": entities["threshold"],
                "direction": entities["direction"],
                "action": "BUY",
                "quantity": quantity,
            })
            
            return {
                "status": "registered",
                "message": f"{entities['stock_name']} {entities['threshold']}% ìƒìŠ¹ ì‹œ "
                           f"{quantity}ì£¼ ë§¤ìˆ˜ ì¡°ê±´ ë“±ë¡ ì™„ë£Œ"
            }
```

#### ApprovalGateway â€” ìŠ¹ì¸ ê²Œì´íŠ¸ì›¨ì´ [v1.1 NEW]

```python
class ApprovalGateway:
    """
    [v1.1 NEW] ë§¤ë§¤ ëª…ë ¹ ìŠ¹ì¸ ê²Œì´íŠ¸ì›¨ì´
    
    Slack/Telegramìœ¼ë¡œ ìŠ¹ì¸ ìš”ì²­ì„ ì „ì†¡í•˜ê³ ,
    ì‚¬ìš©ìì˜ Approve/Reject ë²„íŠ¼ í´ë¦­ì„ ìˆ˜ì‹ í•©ë‹ˆë‹¤.
    """
    
    def __init__(self, notifier: Notifier, mcp_handler: MCPHandler):
        self.notifier = notifier
        self.mcp_handler = mcp_handler
    
    async def request_approval(self, command: dict) -> dict:
        """ë©”ì‹ ì €ë¡œ ìŠ¹ì¸ ìš”ì²­ ì „ì†¡ (ì¸í„°ë™í‹°ë¸Œ ë²„íŠ¼ í¬í•¨)"""
        message = {
            "text": f"ğŸ¤– AI ë§¤ë§¤ ëª…ë ¹ ìŠ¹ì¸ ìš”ì²­\n\n{command['parsed_summary']}",
            "attachments": [
                {
                    "text": f"ì›ë³¸ ëª…ë ¹: \"{command['raw_input']}\"",
                    "callback_id": f"mcp_approval_{command['command_id']}",
                    "actions": [
                        {
                            "name": "approve",
                            "text": "âœ… ìŠ¹ì¸",
                            "type": "button",
                            "value": command["command_id"],
                            "style": "primary"
                        },
                        {
                            "name": "reject",
                            "text": "âŒ ê±°ë¶€",
                            "type": "button",
                            "value": command["command_id"],
                            "style": "danger"
                        }
                    ]
                }
            ]
        }
        
        channel = await self.notifier.send_interactive(message)
        
        # íƒ€ì„ì•„ì›ƒ ìŠ¤ì¼€ì¤„ ë“±ë¡
        asyncio.create_task(
            self._timeout_handler(command["command_id"], 
                                   float(command.get("timeout", 300)))
        )
        
        return {"channel": channel, "command_id": command["command_id"]}
    
    async def _timeout_handler(self, command_id: str, timeout: float):
        """ìŠ¹ì¸ ë¯¸ì‘ë‹µ ì‹œ ìë™ íŒŒê¸°"""
        await asyncio.sleep(timeout)
        result = await self.mcp_handler.on_approval_received(command_id, approved=False)
        if result.get("status") != "expired":
            logger.info(f"â° ìŠ¹ì¸ íƒ€ì„ì•„ì›ƒ â€” ëª…ë ¹ ìë™ íŒŒê¸°: {command_id}")
```

### 9.2 ìì—°ì–´ íŒŒì„œ

```python
class NLPParser:
    """
    ìì—°ì–´ ë§¤ë§¤ ëª…ë ¹ íŒŒì‹± ì—”ì§„
    - ì¢…ëª©ëª… â†’ ì¢…ëª©ì½”ë“œ ë§¤í•‘
    - ê°€ê²© ì¡°ê±´ ì¶”ì¶œ (% ë³€ë™, ì ˆëŒ€ê°€ê²©)
    - ìˆ˜ëŸ‰/ê¸ˆì•¡ ì¶”ì¶œ
    - ì „ëµëª… ì¸ì‹
    """
    
    STOCK_ALIASES = {
        "ì‚¼ì„±ì „ì": "005930", "ì‚¼ì „": "005930",
        "SKí•˜ì´ë‹‰ìŠ¤": "000660", "í•˜ì´ë‹‰ìŠ¤": "000660",
        "í˜„ëŒ€ì°¨": "005380", "í˜„ëŒ€ìë™ì°¨": "005380",
        # ... (ì£¼ìš” ì¢…ëª© ì‚¬ì „)
    }
    
    CONDITION_PATTERNS = [
        (r"(\d+(?:\.\d+)?)\s*%\s*(ì˜¤ë¥´|ìƒìŠ¹|ì˜¬ë¼)", "price_up_pct"),
        (r"(\d+(?:\.\d+)?)\s*%\s*(ë‚´ë¦¬|í•˜ë½|ë–¨ì–´)", "price_down_pct"),
        (r"(\d+(?:,\d+)?)\s*ì›\s*(ì´ìƒ|ë„˜ìœ¼|ëŒíŒŒ)", "price_above"),
        (r"(\d+(?:,\d+)?)\s*ì›\s*(ì´í•˜|ë°‘ìœ¼)", "price_below"),
    ]
    
    async def parse_intent(self, text: str) -> str:
        """ì˜ë„ ë¶„ë¥˜"""
        if any(kw in text for kw in ["ì‚¬ì¤˜", "ë§¤ìˆ˜", "ì‚¬"]):
            return "conditional_buy" if "ë©´" in text or "ì‹œ" in text else "buy"
        elif any(kw in text for kw in ["íŒ”ì•„", "ë§¤ë„", "íŒ”"]):
            return "conditional_sell" if "ë©´" in text or "ì‹œ" in text else "sell"
        elif any(kw in text for kw in ["ì†ì ˆ", "ìŠ¤íƒ‘"]):
            return "modify_stop_loss"
        elif any(kw in text for kw in ["ì„±ê³¼", "ìˆ˜ìµ", "ê²°ê³¼"]):
            return "performance_report"
        elif any(kw in text for kw in ["ìƒíƒœ", "ì”ê³ ", "í¬ì§€ì…˜"]):
            return "status_inquiry"
        return "unknown"
```

---

## 10. ì˜ˆì™¸ ì²˜ë¦¬ ë° ì¥ì•  ëŒ€ì‘

### 10.1 ì˜ˆì™¸ ì²˜ë¦¬ ì‹œë‚˜ë¦¬ì˜¤

| ì‹œë‚˜ë¦¬ì˜¤ | ê°ì§€ ë°©ë²• | ëŒ€ì‘ ì¡°ì¹˜ | ë³µêµ¬ ì „ëµ |
|---------|----------|----------|----------|
| **ë„¤íŠ¸ì›Œí¬ ë‹¨ì ˆ** | aiohttp.ClientError, TimeoutError | ë¯¸ì²´ê²° ì£¼ë¬¸ ìƒíƒœ í™•ì¸ í›„ ì¬ì—°ê²° | Exponential Backoff (ìµœëŒ€ 60ì´ˆ) |
| **ì¦ê¶Œì‚¬ ì„œë²„ ì ê²€** | HTTP 503, íŠ¹ì • ì‹œê°„ëŒ€ (06:30~08:00) | ë§¤ë§¤ ì¼ì‹œ ì¤‘ì§€, ì ê²€ ì™„ë£Œ í›„ ìë™ ì¬ê°œ | ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ìë™ ë³µêµ¬ |
| **ì£¼ë¬¸ ì‹¤íŒ¨** | rt_cd != "0", msg_cd ë¶„ì„ | ì‹¤íŒ¨ ì›ì¸ë³„ ë¶„ê¸° ì²˜ë¦¬ (ì•„ë˜ ìƒì„¸) | ì¬ì£¼ë¬¸ ë˜ëŠ” í¬ê¸° |
| **í† í° ë§Œë£Œ** | 401 Unauthorized | ì¦‰ì‹œ í† í° ì¬ë°œê¸‰ í›„ ì¬ì‹œë„ | TokenManager ìë™ ê°±ì‹  |
| **WebSocket ì—°ê²° ëŠê¹€** | ConnectionClosed | êµ¬ë… ëª©ë¡ ë³´ì¡´ í›„ ì¬ì—°ê²° | ì¬ì—°ê²° í›„ êµ¬ë… ìë™ ë³µì› |
| **ë°ì´í„° ëˆ„ë½** | ì‹œì„¸ ë°ì´í„° None/ë¹„ì •ìƒê°’ | í•´ë‹¹ ì¢…ëª© ì‹ í˜¸ ìƒì„± ìŠ¤í‚µ | REST API ë³´ì¡° ì¡°íšŒ |
| **DB ì¥ì• ** | OperationalError | ë§¤ë§¤ ì¤‘ë‹¨ (ê¸°ë¡ ë¶ˆê°€ ì‹œ ë§¤ë§¤ ë¶ˆê°€) | íŒŒì¼ ë¡œê·¸ ëŒ€ì²´ í›„ ë³µêµ¬ ì‹œ ë™ê¸°í™” |

### 10.2 ì£¼ë¬¸ ìƒíƒœ ì „ì´ ê´€ë¦¬ (Order State Machine) [v1.1 NEW]

> **[v1.1 ë³€ê²½] ì£¼ë¬¸ ì „ì†¡ í›„ 'ì²´ê²° ì™„ë£Œ'ê¹Œì§€ì˜ ìƒíƒœ ì „ì´ê°€ ëª…ì‹œì ìœ¼ë¡œ ê´€ë¦¬ë˜ì§€ ì•Šì•„,**
> ë¯¸ì²´ê²° ì£¼ë¬¸ì´ ìì‚°(Margin)ì„ ë¬¶ì–´ë²„ë¦¬ëŠ” ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤.
> State Machine íŒ¨í„´ìœ¼ë¡œ ëª¨ë“  ì£¼ë¬¸ì˜ ìƒëª…ì£¼ê¸°ë¥¼ ì¶”ì í•©ë‹ˆë‹¤.

```python
class OrderState(Enum):
    """ì£¼ë¬¸ ìƒíƒœ ì „ì´ ë‹¤ì´ì–´ê·¸ë¨:
    
    CREATED â”€â”€ì „ì†¡â”€â”€â–¶ SUBMITTED â”€â”€ë¶€ë¶„ì²´ê²°â”€â”€â–¶ PARTIAL_FILLED â”€â”€ì”ëŸ‰ì²´ê²°â”€â”€â–¶ FILLED
       â”‚                  â”‚                         â”‚
       â”‚                  â”œâ”€â”€ì „ëŸ‰ì²´ê²°â”€â”€â–¶ FILLED      â”œâ”€â”€íƒ€ì„ì•„ì›ƒâ”€â”€â–¶ CANCEL_REQUESTED
       â”‚                  â”‚                         â”‚
       â”‚                  â”œâ”€â”€íƒ€ì„ì•„ì›ƒâ”€â”€â–¶ CANCEL_REQUESTED â”€â”€ì·¨ì†Œí™•ì¸â”€â”€â–¶ CANCELLED
       â”‚                  â”‚                         â”‚
       â”‚                  â”œâ”€â”€ê±°ë¶€â”€â”€â–¶ REJECTED        â”œâ”€â”€ì •ì •â”€â”€â–¶ AMEND_REQUESTED
       â”‚                  â”‚                         â”‚
       â”‚                  â””â”€â”€ì—ëŸ¬â”€â”€â–¶ ERROR           â””â”€â”€ì²´ê²°â”€â”€â–¶ FILLED
       â”‚
       â””â”€â”€ê²€ì¦ì‹¤íŒ¨â”€â”€â–¶ REJECTED
    """
    CREATED = "ìƒì„±"
    SUBMITTED = "ì „ì†¡ì™„ë£Œ"
    PARTIAL_FILLED = "ë¶€ë¶„ì²´ê²°"
    FILLED = "ì²´ê²°ì™„ë£Œ"
    CANCEL_REQUESTED = "ì·¨ì†Œìš”ì²­"
    CANCELLED = "ì·¨ì†Œì™„ë£Œ"
    AMEND_REQUESTED = "ì •ì •ìš”ì²­"
    REJECTED = "ê±°ë¶€"
    EXPIRED = "ë§Œë£Œ"       # [v1.1] ìœ íš¨ì‹œê°„ ì´ˆê³¼
    ERROR = "ì˜¤ë¥˜"

class OrderStateMachine:
    """
    [v1.1 NEW] ì£¼ë¬¸ ìƒëª…ì£¼ê¸° ê´€ë¦¬
    
    ê¸°ëŠ¥:
    1. ëª¨ë“  ì£¼ë¬¸ì˜ í˜„ì¬ ìƒíƒœ ì¶”ì 
    2. ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœ ì „ì´ ì°¨ë‹¨ (ì˜ˆ: FILLED â†’ CANCELLED)
    3. ë¯¸ì²´ê²° ì£¼ë¬¸ ì˜ˆì•½ ê¸ˆì•¡ì„ MarginGuardì™€ ë™ê¸°í™”
    4. ìƒíƒœ ë³€ê²½ ì‹œ ì´ë²¤íŠ¸ ë°œí–‰ (ì½œë°±)
    """
    
    # í—ˆìš©ëœ ìƒíƒœ ì „ì´ ë§µ
    VALID_TRANSITIONS = {
        OrderState.CREATED: {OrderState.SUBMITTED, OrderState.REJECTED},
        OrderState.SUBMITTED: {
            OrderState.PARTIAL_FILLED, OrderState.FILLED,
            OrderState.CANCEL_REQUESTED, OrderState.REJECTED, OrderState.ERROR
        },
        OrderState.PARTIAL_FILLED: {
            OrderState.FILLED, OrderState.CANCEL_REQUESTED, OrderState.AMEND_REQUESTED
        },
        OrderState.CANCEL_REQUESTED: {OrderState.CANCELLED, OrderState.FILLED},
        OrderState.AMEND_REQUESTED: {OrderState.SUBMITTED, OrderState.REJECTED},
    }
    
    def __init__(self, margin_guard: MarginGuard):
        self._orders: Dict[str, dict] = {}  # {order_id: {state, order_data, history}}
        self.margin_guard = margin_guard
        self._callbacks: List[Callable] = []
    
    def create_order(self, order_id: str, order_data: dict) -> dict:
        """ì£¼ë¬¸ ìƒì„± ë° ìƒíƒœ ì´ˆê¸°í™”"""
        self._orders[order_id] = {
            "state": OrderState.CREATED,
            "data": order_data,
            "created_at": datetime.now(),
            "updated_at": datetime.now(),
            "history": [{"state": "CREATED", "at": datetime.now()}],
        }
        return self._orders[order_id]
    
    async def transition(self, order_id: str, new_state: OrderState, 
                          metadata: dict = None):
        """ìƒíƒœ ì „ì´ ì‹¤í–‰ (ìœ íš¨ì„± ê²€ì¦ í¬í•¨)"""
        order = self._orders.get(order_id)
        if not order:
            raise ValueError(f"ì£¼ë¬¸ {order_id} ì¡´ì¬í•˜ì§€ ì•ŠìŒ")
        
        current = order["state"]
        valid_next = self.VALID_TRANSITIONS.get(current, set())
        
        if new_state not in valid_next:
            logger.error(
                f"âŒ ì˜ëª»ëœ ìƒíƒœ ì „ì´: {order_id} {current.value} â†’ {new_state.value}"
            )
            raise InvalidStateTransition(current, new_state)
        
        # ìƒíƒœ ì „ì´ ì‹¤í–‰
        order["state"] = new_state
        order["updated_at"] = datetime.now()
        order["history"].append({
            "state": new_state.value, "at": datetime.now(),
            "metadata": metadata
        })
        
        # ë¶€ìˆ˜ íš¨ê³¼: ì²´ê²°/ì·¨ì†Œ ì‹œ MarginGuard ì˜ˆì•½ í•´ì œ
        if new_state in (OrderState.FILLED, OrderState.CANCELLED, OrderState.EXPIRED):
            reserved_amount = order["data"].get("reserved_amount", 0)
            self.margin_guard.release_reservation(reserved_amount)
            logger.info(f"ğŸ’° ì˜ˆì•½ í•´ì œ: {order_id} {reserved_amount:,.0f}ì›")
        
        # ì½œë°± ì‹¤í–‰
        for cb in self._callbacks:
            await cb(order_id, current, new_state, metadata)
        
        logger.info(f"ğŸ“‹ ì£¼ë¬¸ ìƒíƒœ: {order_id} {current.value} â†’ {new_state.value}")
    
    def get_pending_orders(self) -> List[dict]:
        """ë¯¸ì²´ê²° ì£¼ë¬¸ ëª©ë¡ (SUBMITTED + PARTIAL_FILLED)"""
        return [
            {"order_id": oid, **odata}
            for oid, odata in self._orders.items()
            if odata["state"] in (OrderState.SUBMITTED, OrderState.PARTIAL_FILLED)
        ]
```

### 10.3 ë¯¸ì²´ê²° ì£¼ë¬¸ ì¶”ì ê¸° (Order Tracker) [v1.1 NEW]

> **ìë™ ì·¨ì†Œ/ì •ì •:** ë¯¸ì²´ê²° ì£¼ë¬¸ì´ ì„¤ì •ëœ ìœ íš¨ì‹œê°„(ê¸°ë³¸ 5ë¶„)ì„ ì´ˆê³¼í•˜ë©´
> ìë™ìœ¼ë¡œ ì·¨ì†Œ ìš”ì²­í•˜ê±°ë‚˜, ì‹œì¥ê°€ë¡œ ì •ì •í•©ë‹ˆë‹¤.

```python
class OrderTracker:
    """
    [v1.1 NEW] ë¯¸ì²´ê²° ì£¼ë¬¸ ì¶”ì  ë° ìë™ ì²˜ë¦¬
    
    ê¸°ëŠ¥:
    1. ë¯¸ì²´ê²° ì£¼ë¬¸ ìœ íš¨ì‹œê°„ ê°ì‹œ (ê¸°ë³¸ 5ë¶„)
    2. íƒ€ì„ì•„ì›ƒ ì‹œ ìë™ ì·¨ì†Œ ë˜ëŠ” í˜¸ê°€ ì •ì •
    3. ë¶€ë¶„ ì²´ê²° ì£¼ë¬¸ì˜ ì”ëŸ‰ ì²˜ë¦¬
    4. ë¯¸ì²´ê²° ì£¼ë¬¸ì´ ë¬¶ëŠ” ìê¸ˆ(Margin) ì‹¤ì‹œê°„ ì¶”ì 
    """
    
    DEFAULT_ORDER_TTL_SEC = 300  # ì£¼ë¬¸ ìœ íš¨ì‹œê°„ (5ë¶„)
    
    # ì „ëµë³„ ìœ íš¨ì‹œê°„ ì»¤ìŠ¤í„°ë§ˆì´ì§•
    STRATEGY_TTL = {
        "VB": 60,    # ë³€ë™ì„± ëŒíŒŒ: 1ë¶„ (ë¹ ë¥¸ ì§„ì… í•„ìˆ˜)
        "S2": 120,   # Gap & Go: 2ë¶„
        "GR": 600,   # ê·¸ë¦¬ë“œ: 10ë¶„ (ì¸ë‚´ í•„ìš”)
    }
    
    def __init__(self, state_machine: OrderStateMachine, 
                 rest_client: KISRestClient):
        self.state_machine = state_machine
        self.rest_client = rest_client
        self._running = False
    
    async def start_tracking(self):
        """ë¯¸ì²´ê²° ì£¼ë¬¸ ê°ì‹œ ë£¨í”„ (10ì´ˆ ê°„ê²©)"""
        self._running = True
        while self._running:
            await self._check_pending_orders()
            await asyncio.sleep(10)
    
    async def _check_pending_orders(self):
        """ë¯¸ì²´ê²° ì£¼ë¬¸ íƒ€ì„ì•„ì›ƒ í™•ì¸ ë° ìë™ ì²˜ë¦¬"""
        pending = self.state_machine.get_pending_orders()
        now = datetime.now()
        
        for order in pending:
            order_id = order["order_id"]
            strategy = order["data"].get("strategy_code", "")
            ttl = self.STRATEGY_TTL.get(strategy, self.DEFAULT_ORDER_TTL_SEC)
            
            elapsed = (now - order["created_at"]).total_seconds()
            
            if elapsed > ttl:
                logger.warning(
                    f"â° ì£¼ë¬¸ íƒ€ì„ì•„ì›ƒ: {order_id} ({elapsed:.0f}ì´ˆ > {ttl}ì´ˆ)"
                )
                
                if order["state"] == OrderState.PARTIAL_FILLED:
                    # ë¶€ë¶„ ì²´ê²°: ì”ëŸ‰ë§Œ ì·¨ì†Œ
                    await self._cancel_remaining(order_id, order)
                else:
                    # ë¯¸ì²´ê²°: ì „ëŸ‰ ì·¨ì†Œ
                    await self._cancel_order(order_id, order)
            
            elif elapsed > ttl * 0.8:
                # 80% ì‹œê°„ ê²½ê³¼: í˜¸ê°€ ì •ì • ì‹œë„
                await self._amend_to_market_price(order_id, order)
    
    async def _cancel_order(self, order_id: str, order: dict):
        """ë¯¸ì²´ê²° ì£¼ë¬¸ ìë™ ì·¨ì†Œ"""
        try:
            await self.state_machine.transition(
                order_id, OrderState.CANCEL_REQUESTED,
                metadata={"reason": "TTL_EXPIRED"}
            )
            # KIS API ì·¨ì†Œ ìš”ì²­
            result = await self.rest_client.cancel_order(
                order_no=order["data"]["kis_order_no"],
                stock_code=order["data"]["stock_code"]
            )
            if result.get("rt_cd") == "0":
                await self.state_machine.transition(order_id, OrderState.CANCELLED)
                logger.info(f"âœ… ë¯¸ì²´ê²° ìë™ ì·¨ì†Œ ì™„ë£Œ: {order_id}")
            
        except Exception as e:
            logger.error(f"âŒ ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {order_id} â€” {e}")
    
    async def _amend_to_market_price(self, order_id: str, order: dict):
        """í˜¸ê°€ ì •ì •: í˜„ì¬ ì‹œì¥ê°€ ê¸°ì¤€ìœ¼ë¡œ ì¬ì „ì†¡"""
        try:
            await self.state_machine.transition(
                order_id, OrderState.AMEND_REQUESTED,
                metadata={"reason": "APPROACHING_TTL"}
            )
            result = await self.rest_client.modify_order(
                order_no=order["data"]["kis_order_no"],
                stock_code=order["data"]["stock_code"],
                new_price=0,  # ì‹œì¥ê°€
                order_dvsn="01"  # ì‹œì¥ê°€ ì£¼ë¬¸
            )
            if result.get("rt_cd") == "0":
                await self.state_machine.transition(order_id, OrderState.SUBMITTED)
                logger.info(f"ğŸ”„ í˜¸ê°€ ì •ì • ì™„ë£Œ: {order_id} â†’ ì‹œì¥ê°€")
                
        except Exception as e:
            logger.error(f"âŒ í˜¸ê°€ ì •ì • ì‹¤íŒ¨: {order_id} â€” {e}")
    
    async def _cancel_remaining(self, order_id: str, order: dict):
        """ë¶€ë¶„ ì²´ê²° ì£¼ë¬¸ì˜ ì”ëŸ‰ ì·¨ì†Œ"""
        await self._cancel_order(order_id, order)
        logger.info(
            f"ğŸ“Š ë¶€ë¶„ ì²´ê²° ì”ëŸ‰ ì·¨ì†Œ: {order_id} "
            f"(ì²´ê²° {order.get('filled_qty', 0)}ì£¼ / ì”ëŸ‰ ì·¨ì†Œ)"
        )
    
    def get_locked_capital(self) -> float:
        """ë¯¸ì²´ê²° ì£¼ë¬¸ì´ ë¬¶ê³  ìˆëŠ” ì´ ì˜ˆì•½ ê¸ˆì•¡"""
        pending = self.state_machine.get_pending_orders()
        return sum(o["data"].get("reserved_amount", 0) for o in pending)
```

### 10.4 ì£¼ë¬¸ ì‹¤íŒ¨ ìƒì„¸ ì²˜ë¦¬

```python
class OrderErrorHandler:
    """ì£¼ë¬¸ ì‹¤íŒ¨ ì›ì¸ë³„ ë¶„ê¸° ì²˜ë¦¬"""
    
    ERROR_RESPONSES = {
        "OPSQ0004": {  # ë§¤ë§¤ì œí•œì¢…ëª©
            "action": "skip",
            "message": "ë§¤ë§¤ì œí•œì¢…ëª© â€” í•´ë‹¹ ì¢…ëª© ì œì™¸"
        },
        "OPSQ0005": {  # ê°€ê²©ì œí•œ ì´ˆê³¼
            "action": "adjust_price",
            "message": "ê°€ê²© ë²”ìœ„ ì´ˆê³¼ â€” ì‹œì¥ê°€ë¡œ ì¬ì£¼ë¬¸"
        },
        "OPSQ0009": {  # ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ ì´ˆê³¼
            "action": "reduce_quantity",
            "message": "ì£¼ë¬¸ê¸ˆì•¡ ì´ˆê³¼ â€” ìˆ˜ëŸ‰ ì¶•ì†Œ í›„ ì¬ì£¼ë¬¸"
        },
        "OPSQ0099": {  # ì‹œìŠ¤í…œ ì˜¤ë¥˜
            "action": "retry",
            "message": "ì¦ê¶Œì‚¬ ì‹œìŠ¤í…œ ì˜¤ë¥˜ â€” 3ì´ˆ í›„ ì¬ì‹œë„",
            "retry_count": 3,
            "retry_delay": 3
        },
    }
    
    async def handle_error(self, error_code: str, original_order: dict) -> dict:
        """ì—ëŸ¬ ì½”ë“œë³„ ìë™ ëŒ€ì‘"""
        handler = self.ERROR_RESPONSES.get(error_code)
        if not handler:
            logger.error(f"ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ ì½”ë“œ: {error_code}")
            return {"action": "manual_review", "order": original_order}
        
        if handler["action"] == "retry":
            for i in range(handler["retry_count"]):
                await asyncio.sleep(handler["retry_delay"])
                result = await self.order_manager.retry_order(original_order)
                if result["success"]:
                    return result
        
        elif handler["action"] == "reduce_quantity":
            reduced = original_order.copy()
            reduced["quantity"] = int(original_order["quantity"] * 0.8)
            return await self.order_manager.place_order(**reduced)
        
        return {"action": handler["action"], "message": handler["message"]}
```

### 10.5 ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬

```python
class HealthChecker:
    """ì‹œìŠ¤í…œ ìƒíƒœ ì£¼ê¸°ì  ì ê²€ (ë§¤ 5ë¶„)"""
    
    async def check_all(self) -> dict:
        return {
            "api_connection": await self._check_api(),
            "websocket": await self._check_websocket(),
            "database": await self._check_database(),
            "token_valid": self._check_token(),
            "disk_space": self._check_disk(),
            "memory_usage": self._check_memory(),
            "timestamp": datetime.now().isoformat(),
        }
    
    async def _check_api(self) -> dict:
        """REST API ì—°ê²° ìƒíƒœ í™•ì¸ (ì½”ìŠ¤í”¼ ì§€ìˆ˜ ì¡°íšŒ)"""
        try:
            start = time.monotonic()
            result = await self.rest_client.get_current_price("0001")  # ì½”ìŠ¤í”¼ ì§€ìˆ˜
            latency = (time.monotonic() - start) * 1000
            return {"status": "OK", "latency_ms": round(latency, 1)}
        except Exception as e:
            return {"status": "ERROR", "error": str(e)}
```

---

## 11. ë°°í¬ ë° ìš´ì˜

### 11.1 ì‹¤í–‰ ìŠ¤ì¼€ì¤„

```python
DAILY_SCHEDULE = {
    "06:30": "ì‹œìŠ¤í…œ ê¸°ë™ + í—¬ìŠ¤ì²´í¬ + Redis ì—°ê²° í™•ì¸",
    "08:00": "í† í° ê°±ì‹  í™•ì¸",
    "08:30": "ì¢…ëª© ìŠ¤ìºë‹ (StockScreener.scan_daily) â€” REST ì‚¬ìš©",
    "08:50": "ì „ëµ ì„ íƒ + ë§¤ë§¤ ì‹œë‚˜ë¦¬ì˜¤ ì¤€ë¹„",
    "09:00": "WebSocket êµ¬ë… ì‹œì‘ + VIëª¨ë‹ˆí„° ê¸°ë™ + OrderTracker ì‹œì‘",  # [v1.1]
    "09:00~15:30": "ì‹¤ì‹œê°„ ë§¤ë§¤ ë£¨í”„ (ì‹œì„¸=ìºì‹œ ì½ê¸°, ì£¼ë¬¸=REST)",
    "15:30": "ì¥ ë§ˆê° â€” OrderTracker ë¯¸ì²´ê²° ì „ëŸ‰ ì·¨ì†Œ",                    # [v1.1]
    "15:40": "Redis â†’ DB Bulk Insert + ì¼ê°„ í†µê³„ ì§‘ê³„",                    # [v1.1]
    "16:00": "ì„±ê³¼ ë¦¬í¬íŠ¸ ìƒì„± + ì•Œë¦¼ ì „ì†¡",
    "16:30": "WebSocket ì—°ê²° ì¢…ë£Œ + Redis ìºì‹œ ì´ˆê¸°í™”",                    # [v1.1]
    "ë§¤ì£¼ ê¸ˆìš”ì¼ 16:00": "ì£¼ê°„ ë¦¬ë·° ìƒì„±",
    "ë§¤ì›” ë§ 16:00": "ì›”ê°„ ë¦¬ë·° + SQN ì‚°ì¶œ",
}
```

### 11.2 í™˜ê²½ ì„¤ì •

```python
# config/settings.py
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    # KIS API
    KIS_APP_KEY = os.getenv("KIS_APP_KEY")
    KIS_APP_SECRET = os.getenv("KIS_APP_SECRET")
    KIS_ACCOUNT_NO = os.getenv("KIS_ACCOUNT_NO")
    KIS_ACCOUNT_PROD_CODE = os.getenv("KIS_ACCOUNT_PROD_CODE", "01")
    
    # ë§¤ë§¤ ëª¨ë“œ
    TRADE_MODE = os.getenv("TRADE_MODE", "PAPER")  # LIVE / PAPER
    
    # ë°ì´í„°ë² ì´ìŠ¤
    DB_TYPE = os.getenv("DB_TYPE", "sqlite")  # sqlite / postgresql
    DB_URL = os.getenv("DB_URL", "sqlite:///kats.db")
    REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")  # [v1.1] Redis ë²„í¼
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    TOTAL_CAPITAL = int(os.getenv("TOTAL_CAPITAL", "100000000"))
    RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.02"))
    DAILY_LOSS_LIMIT = float(os.getenv("DAILY_LOSS_LIMIT", "0.03"))
    MONTHLY_LOSS_LIMIT = float(os.getenv("MONTHLY_LOSS_LIMIT", "0.06"))
    
    # ì•Œë¦¼
    SLACK_WEBHOOK_URL = os.getenv("SLACK_WEBHOOK_URL")
    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
```

### 11.3 ì˜ì¡´ì„± íŒ¨í‚¤ì§€

```
# requirements.txt
aiohttp>=3.9.0          # ë¹„ë™ê¸° HTTP í´ë¼ì´ì–¸íŠ¸
websockets>=12.0        # WebSocket í´ë¼ì´ì–¸íŠ¸
sqlalchemy>=2.0         # ORM
asyncpg>=0.29           # PostgreSQL ë¹„ë™ê¸° ë“œë¼ì´ë²„
aiosqlite>=0.20         # SQLite ë¹„ë™ê¸° ë“œë¼ì´ë²„
redis[hiredis]>=5.0     # [v1.1 NEW] Redis In-Memory ìºì‹œ/ë²„í¼
apscheduler>=3.10       # ìŠ¤ì¼€ì¤„ëŸ¬
python-dotenv>=1.0      # í™˜ê²½ ë³€ìˆ˜
numpy>=1.26             # ìˆ˜ì¹˜ ê³„ì‚° (ì§€í‘œ)
pandas>=2.1             # ë°ì´í„° ë¶„ì„
pydantic>=2.5           # ë°ì´í„° ê²€ì¦
structlog>=23.2         # êµ¬ì¡°í™” ë¡œê¹…
```

### 11.4 Redis ë²„í¼ â€” DB ì“°ê¸° ë³‘ëª© í•´ì†Œ [v1.1 NEW]

> **[v1.1 ë³€ê²½] ì‹¤ì‹œê°„ ì²´ê²° ë°ì´í„°ë¥¼ ë§¤ê±´ DBì— INSERTí•˜ë©´ ê³ ë³€ë™ì„± ì¥ì„¸ì—ì„œ I/O ë³‘ëª© ë°œìƒ.**
> Redisë¥¼ In-Memory ë²„í¼ë¡œ í™œìš©í•˜ì—¬ ì‹¤ì‹œê°„ ë°ì´í„°ë¥¼ ì¦‰ì‹œ ì €ì¥í•˜ê³ ,
> ì¥ ë§ˆê° í›„ DBì— Bulk Insert í•©ë‹ˆë‹¤.

```python
class RedisTickBuffer:
    """
    [v1.1 NEW] ì‹¤ì‹œê°„ í‹± ë°ì´í„° Redis ë²„í¼
    
    êµ¬ì¡°:
    - ì‹¤ì‹œê°„: WebSocket â†’ Redis (LPUSH, 0.1ms ì´ë‚´)
    - ë°°ì¹˜:   ì¥ ë§ˆê° í›„ Redis â†’ DB (Bulk INSERT)
    - ì¡°íšŒ:   Redisì—ì„œ ìµœê·¼ Nê±´ ì¦‰ì‹œ ì¡°íšŒ (LRANGE)
    
    í‚¤ ì„¤ê³„:
    - tick:{stock_code}:{YYYYMMDD}  â€” ì¼ë³„ í‹± ë°ì´í„° ë¦¬ìŠ¤íŠ¸
    - orderbook:{stock_code}        â€” ìµœì‹  í˜¸ê°€ (Hash)
    - vi:{stock_code}               â€” VI ìƒíƒœ (String)
    - stat:daily:{YYYYMMDD}         â€” ì¼ì¼ í†µê³„ (Hash)
    
    TTL:
    - í‹± ë°ì´í„°: 3ì¼ (ì´í›„ ìë™ ì‚­ì œ)
    - í˜¸ê°€/VI: TTL ì—†ìŒ (ì¥ ì‹œì‘ ì‹œ ì´ˆê¸°í™”)
    """
    
    TICK_TTL_DAYS = 3
    
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis = redis.asyncio.from_url(redis_url, decode_responses=True)
    
    async def buffer_tick(self, stock_code: str, tick_data: dict):
        """ì‹¤ì‹œê°„ í‹± ë°ì´í„° ë²„í¼ë§ (O(1), ~0.1ms)"""
        key = f"tick:{stock_code}:{datetime.now().strftime('%Y%m%d')}"
        await self.redis.lpush(key, json.dumps(tick_data, default=str))
        
        # í‚¤ê°€ ìƒˆë¡œ ìƒì„±ëœ ê²½ìš° TTL ì„¤ì •
        ttl = await self.redis.ttl(key)
        if ttl == -1:
            await self.redis.expire(key, self.TICK_TTL_DAYS * 86400)
    
    async def buffer_orderbook(self, stock_code: str, orderbook: dict):
        """í˜¸ê°€ ë°ì´í„° ë²„í¼ë§ (ìµœì‹  1ê±´ë§Œ ìœ ì§€)"""
        key = f"orderbook:{stock_code}"
        await self.redis.set(key, json.dumps(orderbook, default=str))
    
    async def flush_to_db(self, date_str: str, db_session):
        """
        ì¥ ë§ˆê° í›„ Redis â†’ DB Bulk Insert
        
        15:40 ìŠ¤ì¼€ì¤„ì—ì„œ í˜¸ì¶œë©ë‹ˆë‹¤.
        """
        pattern = f"tick:*:{date_str}"
        keys = []
        async for key in self.redis.scan_iter(pattern):
            keys.append(key)
        
        total_rows = 0
        for key in keys:
            # Redisì—ì„œ ì „ì²´ í‹± ì¡°íšŒ
            ticks = await self.redis.lrange(key, 0, -1)
            if not ticks:
                continue
            
            # JSON íŒŒì‹± â†’ ORM ê°ì²´ ë³€í™˜
            records = [json.loads(t) for t in ticks]
            
            # Bulk Insert (1000ê±´ì”© ë°°ì¹˜)
            for batch_start in range(0, len(records), 1000):
                batch = records[batch_start:batch_start + 1000]
                await db_session.execute(
                    insert(TickDataTable).values(batch)
                )
                total_rows += len(batch)
            
            await db_session.commit()
        
        logger.info(f"ğŸ“¦ Redis â†’ DB Bulk Insert ì™„ë£Œ: {total_rows}ê±´ ({date_str})")
        return total_rows
    
    async def get_recent_ticks(self, stock_code: str, count: int = 100) -> list:
        """ìµœê·¼ Nê±´ í‹± ë°ì´í„° ì¡°íšŒ (Redisì—ì„œ ì¦‰ì‹œ)"""
        key = f"tick:{stock_code}:{datetime.now().strftime('%Y%m%d')}"
        ticks = await self.redis.lrange(key, 0, count - 1)
        return [json.loads(t) for t in ticks]
```

### 11.5 ê°€ìƒ ë§¤ë§¤ (Paper Trading) ì„¤ê³„ [v1.1 ê°•í™”]

> **[v1.1 ë³€ê²½] í˜¸ê°€ ì”ëŸ‰(Depth) ê¸°ë°˜ í˜„ì‹¤ì  ì²´ê²° ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ë³€ê²½.**
> ê¸°ì¡´ ì„¤ê³„ëŠ” í˜¸ê°€ 1ìˆœìœ„ì— ì¦‰ì‹œ ì „ëŸ‰ ì²´ê²°ë˜ëŠ” ë¹„í˜„ì‹¤ì  ëª¨ë¸ì´ì—ˆìŠµë‹ˆë‹¤.
> ì‹¤ì œ ì‹œì¥ì—ì„œëŠ” ëŒ€ëŸ‰ ì£¼ë¬¸ì´ í˜¸ê°€ë¥¼ ë°€ì–´ì˜¬ë¦¬ê±°ë‚˜ ë¶€ë¶„ ì²´ê²°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
class PaperTradingEngine:
    """
    [v1.1 ê°•í™”] í˜¸ê°€ ì”ëŸ‰ ê¸°ë°˜ í˜„ì‹¤ì  ê°€ìƒ ë§¤ë§¤ ì—”ì§„
    
    ë³€ê²½ì‚¬í•­ (v1.0 â†’ v1.1):
    - í˜¸ê°€ ì”ëŸ‰(Size) ì²´í¬: ì£¼ë¬¸ìˆ˜ëŸ‰ì´ ì”ëŸ‰ì˜ 20% ì´ˆê³¼ ì‹œ ë¶€ë¶„ ì²´ê²°
    - ì‹œì¥ ì¶©ê²©(Market Impact) ëª¨ë¸: ëŒ€ëŸ‰ ì£¼ë¬¸ ì‹œ ì²´ê²° ê°€ê²© ë¶ˆë¦¬í•˜ê²Œ ì‚°ì •
    - ì²´ê²° ì§€ì—° ì‹œë®¬ë ˆì´ì…˜: ê±°ë˜ëŸ‰ ëŒ€ë¹„ ì£¼ë¬¸ í¬ê¸°ì— ë”°ë¼ ì§€ì—°
    - WebSocket ìºì‹œì—ì„œ í˜¸ê°€ ì¡°íšŒ (REST ì§ì ‘ í˜¸ì¶œ ì œê±°)
    """
    
    # í˜¸ê°€ ì”ëŸ‰ ëŒ€ë¹„ ìµœëŒ€ ì¦‰ì‹œ ì²´ê²° ë¹„ìœ¨
    MAX_INSTANT_FILL_RATIO = 0.20  # ì”ëŸ‰ì˜ 20% ì´ë‚´ë§Œ ì¦‰ì‹œ ì²´ê²°
    
    # ì‹œì¥ ì¶©ê²© ê³„ìˆ˜ (ì£¼ë¬¸ë¹„ìœ¨ Ã— ì´ ê³„ìˆ˜ = ì¶”ê°€ ìŠ¬ë¦¬í”¼ì§€ %)
    MARKET_IMPACT_COEFF = 0.05
    
    # ê¸°ë³¸ ìŠ¬ë¦¬í”¼ì§€
    BASE_SLIPPAGE_PCT = 0.1
    
    def __init__(self, cache: RealtimeCache):
        self.cache = cache  # [v1.1] REST ëŒ€ì‹  ìºì‹œì—ì„œ ì½ê¸°
    
    async def execute_virtual_order(self, order: dict) -> dict:
        """[v1.1] í˜¸ê°€ ì”ëŸ‰ ê¸°ë°˜ ê°€ìƒ ì£¼ë¬¸ ì²´ê²° ì²˜ë¦¬"""
        stock_code = order["stock_code"]
        quantity = order["quantity"]
        
        # 1. [v1.1] ìºì‹œì—ì„œ í˜¸ê°€ ì¡°íšŒ (REST í˜¸ì¶œ ì œê±°)
        orderbook = self.cache.get_orderbook(stock_code)
        if not orderbook:
            return {"success": False, "error": "í˜¸ê°€ ë°ì´í„° ì—†ìŒ (WebSocket ë¯¸ìˆ˜ì‹ )"}
        
        if order["order_type"] == "BUY":
            best_price = orderbook.ask_prices[0]
            best_volume = orderbook.ask_volumes[0]
        else:
            best_price = orderbook.bid_prices[0]
            best_volume = orderbook.bid_volumes[0]
        
        # 2. [v1.1 NEW] í˜¸ê°€ ì”ëŸ‰ ëŒ€ë¹„ ì£¼ë¬¸ í¬ê¸° ë¹„ìœ¨ ì‚°ì¶œ
        fill_ratio = quantity / best_volume if best_volume > 0 else float('inf')
        
        # 3. [v1.1 NEW] ë¶€ë¶„ ì²´ê²° íŒì •
        if fill_ratio > self.MAX_INSTANT_FILL_RATIO:
            # ëŒ€ëŸ‰ ì£¼ë¬¸: ë¶€ë¶„ ì²´ê²° + ë‚˜ë¨¸ì§€ ë‹¤ìŒ í˜¸ê°€ë¡œ ì‹œë®¬ë ˆì´ì…˜
            instant_qty = int(best_volume * self.MAX_INSTANT_FILL_RATIO)
            remaining_qty = quantity - instant_qty
            
            # ì‹œì¥ ì¶©ê²© ì¶”ê°€ ìŠ¬ë¦¬í”¼ì§€
            impact_slippage = fill_ratio * self.MARKET_IMPACT_COEFF
            total_slippage = self.BASE_SLIPPAGE_PCT + impact_slippage
            
            # ë‹¤ìŒ í˜¸ê°€ì—ì„œ ë‚˜ë¨¸ì§€ ì²´ê²° (ê°€ê²© ë¶ˆë¦¬)
            if order["order_type"] == "BUY":
                fill_price_1 = best_price * (1 + self.BASE_SLIPPAGE_PCT / 100)
                fill_price_2 = orderbook.ask_prices[1] * (1 + impact_slippage / 100)
            else:
                fill_price_1 = best_price * (1 - self.BASE_SLIPPAGE_PCT / 100)
                fill_price_2 = orderbook.bid_prices[1] * (1 - impact_slippage / 100)
            
            avg_fill_price = (
                (fill_price_1 * instant_qty + fill_price_2 * remaining_qty) / quantity
            )
            
            result = {
                "success": True,
                "fill_type": "PARTIAL_SIMULATED",  # [v1.1] ë¶€ë¶„ ì²´ê²° ì‹œë®¬ë ˆì´ì…˜
                "fill_price": round(avg_fill_price, 2),
                "instant_qty": instant_qty,
                "delayed_qty": remaining_qty,
                "simulated_slippage_pct": round(total_slippage, 4),
                "market_impact_pct": round(impact_slippage, 4),
                "fill_ratio_vs_depth": round(fill_ratio, 4),
                "mode": "PAPER"
            }
        else:
            # ì†ŒëŸ‰ ì£¼ë¬¸: ì¦‰ì‹œ ì „ëŸ‰ ì²´ê²°
            if order["order_type"] == "BUY":
                fill_price = best_price * (1 + self.BASE_SLIPPAGE_PCT / 100)
            else:
                fill_price = best_price * (1 - self.BASE_SLIPPAGE_PCT / 100)
            
            result = {
                "success": True,
                "fill_type": "FULL_INSTANT",
                "fill_price": round(fill_price, 2),
                "simulated_slippage_pct": self.BASE_SLIPPAGE_PCT,
                "market_impact_pct": 0,
                "fill_ratio_vs_depth": round(fill_ratio, 4),
                "mode": "PAPER"
            }
        
        # 4. ê°€ìƒ ê³„ì¢Œ DB ì—…ë°ì´íŠ¸
        await self._update_paper_account(order, result["fill_price"])
        
        return result
```

---

## ë¶€ë¡ A: ì „ëµ ì½”ë“œ ë§¤í•‘

| ì½”ë“œ | ì „ëµëª… | ì¹´í…Œê³ ë¦¬ | ê·¼ê±° ë„ì„œ | ëŒ€ìƒ ë“±ê¸‰ | ê¸°ë³¸ ë¹„ì¤‘ |
|------|--------|---------|----------|----------|----------|
| S1 | SEPA ëª¨ë©˜í…€ ëŒíŒŒ | ìƒìŠ¹ì¥ | Minervini | B | 15~20% |
| S2 | Gap & Go ëˆŒë¦¼ëª© ë§¤ìˆ˜ | ìƒìŠ¹ì¥ | Cameron, Aziz | B~C | 10~15% |
| S3 | CAN SLIM ëŒíŒŒ ë§¤ë§¤ | ìƒìŠ¹ì¥ | O'Neil | A | 20~30% |
| S4 | Triple Screen ì¶”ì„¸ ì¶”ì¢… | ìƒìŠ¹ì¥ | Elder | A~B | 20~25% |
| S5 | VWAP ë°”ìš´ìŠ¤ | ìƒìŠ¹ì¥ | Carter, Aziz | A | 20~30% |
| B1 | ë°ë“œìº£ ë°”ìš´ìŠ¤ | í•˜ë½ì¥ | Staley, Turner | A | 10~15% |
| B2 | ì¸ë²„ìŠ¤ ETF | í•˜ë½ì¥ | Staley, Pring | ETF | 15~20% |
| B3 | ë°•ìŠ¤ê¶Œ ë ˆì¸ì§€ ë§¤ë§¤ | í•˜ë½ì¥ | Nison, Murphy | A~B | 10~15% |
| B4 | ê³¼ë§¤ë„ ì—­ë°œìƒ | í•˜ë½ì¥ | Steenbarger | A(ë°©ì–´ì£¼) | 10~15% |
| VB | ë³€ë™ì„± ëŒíŒŒ | ì¤‘ë¦½ | ë˜ë¦¬ ìœŒë¦¬ì—„ìŠ¤ | A~B | ê°€ë³€ |
| GR | ê·¸ë¦¬ë“œ ë§¤ë§¤ | ì¤‘ë¦½ | (ë°•ìŠ¤ê¶Œ ì „ëµ) | A~B | ê·¸ë¦¬ë“œë‹¹ 5% |
| DS | ë°°ë‹¹ì£¼ ìŠ¤ìœ„ì¹­ | ì¤‘ë¦½ | (ë°°ë‹¹ ìº˜ë¦°ë”) | A | ê°€ë³€ |

## ë¶€ë¡ B: ì½”ìŠ¤í”¼ ìµœì  ë§¤ë§¤ ì‹œê°„ëŒ€

| ì‹œê°„ëŒ€ | íŠ¹ì„± | ì í•© ì „ëµ | ì‹œìŠ¤í…œ ë™ì‘ |
|--------|------|----------|-----------|
| 09:00~09:15 | ê°­ í˜•ì„± + ìµœëŒ€ ë³€ë™ì„± ë…¸ì´ì¦ˆ | **ê´€ì°°ë§Œ (ë§¤ìˆ˜ ê¸ˆì§€)** | ë°ì´í„° ìˆ˜ì§‘ë§Œ, ì‹ í˜¸ ìƒì„± ì°¨ë‹¨ |
| 09:15~09:30 | ì´ˆë°˜ ìˆ˜ê¸‰ ë°©í–¥ í™•ì¸ | Gap & Go (ê²½í—˜ì í•œì •) | S2 ì „ëµë§Œ í™œì„±í™” |
| 09:30~10:30 | â­ **ìŠ¹ë¥  ìµœê³  êµ¬ê°„** | VWAP, SEPA, CAN SLIM | ì „ ì „ëµ í™œì„±í™” |
| 10:30~14:00 | ê±°ë˜ëŸ‰ ê°ì†Œ, íš¡ë³´ | ë°•ìŠ¤ê¶Œ ë§¤ë§¤, ê´€ë§ | GR, B3ë§Œ í™œì„±í™” |
| 14:00~15:20 | ë§ˆê° ì „ ê±°ë˜ëŸ‰ ì¦ê°€ | ì¢…ê°€ ë§¤ë§¤, ì¶”ì„¸ í™•ì¸ | ì²­ì‚° ìœ„ì£¼ |
| 15:20~15:30 | ì¢…ê°€ ë‹¨ì¼ê°€ | ìµì¼ ê°­ ìƒìŠ¹ ê¸°ëŒ€ ë§¤ìˆ˜ | DS ì „ëµ í™œì„±í™” |

## ë¶€ë¡ C: ìˆ˜ê¸‰ êµì°¨ ê²€ì¦ ë§¤íŠ¸ë¦­ìŠ¤

| ê¸°ìˆ ì  ì¡°ê±´ | ì™¸êµ­ì¸/ê¸°ê´€ ìˆ˜ê¸‰ | íŒë‹¨ | ë¹„ì¤‘ ì¡°ì • |
|------------|----------------|------|----------|
| âœ… ì¶©ì¡± | âœ… ìˆœë§¤ìˆ˜ ë™í–‰ | **ì ê·¹ ì§„ì…** | í™•ì‹ ë„ +1 â†’ ë“±ê¸‰ ìµœëŒ€ ë¹„ì¤‘ |
| âœ… ì¶©ì¡± | âš ï¸ ì¤‘ë¦½/í˜¼ì¡° | **ê¸°ë³¸ ì§„ì…** | í™•ì‹ ë„ ìœ ì§€ â†’ ê¸°ë³¸ ë¹„ì¤‘ |
| âœ… ì¶©ì¡± | âŒ ìˆœë§¤ë„ ì—­í–‰ | **ì†Œê·¹ ì§„ì… ë˜ëŠ” ê´€ë§** | í™•ì‹ ë„ -1 â†’ ë¹„ì¤‘ 50% ì¶•ì†Œ |
| âŒ ë¯¸ì¶©ì¡± | âœ… ìˆœë§¤ìˆ˜ | **ë§¤ë§¤ ê¸ˆì§€** | ìˆ˜ê¸‰ë§Œìœ¼ë¡œ ì§„ì…í•˜ì§€ ì•ŠìŒ |

---

## ë¶€ë¡ D: v1.1 ë³€ê²½ ì´ë ¥ (ì˜¤ë¥˜ ì§€ì ì‚¬í•­ ë°˜ì˜)

| # | ì§€ì  ì‚¬í•­ | ëŒ€ì‘ | ê´€ë ¨ ì„¹ì…˜ | ì‹ ê·œ ëª¨ë“ˆ |
|---|----------|------|----------|----------|
| 1.1 | REST ì‹œì„¸ ì¡°íšŒ Race Condition | WebSocket ìºì‹œ ìš°ì„  ì•„í‚¤í…ì²˜ë¡œ ì „í™˜. ì „ëµ ì—”ì§„ì˜ REST ì§ì ‘ í˜¸ì¶œ ì œê±° | Â§2.2, Â§5.3, Â§5.4 | `realtime_cache.py` |
| 1.2 | Paper Trading ë¹„í˜„ì‹¤ì  ì²´ê²° | í˜¸ê°€ ì”ëŸ‰ ê¸°ë°˜ ë¶€ë¶„ ì²´ê²° + ì‹œì¥ ì¶©ê²© ëª¨ë¸ ë„ì… | Â§11.5 | `paper_trading.py` (ê°•í™”) |
| 1.3 | ì£¼ë¬¸ ìƒíƒœ ê´€ë¦¬ ê³µë°± | Order State Machine + Order Tracker (ë¯¸ì²´ê²° ìë™ ì·¨ì†Œ/ì •ì •) | Â§10.2, Â§10.3 | `order_state_machine.py`, `order_tracker.py` |
| 2.1 | VI(ë³€ë™ì„± ì™„í™”ì¥ì¹˜) ëŒ€ì‘ ë¶€ì¬ | VI ë°œë™ê°€ ì‹¤ì‹œê°„ ê°ì§€, ë°œë™ ì¤‘ ì£¼ë¬¸ ì°¨ë‹¨, í•´ì œ í›„ ê´€ì°° êµ¬ê°„ | Â§5.5, Â§7.1 (8ë‹¨ê³„) | `vi_monitor.py` |
| 2.2 | ë¯¸ìˆ˜/ì‹ ìš© ê±°ë˜ ì°¨ë‹¨ ë¯¸ë¹„ | Margin Guard â€” í˜„ê¸ˆ ì˜ˆìˆ˜ê¸ˆ ì‹¤ì‹œê°„ ëŒ€ì¡° í•˜ë“œìŠ¤íƒ‘ | Â§7.8, Â§7.1 (9ë‹¨ê³„) | `margin_guard.py` |
| 2.3 | ì „ëµ ê°„ ì¢…ëª© ì¤‘ë³µ ë¹„ì¤‘ | Global Position Lock â€” ì „ ì „ëµ í•©ì‚° ì¢…ëª©ë³„ ë¹„ì¤‘ í•œë„ | Â§7.7, Â§7.1 (7ë‹¨ê³„) | `global_position_lock.py` |
| 3.1 | DB ì“°ê¸° ë³‘ëª© | Redis In-Memory ë²„í¼ â†’ ì¥ ë§ˆê° í›„ Bulk Insert | Â§11.4 | `redis_buffer.py` |
| 3.2 | MCP ëª…ë ¹ ë³´ì•ˆ | Human-in-the-loop í•„ìˆ˜ â€” ë©”ì‹ ì € ìŠ¹ì¸ í›„ ì‹¤í–‰ | Â§9.1 | `approval_gateway.py` |

**ì´ ì‹ ê·œ ëª¨ë“ˆ: 8ê°œ** | **ë¦¬ìŠ¤í¬ íŒŒì´í”„ë¼ì¸: 6ë‹¨ê³„ â†’ 9ë‹¨ê³„** | **ê¸°ìˆ  ìŠ¤íƒ ì¶”ê°€: Redis**

---

> âš ï¸ **ë©´ì±… ì¡°í•­:** ë³¸ ì„¤ê³„ì„œëŠ” êµìœ¡/ì°¸ê³  ëª©ì ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, íˆ¬ì ì¡°ì–¸ì´ ì•„ë‹™ë‹ˆë‹¤. ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì˜ ëª¨ë“  íˆ¬ì íŒë‹¨ê³¼ ì†ì‹¤ì€ ìš´ìš©ì ë³¸ì¸ì—ê²Œ ìˆìœ¼ë©°, ë°˜ë“œì‹œ ì¶©ë¶„í•œ ë°±í…ŒìŠ¤íŠ¸ì™€ ëª¨ì˜íˆ¬ì(Paper Trading)ë¥¼ ê±°ì¹œ í›„ ì‹¤ì „ì— ì„í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì‹œìŠ¤í…œ ì˜¤ë¥˜, ë„¤íŠ¸ì›Œí¬ ì¥ì• , ì¦ê¶Œì‚¬ API ë³€ê²½ ë“±ìœ¼ë¡œ ì¸í•œ ì˜ˆê¸°ì¹˜ ì•Šì€ ì†ì‹¤ ê°€ëŠ¥ì„±ì„ í•­ìƒ ì¸ì§€í•˜ì‹­ì‹œì˜¤.
